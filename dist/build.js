var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/.pnpm/maplibre-gl@4.7.1/node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS({
  "node_modules/.pnpm/maplibre-gl@4.7.1/node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
    })(exports, function() {
      "use strict";
      var maplibregl2 = {};
      var modules = {};
      function define2(moduleName, _dependencies, moduleFactory) {
        modules[moduleName] = moduleFactory;
        if (moduleName !== "index") {
          return;
        }
        var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
        var sharedModule = {};
        modules.shared(sharedModule);
        modules.index(maplibregl2, sharedModule);
        if (typeof window !== "undefined") {
          maplibregl2.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
        }
        return maplibregl2;
      }
      ;
      define2("shared", ["exports"], function(t) {
        "use strict";
        function e(t2, e2, r2, n2) {
          return new (r2 || (r2 = Promise))(function(i2, s2) {
            function a2(t3) {
              try {
                l3(n2.next(t3));
              } catch (t4) {
                s2(t4);
              }
            }
            function o2(t3) {
              try {
                l3(n2.throw(t3));
              } catch (t4) {
                s2(t4);
              }
            }
            function l3(t3) {
              var e3;
              t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
                t4(e3);
              })).then(a2, o2);
            }
            l3((n2 = n2.apply(t2, e2 || [])).next());
          });
        }
        function r(t2) {
          return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        "function" == typeof SuppressedError && SuppressedError;
        var n = i;
        function i(t2, e2) {
          this.x = t2, this.y = e2;
        }
        i.prototype = { clone: function() {
          return new i(this.x, this.y);
        }, add: function(t2) {
          return this.clone()._add(t2);
        }, sub: function(t2) {
          return this.clone()._sub(t2);
        }, multByPoint: function(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint: function(t2) {
          return this.clone()._divByPoint(t2);
        }, mult: function(t2) {
          return this.clone()._mult(t2);
        }, div: function(t2) {
          return this.clone()._div(t2);
        }, rotate: function(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround: function(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        }, matMult: function(t2) {
          return this.clone()._matMult(t2);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist: function(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr: function(t2) {
          var e2 = t2.x - this.x, r2 = t2.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith: function(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep: function(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        }, _matMult: function(t2) {
          var e2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
        }, _add: function(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub: function(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult: function(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div: function(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint: function(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint: function(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate: function(t2) {
          var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround: function(t2, e2) {
          var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, i.convert = function(t2) {
          return t2 instanceof i ? t2 : Array.isArray(t2) ? new i(t2[0], t2[1]) : t2;
        };
        var s = r(n), a = o;
        function o(t2, e2, r2, n2) {
          this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
        }
        o.prototype = { sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, solveCurveX: function(t2, e2) {
          if (void 0 === e2 && (e2 = 1e-6), t2 < 0) return 0;
          if (t2 > 1) return 1;
          for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e2) return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 1e-6) break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++) t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        }, solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        } };
        var l2 = r(a);
        let u, c;
        function h() {
          return null == u && (u = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), u;
        }
        function p() {
          if (null == c && (c = false, h())) {
            const t2 = 5, e2 = new OffscreenCanvas(t2, t2).getContext("2d", { willReadFrequently: true });
            if (e2) {
              for (let r3 = 0; r3 < t2 * t2; r3++) {
                const n2 = 4 * r3;
                e2.fillStyle = "rgb(".concat(n2, ",").concat(n2 + 1, ",").concat(n2 + 2, ")"), e2.fillRect(r3 % t2, Math.floor(r3 / t2), 1, 1);
              }
              const r2 = e2.getImageData(0, 0, t2, t2).data;
              for (let e3 = 0; e3 < t2 * t2 * 4; e3++) if (e3 % 4 != 3 && r2[e3] !== e3) {
                c = true;
                break;
              }
            }
          }
          return c || false;
        }
        function f(t2, e2, r2, n2) {
          const i2 = new l2(t2, e2, r2, n2);
          return (t3) => i2.solve(t3);
        }
        const d = f(0.25, 0.1, 0.25, 1);
        function y2(t2, e2, r2) {
          return Math.min(r2, Math.max(e2, t2));
        }
        function m(t2, e2, r2) {
          const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
          return i2 === e2 ? r2 : i2;
        }
        function g(t2, ...e2) {
          for (const r2 of e2) for (const e3 in r2) t2[e3] = r2[e3];
          return t2;
        }
        let x = 1;
        function v(t2, e2, r2) {
          const n2 = {};
          for (const r3 in t2) n2[r3] = e2.call(this, t2[r3], r3, t2);
          return n2;
        }
        function b(t2, e2, r2) {
          const n2 = {};
          for (const r3 in t2) e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
          return n2;
        }
        function w(t2) {
          return Array.isArray(t2) ? t2.map(w) : "object" == typeof t2 && t2 ? v(t2, w) : t2;
        }
        const _ = {};
        function A2(t2) {
          _[t2] || ("undefined" != typeof console && console.warn(t2), _[t2] = true);
        }
        function S(t2, e2, r2) {
          return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
        }
        function k(t2) {
          return "undefined" != typeof WorkerGlobalScope && void 0 !== t2 && t2 instanceof WorkerGlobalScope;
        }
        let M2 = null;
        function I(t2) {
          return "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap;
        }
        const z2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function P(t2, r2, n2, i2, s2) {
          return e(this, void 0, void 0, function* () {
            if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
            const e2 = new VideoFrame(t2, { timestamp: 0 });
            try {
              const a2 = null == e2 ? void 0 : e2.format;
              if (!a2 || !a2.startsWith("BGR") && !a2.startsWith("RGB")) throw new Error("Unrecognized format ".concat(a2));
              const o2 = a2.startsWith("BGR"), l3 = new Uint8ClampedArray(i2 * s2 * 4);
              if (yield e2.copyTo(l3, function(t3, e3, r3, n3, i3) {
                const s3 = 4 * Math.max(-e3, 0), a3 = (Math.max(0, r3) - r3) * n3 * 4 + s3, o3 = 4 * n3, l4 = Math.max(0, e3), u2 = Math.max(0, r3);
                return { rect: { x: l4, y: u2, width: Math.min(t3.width, e3 + n3) - l4, height: Math.min(t3.height, r3 + i3) - u2 }, layout: [{ offset: a3, stride: o3 }] };
              }(t2, r2, n2, i2, s2)), o2) for (let t3 = 0; t3 < l3.length; t3 += 4) {
                const e3 = l3[t3];
                l3[t3] = l3[t3 + 2], l3[t3 + 2] = e3;
              }
              return l3;
            } finally {
              e2.close();
            }
          });
        }
        let C2, B;
        const V2 = "AbortError";
        function E() {
          return new Error(V2);
        }
        const F = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function T(t2) {
          return F.REGISTERED_PROTOCOLS[t2.substring(0, t2.indexOf("://"))];
        }
        const $ = "global-dispatcher";
        class L2 extends Error {
          constructor(t2, e2, r2, n2) {
            super("AJAXError: ".concat(e2, " (").concat(t2, "): ").concat(r2)), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
          }
        }
        const D = () => k(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, O = function(t2, r2) {
          if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
            const e2 = T(t2.url);
            if (e2) return e2(t2, r2);
            if (k(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t2, targetMapId: $ }, r2);
          }
          if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(D()) && !/^\w+:/.test(n2))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(t3, r3) {
              return e(this, void 0, void 0, function* () {
                const e2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, cache: t3.cache, referrer: D(), signal: r3.signal });
                "json" !== t3.type || e2.headers.has("Accept") || e2.headers.set("Accept", "application/json");
                const n3 = yield fetch(e2);
                if (!n3.ok) {
                  const e3 = yield n3.blob();
                  throw new L2(n3.status, n3.statusText, t3.url, e3);
                }
                let i2;
                i2 = "arrayBuffer" === t3.type || "image" === t3.type ? n3.arrayBuffer() : "json" === t3.type ? n3.json() : n3.text();
                const s2 = yield i2;
                if (r3.signal.aborted) throw E();
                return { data: s2, cacheControl: n3.headers.get("Cache-Control"), expires: n3.headers.get("Expires") };
              });
            }(t2, r2);
            if (k(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t2, mustQueue: true, targetMapId: $ }, r2);
          }
          var n2;
          return function(t3, e2) {
            return new Promise((r3, n3) => {
              var i2;
              const s2 = new XMLHttpRequest();
              s2.open(t3.method || "GET", t3.url, true), "arrayBuffer" !== t3.type && "image" !== t3.type || (s2.responseType = "arraybuffer");
              for (const e3 in t3.headers) s2.setRequestHeader(e3, t3.headers[e3]);
              "json" === t3.type && (s2.responseType = "text", (null === (i2 = t3.headers) || void 0 === i2 ? void 0 : i2.Accept) || s2.setRequestHeader("Accept", "application/json")), s2.withCredentials = "include" === t3.credentials, s2.onerror = () => {
                n3(new Error(s2.statusText));
              }, s2.onload = () => {
                if (!e2.signal.aborted) if ((s2.status >= 200 && s2.status < 300 || 0 === s2.status) && null !== s2.response) {
                  let e3 = s2.response;
                  if ("json" === t3.type) try {
                    e3 = JSON.parse(s2.response);
                  } catch (t4) {
                    return void n3(t4);
                  }
                  r3({ data: e3, cacheControl: s2.getResponseHeader("Cache-Control"), expires: s2.getResponseHeader("Expires") });
                } else {
                  const e3 = new Blob([s2.response], { type: s2.getResponseHeader("Content-Type") });
                  n3(new L2(s2.status, s2.statusText, t3.url, e3));
                }
              }, e2.signal.addEventListener("abort", () => {
                s2.abort(), n3(E());
              }), s2.send(t3.body);
            });
          }(t2, r2);
        };
        function j(t2) {
          if (!t2 || t2.indexOf("://") <= 0 || 0 === t2.indexOf("data:image/") || 0 === t2.indexOf("blob:")) return true;
          const e2 = new URL(t2), r2 = window.location;
          return e2.protocol === r2.protocol && e2.host === r2.host;
        }
        function R(t2, e2, r2) {
          r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
        }
        function U2(t2, e2, r2) {
          if (r2 && r2[t2]) {
            const n2 = r2[t2].indexOf(e2);
            -1 !== n2 && r2[t2].splice(n2, 1);
          }
        }
        class q {
          constructor(t2, e2 = {}) {
            g(this, e2), this.type = t2;
          }
        }
        class N extends q {
          constructor(t2, e2 = {}) {
            super("error", g({ error: t2 }, e2));
          }
        }
        class Z {
          on(t2, e2) {
            return this._listeners = this._listeners || {}, R(t2, e2, this._listeners), this;
          }
          off(t2, e2) {
            return U2(t2, e2, this._listeners), U2(t2, e2, this._oneTimeListeners), this;
          }
          once(t2, e2) {
            return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, R(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
          }
          fire(t2, e2) {
            "string" == typeof t2 && (t2 = new q(t2, e2 || {}));
            const r2 = t2.type;
            if (this.listens(r2)) {
              t2.target = this;
              const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
              for (const r3 of e3) r3.call(this, t2);
              const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
              for (const e4 of n2) U2(r2, e4, this._oneTimeListeners), e4.call(this, t2);
              const i2 = this._eventedParent;
              i2 && (g(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
            } else t2 instanceof N && console.error(t2.error);
            return this;
          }
          listens(t2) {
            return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
          }
          setEventedParent(t2, e2) {
            return this._eventedParent = t2, this._eventedParentData = e2, this;
          }
        }
        var G = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const K = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function X(t2, e2) {
          const r2 = {};
          for (const e3 in t2) "ref" !== e3 && (r2[e3] = t2[e3]);
          return K.forEach((t3) => {
            t3 in e2 && (r2[t3] = e2[t3]);
          }), r2;
        }
        function H(t2, e2) {
          if (Array.isArray(t2)) {
            if (!Array.isArray(e2) || t2.length !== e2.length) return false;
            for (let r2 = 0; r2 < t2.length; r2++) if (!H(t2[r2], e2[r2])) return false;
            return true;
          }
          if ("object" == typeof t2 && null !== t2 && null !== e2) {
            if ("object" != typeof e2) return false;
            if (Object.keys(t2).length !== Object.keys(e2).length) return false;
            for (const r2 in t2) if (!H(t2[r2], e2[r2])) return false;
            return true;
          }
          return t2 === e2;
        }
        function Y(t2, e2) {
          t2.push(e2);
        }
        function J2(t2, e2, r2) {
          Y(r2, { command: "addSource", args: [t2, e2[t2]] });
        }
        function W2(t2, e2, r2) {
          Y(e2, { command: "removeSource", args: [t2] }), r2[t2] = true;
        }
        function Q2(t2, e2, r2, n2) {
          W2(t2, r2, n2), J2(t2, e2, r2);
        }
        function tt2(t2, e2, r2) {
          let n2;
          for (n2 in t2[r2]) if (Object.prototype.hasOwnProperty.call(t2[r2], n2) && "data" !== n2 && !H(t2[r2][n2], e2[r2][n2])) return false;
          for (n2 in e2[r2]) if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && "data" !== n2 && !H(t2[r2][n2], e2[r2][n2])) return false;
          return true;
        }
        function et2(t2, e2, r2, n2, i2, s2) {
          t2 = t2 || {}, e2 = e2 || {};
          for (const a2 in t2) Object.prototype.hasOwnProperty.call(t2, a2) && (H(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
          for (const a2 in e2) Object.prototype.hasOwnProperty.call(e2, a2) && !Object.prototype.hasOwnProperty.call(t2, a2) && (H(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
        }
        function rt2(t2) {
          return t2.id;
        }
        function nt2(t2, e2) {
          return t2[e2.id] = e2, t2;
        }
        class it2 {
          constructor(t2, e2, r2, n2) {
            this.message = (t2 ? "".concat(t2, ": ") : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function st2(t2, ...e2) {
          for (const r2 of e2) for (const e3 in r2) t2[e3] = r2[e3];
          return t2;
        }
        class at2 extends Error {
          constructor(t2, e2) {
            super(e2), this.message = e2, this.key = t2;
          }
        }
        class ot2 {
          constructor(t2, e2 = []) {
            this.parent = t2, this.bindings = {};
            for (const [t3, r2] of e2) this.bindings[t3] = r2;
          }
          concat(t2) {
            return new ot2(this, t2);
          }
          get(t2) {
            if (this.bindings[t2]) return this.bindings[t2];
            if (this.parent) return this.parent.get(t2);
            throw new Error("".concat(t2, " not found in scope."));
          }
          has(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          }
        }
        const lt2 = { kind: "null" }, ut2 = { kind: "number" }, ct2 = { kind: "string" }, ht2 = { kind: "boolean" }, pt2 = { kind: "color" }, ft2 = { kind: "object" }, dt2 = { kind: "value" }, yt2 = { kind: "collator" }, mt2 = { kind: "formatted" }, gt2 = { kind: "padding" }, xt2 = { kind: "resolvedImage" }, vt2 = { kind: "variableAnchorOffsetCollection" };
        function bt2(t2, e2) {
          return { kind: "array", itemType: t2, N: e2 };
        }
        function wt2(t2) {
          if ("array" === t2.kind) {
            const e2 = wt2(t2.itemType);
            return "number" == typeof t2.N ? "array<".concat(e2, ", ").concat(t2.N, ">") : "value" === t2.itemType.kind ? "array" : "array<".concat(e2, ">");
          }
          return t2.kind;
        }
        const _t2 = [lt2, ut2, ct2, ht2, pt2, mt2, ft2, bt2(dt2), gt2, xt2, vt2];
        function At2(t2, e2) {
          if ("error" === e2.kind) return null;
          if ("array" === t2.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !At2(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N)) return null;
          } else {
            if (t2.kind === e2.kind) return null;
            if ("value" === t2.kind) {
              for (const t3 of _t2) if (!At2(t3, e2)) return null;
            }
          }
          return "Expected ".concat(wt2(t2), " but found ").concat(wt2(e2), " instead.");
        }
        function St2(t2, e2) {
          return e2.some((e3) => e3.kind === t2.kind);
        }
        function kt(t2, e2) {
          return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
        }
        function Mt2(t2, e2) {
          return "array" === t2.kind && "array" === e2.kind ? t2.itemType.kind === e2.itemType.kind && "number" == typeof t2.N : t2.kind === e2.kind;
        }
        const It2 = 0.96422, zt2 = 0.82521, Pt2 = 4 / 29, Ct2 = 6 / 29, Bt2 = 3 * Ct2 * Ct2, Vt2 = Ct2 * Ct2 * Ct2, Et2 = Math.PI / 180, Ft2 = 180 / Math.PI;
        function Tt2(t2) {
          return (t2 %= 360) < 0 && (t2 += 360), t2;
        }
        function $t2([t2, e2, r2, n2]) {
          let i2, s2;
          const a2 = Dt2((0.2225045 * (t2 = Lt2(t2)) + 0.7168786 * (e2 = Lt2(e2)) + 0.0606169 * (r2 = Lt2(r2))) / 1);
          t2 === e2 && e2 === r2 ? i2 = s2 = a2 : (i2 = Dt2((0.4360747 * t2 + 0.3850649 * e2 + 0.1430804 * r2) / It2), s2 = Dt2((0.0139322 * t2 + 0.0971045 * e2 + 0.7141733 * r2) / zt2));
          const o2 = 116 * a2 - 16;
          return [o2 < 0 ? 0 : o2, 500 * (i2 - a2), 200 * (a2 - s2), n2];
        }
        function Lt2(t2) {
          return t2 <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function Dt2(t2) {
          return t2 > Vt2 ? Math.pow(t2, 1 / 3) : t2 / Bt2 + Pt2;
        }
        function Ot2([t2, e2, r2, n2]) {
          let i2 = (t2 + 16) / 116, s2 = isNaN(e2) ? i2 : i2 + e2 / 500, a2 = isNaN(r2) ? i2 : i2 - r2 / 200;
          return i2 = 1 * Rt2(i2), s2 = It2 * Rt2(s2), a2 = zt2 * Rt2(a2), [jt(3.1338561 * s2 - 1.6168667 * i2 - 0.4906146 * a2), jt(-0.9787684 * s2 + 1.9161415 * i2 + 0.033454 * a2), jt(0.0719453 * s2 - 0.2289914 * i2 + 1.4052427 * a2), n2];
        }
        function jt(t2) {
          return (t2 = t2 <= 304e-5 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055) < 0 ? 0 : t2 > 1 ? 1 : t2;
        }
        function Rt2(t2) {
          return t2 > Ct2 ? t2 * t2 * t2 : Bt2 * (t2 - Pt2);
        }
        function Ut2(t2) {
          return parseInt(t2.padEnd(2, t2), 16) / 255;
        }
        function qt2(t2, e2) {
          return Nt2(e2 ? t2 / 100 : t2, 0, 1);
        }
        function Nt2(t2, e2, r2) {
          return Math.min(Math.max(e2, t2), r2);
        }
        function Zt2(t2) {
          return !t2.some(Number.isNaN);
        }
        const Gt2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        class Kt2 {
          constructor(t2, e2, r2, n2 = 1, i2 = true) {
            this.r = t2, this.g = e2, this.b = r2, this.a = n2, i2 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [t2, e2, r2, n2]));
          }
          static parse(t2) {
            if (t2 instanceof Kt2) return t2;
            if ("string" != typeof t2) return;
            const e2 = function(t3) {
              if ("transparent" === (t3 = t3.toLowerCase().trim())) return [0, 0, 0, 0];
              const e3 = Gt2[t3];
              if (e3) {
                const [t4, r3, n2] = e3;
                return [t4 / 255, r3 / 255, n2 / 255, 1];
              }
              if (t3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t3)) {
                const e4 = t3.length < 6 ? 1 : 2;
                let r3 = 1;
                return [Ut2(t3.slice(r3, r3 += e4)), Ut2(t3.slice(r3, r3 += e4)), Ut2(t3.slice(r3, r3 += e4)), Ut2(t3.slice(r3, r3 + e4) || "ff")];
              }
              if (t3.startsWith("rgb")) {
                const e4 = t3.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (e4) {
                  const [t4, r3, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2] = e4, f2 = [i2 || " ", o2 || " ", c2].join("");
                  if ("  " === f2 || "  /" === f2 || ",," === f2 || ",,," === f2) {
                    const t5 = [n2, a2, u2].join(""), e5 = "%%%" === t5 ? 100 : "" === t5 ? 255 : 0;
                    if (e5) {
                      const t6 = [Nt2(+r3 / e5, 0, 1), Nt2(+s2 / e5, 0, 1), Nt2(+l3 / e5, 0, 1), h2 ? qt2(+h2, p2) : 1];
                      if (Zt2(t6)) return t6;
                    }
                  }
                  return;
                }
              }
              const r2 = t3.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (r2) {
                const [t4, e4, n2, i2, s2, a2, o2, l3, u2] = r2, c2 = [n2 || " ", s2 || " ", o2].join("");
                if ("  " === c2 || "  /" === c2 || ",," === c2 || ",,," === c2) {
                  const t5 = [+e4, Nt2(+i2, 0, 100), Nt2(+a2, 0, 100), l3 ? qt2(+l3, u2) : 1];
                  if (Zt2(t5)) return function([t6, e5, r3, n3]) {
                    function i3(n4) {
                      const i4 = (n4 + t6 / 30) % 12, s3 = e5 * Math.min(r3, 1 - r3);
                      return r3 - s3 * Math.max(-1, Math.min(i4 - 3, 9 - i4, 1));
                    }
                    return t6 = Tt2(t6), e5 /= 100, r3 /= 100, [i3(0), i3(8), i3(4), n3];
                  }(t5);
                }
              }
            }(t2);
            return e2 ? new Kt2(...e2, false) : void 0;
          }
          get rgb() {
            const { r: t2, g: e2, b: r2, a: n2 } = this, i2 = n2 || 1 / 0;
            return this.overwriteGetter("rgb", [t2 / i2, e2 / i2, r2 / i2, n2]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(t2) {
              const [e2, r2, n2, i2] = $t2(t2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
              return [Math.round(1e4 * s2) ? Tt2(Math.atan2(n2, r2) * Ft2) : NaN, s2, e2, i2];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", $t2(this.rgb));
          }
          overwriteGetter(t2, e2) {
            return Object.defineProperty(this, t2, { value: e2 }), e2;
          }
          toString() {
            const [t2, e2, r2, n2] = this.rgb;
            return "rgba(".concat([t2, e2, r2].map((t3) => Math.round(255 * t3)).join(","), ",").concat(n2, ")");
          }
        }
        Kt2.black = new Kt2(0, 0, 0, 1), Kt2.white = new Kt2(1, 1, 1, 1), Kt2.transparent = new Kt2(0, 0, 0, 0), Kt2.red = new Kt2(1, 0, 0, 1);
        class Xt2 {
          constructor(t2, e2, r2) {
            this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t2, e2) {
            return this.collator.compare(t2, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Ht2 {
          constructor(t2, e2, r2, n2, i2) {
            this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
          }
        }
        class Yt2 {
          constructor(t2) {
            this.sections = t2;
          }
          static fromString(t2) {
            return new Yt2([new Ht2(t2, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
          }
          static factory(t2) {
            return t2 instanceof Yt2 ? t2 : Yt2.fromString(t2);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
          }
        }
        class Jt2 {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof Jt2) return t2;
            if ("number" == typeof t2) return new Jt2([t2, t2, t2, t2]);
            if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
              for (const e2 of t2) if ("number" != typeof e2) return;
              switch (t2.length) {
                case 1:
                  t2 = [t2[0], t2[0], t2[0], t2[0]];
                  break;
                case 2:
                  t2 = [t2[0], t2[1], t2[0], t2[1]];
                  break;
                case 3:
                  t2 = [t2[0], t2[1], t2[2], t2[1]];
              }
              return new Jt2(t2);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        const Wt2 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Qt2 {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof Qt2) return t2;
            if (Array.isArray(t2) && !(t2.length < 1) && t2.length % 2 == 0) {
              for (let e2 = 0; e2 < t2.length; e2 += 2) {
                const r2 = t2[e2], n2 = t2[e2 + 1];
                if ("string" != typeof r2 || !Wt2.has(r2)) return;
                if (!Array.isArray(n2) || 2 !== n2.length || "number" != typeof n2[0] || "number" != typeof n2[1]) return;
              }
              return new Qt2(t2);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        class te {
          constructor(t2) {
            this.name = t2.name, this.available = t2.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t2) {
            return t2 ? new te({ name: t2, available: false }) : null;
          }
        }
        function ee2(t2, e2, r2, n2) {
          return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : "Invalid rgba value [".concat([t2, e2, r2, n2].join(", "), "]: 'a' must be between 0 and 1.") : "Invalid rgba value [".concat(("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", "), "]: 'r', 'g', and 'b' must be between 0 and 255.");
        }
        function re2(t2) {
          if (null === t2 || "string" == typeof t2 || "boolean" == typeof t2 || "number" == typeof t2 || t2 instanceof Kt2 || t2 instanceof Xt2 || t2 instanceof Yt2 || t2 instanceof Jt2 || t2 instanceof Qt2 || t2 instanceof te) return true;
          if (Array.isArray(t2)) {
            for (const e2 of t2) if (!re2(e2)) return false;
            return true;
          }
          if ("object" == typeof t2) {
            for (const e2 in t2) if (!re2(t2[e2])) return false;
            return true;
          }
          return false;
        }
        function ne2(t2) {
          if (null === t2) return lt2;
          if ("string" == typeof t2) return ct2;
          if ("boolean" == typeof t2) return ht2;
          if ("number" == typeof t2) return ut2;
          if (t2 instanceof Kt2) return pt2;
          if (t2 instanceof Xt2) return yt2;
          if (t2 instanceof Yt2) return mt2;
          if (t2 instanceof Jt2) return gt2;
          if (t2 instanceof Qt2) return vt2;
          if (t2 instanceof te) return xt2;
          if (Array.isArray(t2)) {
            const e2 = t2.length;
            let r2;
            for (const e3 of t2) {
              const t3 = ne2(e3);
              if (r2) {
                if (r2 === t3) continue;
                r2 = dt2;
                break;
              }
              r2 = t3;
            }
            return bt2(r2 || dt2, e2);
          }
          return ft2;
        }
        function ie(t2) {
          const e2 = typeof t2;
          return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof Kt2 || t2 instanceof Yt2 || t2 instanceof Jt2 || t2 instanceof Qt2 || t2 instanceof te ? t2.toString() : JSON.stringify(t2);
        }
        class se2 {
          constructor(t2, e2) {
            this.type = t2, this.value = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("'literal' expression requires exactly one argument, but found ".concat(t2.length - 1, " instead."));
            if (!re2(t2[1])) return e2.error("invalid value");
            const r2 = t2[1];
            let n2 = ne2(r2);
            const i2 = e2.expectedType;
            return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new se2(n2, r2);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class ae2 {
          constructor(t2) {
            this.name = "ExpressionEvaluationError", this.message = t2;
          }
          toJSON() {
            return this.message;
          }
        }
        const oe = { string: ct2, number: ut2, boolean: ht2, object: ft2 };
        class le {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            let r2, n2 = 1;
            const i2 = t2[0];
            if ("array" === i2) {
              let i3, s3;
              if (t2.length > 2) {
                const r3 = t2[1];
                if ("string" != typeof r3 || !(r3 in oe) || "object" === r3) return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i3 = oe[r3], n2++;
              } else i3 = dt2;
              if (t2.length > 3) {
                if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2]))) return e2.error('The length argument to "array" must be a positive integer literal', 2);
                s3 = t2[2], n2++;
              }
              r2 = bt2(i3, s3);
            } else {
              if (!oe[i2]) throw new Error("Types doesn't contain name = ".concat(i2));
              r2 = oe[i2];
            }
            const s2 = [];
            for (; n2 < t2.length; n2++) {
              const r3 = e2.parse(t2[n2], n2, dt2);
              if (!r3) return null;
              s2.push(r3);
            }
            return new le(r2, s2);
          }
          evaluate(t2) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              const r2 = this.args[e2].evaluate(t2);
              if (!At2(this.type, ne2(r2))) return r2;
              if (e2 === this.args.length - 1) throw new ae2("Expected value to be of type ".concat(wt2(this.type), ", but found ").concat(wt2(ne2(r2)), " instead."));
            }
            throw new Error();
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        const ue2 = { "to-boolean": ht2, "to-color": pt2, "to-number": ut2, "to-string": ct2 };
        class ce2 {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            const r2 = t2[0];
            if (!ue2[r2]) throw new Error("Can't parse ".concat(r2, " as it is not part of the known types"));
            if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length) return e2.error("Expected one argument.");
            const n2 = ue2[r2], i2 = [];
            for (let r3 = 1; r3 < t2.length; r3++) {
              const n3 = e2.parse(t2[r3], r3, dt2);
              if (!n3) return null;
              i2.push(n3);
            }
            return new ce2(n2, i2);
          }
          evaluate(t2) {
            switch (this.type.kind) {
              case "boolean":
                return Boolean(this.args[0].evaluate(t2));
              case "color": {
                let e2, r2;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Kt2) return e2;
                  if ("string" == typeof e2) {
                    const r3 = t2.parseColor(e2);
                    if (r3) return r3;
                  } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? "Invalid rbga value ".concat(JSON.stringify(e2), ": expected an array containing either three or four numeric values.") : ee2(e2[0], e2[1], e2[2], e2[3]), !r2)) return new Kt2(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new ae2(r2 || "Could not parse color from value '".concat("string" == typeof e2 ? e2 : JSON.stringify(e2), "'"));
              }
              case "padding": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t2);
                  const n2 = Jt2.parse(e2);
                  if (n2) return n2;
                }
                throw new ae2("Could not parse padding from value '".concat("string" == typeof e2 ? e2 : JSON.stringify(e2), "'"));
              }
              case "variableAnchorOffsetCollection": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t2);
                  const n2 = Qt2.parse(e2);
                  if (n2) return n2;
                }
                throw new ae2("Could not parse variableAnchorOffsetCollection from value '".concat("string" == typeof e2 ? e2 : JSON.stringify(e2), "'"));
              }
              case "number": {
                let e2 = null;
                for (const r2 of this.args) {
                  if (e2 = r2.evaluate(t2), null === e2) return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2)) return n2;
                }
                throw new ae2("Could not convert ".concat(JSON.stringify(e2), " to number."));
              }
              case "formatted":
                return Yt2.fromString(ie(this.args[0].evaluate(t2)));
              case "resolvedImage":
                return te.fromString(ie(this.args[0].evaluate(t2)));
              default:
                return ie(this.args[0].evaluate(t2));
            }
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        const he2 = ["Unknown", "Point", "LineString", "Polygon"];
        class pe {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? he2[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t2) {
            let e2 = this._parseColorCache[t2];
            return e2 || (e2 = this._parseColorCache[t2] = Kt2.parse(t2)), e2;
          }
        }
        class fe2 {
          constructor(t2, e2, r2 = [], n2, i2 = new ot2(), s2 = []) {
            this.registry = t2, this.path = r2, this.key = r2.map((t3) => "[".concat(t3, "]")).join(""), this.scope = i2, this.errors = s2, this.expectedType = n2, this._isConstant = e2;
          }
          parse(t2, e2, r2, n2, i2 = {}) {
            return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
          }
          _parse(t2, e2) {
            function r2(t3, e3, r3) {
              return "assert" === r3 ? new le(e3, [t3]) : "coerce" === r3 ? new ce2(e3, [t3]) : t3;
            }
            if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (0 === t2.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n2 = t2[0];
              if ("string" != typeof n2) return this.error("Expression name must be a string, but found ".concat(typeof n2, ' instead. If you wanted a literal array, use ["literal", [...]].'), 0), null;
              const i2 = this.registry[n2];
              if (i2) {
                let n3 = i2.parse(t2, this);
                if (!n3) return null;
                if (this.expectedType) {
                  const t3 = this.expectedType, i3 = n3.type;
                  if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind) if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== i3.kind && "string" !== i3.kind) if ("padding" !== t3.kind || "value" !== i3.kind && "number" !== i3.kind && "array" !== i3.kind) if ("variableAnchorOffsetCollection" !== t3.kind || "value" !== i3.kind && "array" !== i3.kind) {
                    if (this.checkSubtype(t3, i3)) return null;
                  } else n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                  else n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                  else n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                  else n3 = r2(n3, t3, e2.typeAnnotation || "assert");
                }
                if (!(n3 instanceof se2) && "resolvedImage" !== n3.type.kind && this._isConstant(n3)) {
                  const t3 = new pe();
                  try {
                    n3 = new se2(n3.type, n3.evaluate(t3));
                  } catch (t4) {
                    return this.error(t4.message), null;
                  }
                }
                return n3;
              }
              return this.error('Unknown expression "'.concat(n2, '". If you wanted a literal array, use ["literal", [...]].'), 0);
            }
            return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found ".concat(typeof t2, " instead."));
          }
          concat(t2, e2, r2) {
            const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
            return new fe2(this.registry, this._isConstant, n2, e2 || null, i2, this.errors);
          }
          error(t2, ...e2) {
            const r2 = "".concat(this.key).concat(e2.map((t3) => "[".concat(t3, "]")).join(""));
            this.errors.push(new at2(r2, t2));
          }
          checkSubtype(t2, e2) {
            const r2 = At2(t2, e2);
            return r2 && this.error(r2), r2;
          }
        }
        class de2 {
          constructor(t2, e2) {
            this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
          }
          evaluate(t2) {
            return this.result.evaluate(t2);
          }
          eachChild(t2) {
            for (const e2 of this.bindings) t2(e2[1]);
            t2(this.result);
          }
          static parse(t2, e2) {
            if (t2.length < 4) return e2.error("Expected at least 3 arguments, but found ".concat(t2.length - 1, " instead."));
            const r2 = [];
            for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
              const i2 = t2[n3];
              if ("string" != typeof i2) return e2.error("Expected string, but found ".concat(typeof i2, " instead."), n3);
              if (/[^a-zA-Z0-9_]/.test(i2)) return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              const s2 = e2.parse(t2[n3 + 1], n3 + 1);
              if (!s2) return null;
              r2.push([i2, s2]);
            }
            const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
            return n2 ? new de2(r2, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class ye2 {
          constructor(t2, e2) {
            this.type = e2.type, this.name = t2, this.boundExpression = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length || "string" != typeof t2[1]) return e2.error("'var' expression requires exactly one string literal argument.");
            const r2 = t2[1];
            return e2.scope.has(r2) ? new ye2(r2, e2.scope.get(r2)) : e2.error('Unknown variable "'.concat(r2, '". Make sure "').concat(r2, '" has been bound in an enclosing "let" expression before using it.'), 1);
          }
          evaluate(t2) {
            return this.boundExpression.evaluate(t2);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class me2 {
          constructor(t2, e2, r2) {
            this.type = t2, this.index = e2, this.input = r2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error("Expected 2 arguments, but found ".concat(t2.length - 1, " instead."));
            const r2 = e2.parse(t2[1], 1, ut2), n2 = e2.parse(t2[2], 2, bt2(e2.expectedType || dt2));
            return r2 && n2 ? new me2(n2.type.itemType, r2, n2) : null;
          }
          evaluate(t2) {
            const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e2 < 0) throw new ae2("Array index out of bounds: ".concat(e2, " < 0."));
            if (e2 >= r2.length) throw new ae2("Array index out of bounds: ".concat(e2, " > ").concat(r2.length - 1, "."));
            if (e2 !== Math.floor(e2)) throw new ae2("Array index must be an integer, but found ".concat(e2, " instead."));
            return r2[e2];
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class ge2 {
          constructor(t2, e2) {
            this.type = ht2, this.needle = t2, this.haystack = e2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error("Expected 2 arguments, but found ".concat(t2.length - 1, " instead."));
            const r2 = e2.parse(t2[1], 1, dt2), n2 = e2.parse(t2[2], 2, dt2);
            return r2 && n2 ? St2(r2.type, [ht2, ct2, ut2, lt2, dt2]) ? new ge2(r2, n2) : e2.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(wt2(r2.type), " instead")) : null;
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!r2) return false;
            if (!kt(e2, ["boolean", "string", "number", "null"])) throw new ae2("Expected first argument to be of type boolean, string, number or null, but found ".concat(wt2(ne2(e2)), " instead."));
            if (!kt(r2, ["string", "array"])) throw new ae2("Expected second argument to be of type array or string, but found ".concat(wt2(ne2(r2)), " instead."));
            return r2.indexOf(e2) >= 0;
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class xe2 {
          constructor(t2, e2, r2) {
            this.type = ut2, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5) return e2.error("Expected 3 or 4 arguments, but found ".concat(t2.length - 1, " instead."));
            const r2 = e2.parse(t2[1], 1, dt2), n2 = e2.parse(t2[2], 2, dt2);
            if (!r2 || !n2) return null;
            if (!St2(r2.type, [ht2, ct2, ut2, lt2, dt2])) return e2.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(wt2(r2.type), " instead"));
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, ut2);
              return i2 ? new xe2(r2, n2, i2) : null;
            }
            return new xe2(r2, n2);
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!kt(e2, ["boolean", "string", "number", "null"])) throw new ae2("Expected first argument to be of type boolean, string, number or null, but found ".concat(wt2(ne2(e2)), " instead."));
            let n2;
            if (this.fromIndex && (n2 = this.fromIndex.evaluate(t2)), kt(r2, ["string"])) {
              const t3 = r2.indexOf(e2, n2);
              return -1 === t3 ? -1 : [...r2.slice(0, t3)].length;
            }
            if (kt(r2, ["array"])) return r2.indexOf(e2, n2);
            throw new ae2("Expected second argument to be of type array or string, but found ".concat(wt2(ne2(r2)), " instead."));
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class ve {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
          }
          static parse(t2, e2) {
            if (t2.length < 5) return e2.error("Expected at least 4 arguments, but found only ".concat(t2.length - 1, "."));
            if (t2.length % 2 != 1) return e2.error("Expected an even number of arguments.");
            let r2, n2;
            e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
            const i2 = {}, s2 = [];
            for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
              let o3 = t2[a3];
              const l3 = t2[a3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u2 = e2.concat(a3);
              if (0 === o3.length) return u2.error("Expected at least one branch label.");
              for (const t3 of o3) {
                if ("number" != typeof t3 && "string" != typeof t3) return u2.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER) return u2.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));
                if ("number" == typeof t3 && Math.floor(t3) !== t3) return u2.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (u2.checkSubtype(r2, ne2(t3))) return null;
                } else r2 = ne2(t3);
                if (void 0 !== i2[String(t3)]) return u2.error("Branch labels must be unique.");
                i2[String(t3)] = s2.length;
              }
              const c2 = e2.parse(l3, a3, n2);
              if (!c2) return null;
              n2 = n2 || c2.type, s2.push(c2);
            }
            const a2 = e2.parse(t2[1], 1, dt2);
            if (!a2) return null;
            const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
            return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new ve(r2, n2, a2, i2, s2, o2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            return (ne2(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class be2 {
          constructor(t2, e2, r2) {
            this.type = t2, this.branches = e2, this.otherwise = r2;
          }
          static parse(t2, e2) {
            if (t2.length < 4) return e2.error("Expected at least 3 arguments, but found only ".concat(t2.length - 1, "."));
            if (t2.length % 2 != 0) return e2.error("Expected an odd number of arguments.");
            let r2;
            e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
            const n2 = [];
            for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
              const s2 = e2.parse(t2[i3], i3, ht2);
              if (!s2) return null;
              const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
              if (!a2) return null;
              n2.push([s2, a2]), r2 = r2 || a2.type;
            }
            const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
            if (!i2) return null;
            if (!r2) throw new Error("Can't infer output type");
            return new be2(r2, n2, i2);
          }
          evaluate(t2) {
            for (const [e2, r2] of this.branches) if (e2.evaluate(t2)) return r2.evaluate(t2);
            return this.otherwise.evaluate(t2);
          }
          eachChild(t2) {
            for (const [e2, r2] of this.branches) t2(e2), t2(r2);
            t2(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class we2 {
          constructor(t2, e2, r2, n2) {
            this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5) return e2.error("Expected 3 or 4 arguments, but found ".concat(t2.length - 1, " instead."));
            const r2 = e2.parse(t2[1], 1, dt2), n2 = e2.parse(t2[2], 2, ut2);
            if (!r2 || !n2) return null;
            if (!St2(r2.type, [bt2(dt2), ct2, dt2])) return e2.error("Expected first argument to be of type array or string, but found ".concat(wt2(r2.type), " instead"));
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, ut2);
              return i2 ? new we2(r2.type, r2, n2, i2) : null;
            }
            return new we2(r2.type, r2, n2);
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
            let n2;
            if (this.endIndex && (n2 = this.endIndex.evaluate(t2)), kt(e2, ["string"])) return [...e2].slice(r2, n2).join("");
            if (kt(e2, ["array"])) return e2.slice(r2, n2);
            throw new ae2("Expected first argument to be of type array or string, but found ".concat(wt2(ne2(e2)), " instead."));
          }
          eachChild(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function _e2(t2, e2) {
          const r2 = t2.length - 1;
          let n2, i2, s2 = 0, a2 = r2, o2 = 0;
          for (; s2 <= a2; ) if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r2 || e2 < i2) return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2)) throw new ae2("Input is not a number.");
            a2 = o2 - 1;
          }
          return 0;
        }
        class Ae2 {
          constructor(t2, e2, r2) {
            this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of r2) this.labels.push(t3), this.outputs.push(e3);
          }
          static parse(t2, e2) {
            if (t2.length - 1 < 4) return e2.error("Expected at least 4 arguments, but found only ".concat(t2.length - 1, "."));
            if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            const r2 = e2.parse(t2[1], 1, ut2);
            if (!r2) return null;
            const n2 = [];
            let i2 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
            for (let r3 = 1; r3 < t2.length; r3 += 2) {
              const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l3 = r3 + 1;
              if ("number" != typeof s2) return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= s2) return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u2 = e2.parse(a2, l3, i2);
              if (!u2) return null;
              i2 = i2 || u2.type, n2.push([s2, u2]);
            }
            return new Ae2(i2, r2, n2);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length) return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0]) return r2[0].evaluate(t2);
            const i2 = e2.length;
            return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[_e2(e2, n2)].evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs) t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
        }
        function Se2(t2) {
          return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        var ke = Me2;
        function Me2(t2, e2, r2, n2) {
          this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
        }
        Me2.prototype = { sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, solveCurveX: function(t2, e2) {
          if (void 0 === e2 && (e2 = 1e-6), t2 < 0) return 0;
          if (t2 > 1) return 1;
          for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e2) return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 1e-6) break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++) t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        }, solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        } };
        var Ie2 = Se2(ke);
        function ze(t2, e2, r2) {
          return t2 + r2 * (e2 - t2);
        }
        function Pe2(t2, e2, r2) {
          return t2.map((t3, n2) => ze(t3, e2[n2], r2));
        }
        const Ce2 = { number: ze, color: function(t2, e2, r2, n2 = "rgb") {
          switch (n2) {
            case "rgb": {
              const [n3, i2, s2, a2] = Pe2(t2.rgb, e2.rgb, r2);
              return new Kt2(n3, i2, s2, a2, false);
            }
            case "hcl": {
              const [n3, i2, s2, a2] = t2.hcl, [o2, l3, u2, c2] = e2.hcl;
              let h2, p2;
              if (isNaN(n3) || isNaN(o2)) isNaN(n3) ? isNaN(o2) ? h2 = NaN : (h2 = o2, 1 !== s2 && 0 !== s2 || (p2 = l3)) : (h2 = n3, 1 !== u2 && 0 !== u2 || (p2 = i2));
              else {
                let t3 = o2 - n3;
                o2 > n3 && t3 > 180 ? t3 -= 360 : o2 < n3 && n3 - o2 > 180 && (t3 += 360), h2 = n3 + r2 * t3;
              }
              const [f2, d2, y3, m2] = function([t3, e3, r3, n4]) {
                return t3 = isNaN(t3) ? 0 : t3 * Et2, Ot2([r3, Math.cos(t3) * e3, Math.sin(t3) * e3, n4]);
              }([h2, null != p2 ? p2 : ze(i2, l3, r2), ze(s2, u2, r2), ze(a2, c2, r2)]);
              return new Kt2(f2, d2, y3, m2, false);
            }
            case "lab": {
              const [n3, i2, s2, a2] = Ot2(Pe2(t2.lab, e2.lab, r2));
              return new Kt2(n3, i2, s2, a2, false);
            }
          }
        }, array: Pe2, padding: function(t2, e2, r2) {
          return new Jt2(Pe2(t2.values, e2.values, r2));
        }, variableAnchorOffsetCollection: function(t2, e2, r2) {
          const n2 = t2.values, i2 = e2.values;
          if (n2.length !== i2.length) throw new ae2("Cannot interpolate values of different length. from: ".concat(t2.toString(), ", to: ").concat(e2.toString()));
          const s2 = [];
          for (let t3 = 0; t3 < n2.length; t3 += 2) {
            if (n2[t3] !== i2[t3]) throw new ae2("Cannot interpolate values containing mismatched anchors. from[".concat(t3, "]: ").concat(n2[t3], ", to[").concat(t3, "]: ").concat(i2[t3]));
            s2.push(n2[t3]);
            const [e3, a2] = n2[t3 + 1], [o2, l3] = i2[t3 + 1];
            s2.push([ze(e3, o2, r2), ze(a2, l3, r2)]);
          }
          return new Qt2(s2);
        } };
        class Be2 {
          constructor(t2, e2, r2, n2, i2) {
            this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of i2) this.labels.push(t3), this.outputs.push(e3);
          }
          static interpolationFactor(t2, e2, r2, n2) {
            let i2 = 0;
            if ("exponential" === t2.name) i2 = Ve2(e2, t2.base, r2, n2);
            else if ("linear" === t2.name) i2 = Ve2(e2, 1, r2, n2);
            else if ("cubic-bezier" === t2.name) {
              const s2 = t2.controlPoints;
              i2 = new Ie2(s2[0], s2[1], s2[2], s2[3]).solve(Ve2(e2, 1, r2, n2));
            }
            return i2;
          }
          static parse(t2, e2) {
            let [r2, n2, i2, ...s2] = t2;
            if (!Array.isArray(n2) || 0 === n2.length) return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n2[0]) n2 = { name: "linear" };
            else if ("exponential" === n2[0]) {
              const t3 = n2[1];
              if ("number" != typeof t3) return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t3 };
            } else {
              if ("cubic-bezier" !== n2[0]) return e2.error("Unknown interpolation type ".concat(String(n2[0])), 1, 0);
              {
                const t3 = n2.slice(1);
                if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1)) return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t3 };
              }
            }
            if (t2.length - 1 < 4) return e2.error("Expected at least 4 arguments, but found only ".concat(t2.length - 1, "."));
            if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            if (i2 = e2.parse(i2, 2, ut2), !i2) return null;
            const a2 = [];
            let o2 = null;
            "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = pt2 : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
            for (let t3 = 0; t3 < s2.length; t3 += 2) {
              const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l3 = t3 + 4;
              if ("number" != typeof r3) return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
              if (a2.length && a2[a2.length - 1][0] >= r3) return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
              const u2 = e2.parse(n3, l3, o2);
              if (!u2) return null;
              o2 = o2 || u2.type, a2.push([r3, u2]);
            }
            return Mt2(o2, ut2) || Mt2(o2, pt2) || Mt2(o2, gt2) || Mt2(o2, vt2) || Mt2(o2, bt2(ut2)) ? new Be2(o2, r2, n2, i2, a2) : e2.error("Type ".concat(wt2(o2), " is not interpolatable."));
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length) return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0]) return r2[0].evaluate(t2);
            const i2 = e2.length;
            if (n2 >= e2[i2 - 1]) return r2[i2 - 1].evaluate(t2);
            const s2 = _e2(e2, n2), a2 = Be2.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l3 = r2[s2 + 1].evaluate(t2);
            switch (this.operator) {
              case "interpolate":
                return Ce2[this.type.kind](o2, l3, a2);
              case "interpolate-hcl":
                return Ce2.color(o2, l3, a2, "hcl");
              case "interpolate-lab":
                return Ce2.color(o2, l3, a2, "lab");
            }
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs) t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
        }
        function Ve2(t2, e2, r2, n2) {
          const i2 = n2 - r2, s2 = t2 - r2;
          return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
        }
        class Ee2 {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expectected at least one argument.");
            let r2 = null;
            const n2 = e2.expectedType;
            n2 && "value" !== n2.kind && (r2 = n2);
            const i2 = [];
            for (const n3 of t2.slice(1)) {
              const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
              if (!t3) return null;
              r2 = r2 || t3.type, i2.push(t3);
            }
            if (!r2) throw new Error("No output type");
            const s2 = n2 && i2.some((t3) => At2(n2, t3.type));
            return new Ee2(s2 ? dt2 : r2, i2);
          }
          evaluate(t2) {
            let e2, r2 = null, n2 = 0;
            for (const i2 of this.args) if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof te && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null !== r2) break;
            return r2;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        function Fe2(t2, e2) {
          return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function Te2(t2, e2, r2, n2) {
          return 0 === n2.compare(e2, r2);
        }
        function $e2(t2, e2, r2) {
          const n2 = "==" !== t2 && "!=" !== t2;
          return class i2 {
            constructor(t3, e3, r3) {
              this.type = ht2, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
            }
            static parse(t3, e3) {
              if (3 !== t3.length && 4 !== t3.length) return e3.error("Expected two or three arguments.");
              const r3 = t3[0];
              let s2 = e3.parse(t3[1], 1, dt2);
              if (!s2) return null;
              if (!Fe2(r3, s2.type)) return e3.concat(1).error('"'.concat(r3, "\" comparisons are not supported for type '").concat(wt2(s2.type), "'."));
              let a2 = e3.parse(t3[2], 2, dt2);
              if (!a2) return null;
              if (!Fe2(r3, a2.type)) return e3.concat(2).error('"'.concat(r3, "\" comparisons are not supported for type '").concat(wt2(a2.type), "'."));
              if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error("Cannot compare types '".concat(wt2(s2.type), "' and '").concat(wt2(a2.type), "'."));
              n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new le(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new le(s2.type, [a2])));
              let o2 = null;
              if (4 === t3.length) {
                if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error("Cannot use collator to compare non-string types.");
                if (o2 = e3.parse(t3[3], 3, yt2), !o2) return null;
              }
              return new i2(s2, a2, o2);
            }
            evaluate(i3) {
              const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
              if (n2 && this.hasUntypedArgument) {
                const e3 = ne2(s2), r3 = ne2(a2);
                if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind) throw new ae2('Expected arguments for "'.concat(t2, '" to be (string, string) or (number, number), but found (').concat(e3.kind, ", ").concat(r3.kind, ") instead."));
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                const t3 = ne2(s2), r3 = ne2(a2);
                if ("string" !== t3.kind || "string" !== r3.kind) return e2(i3, s2, a2);
              }
              return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
            }
            eachChild(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const Le2 = $e2("==", function(t2, e2, r2) {
          return e2 === r2;
        }, Te2), De2 = $e2("!=", function(t2, e2, r2) {
          return e2 !== r2;
        }, function(t2, e2, r2, n2) {
          return !Te2(0, e2, r2, n2);
        }), Oe2 = $e2("<", function(t2, e2, r2) {
          return e2 < r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) < 0;
        }), je2 = $e2(">", function(t2, e2, r2) {
          return e2 > r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) > 0;
        }), Re2 = $e2("<=", function(t2, e2, r2) {
          return e2 <= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) <= 0;
        }), Ue2 = $e2(">=", function(t2, e2, r2) {
          return e2 >= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) >= 0;
        });
        class qe2 {
          constructor(t2, e2, r2) {
            this.type = yt2, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("Expected one argument.");
            const r2 = t2[1];
            if ("object" != typeof r2 || Array.isArray(r2)) return e2.error("Collator options argument must be an object.");
            const n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, ht2);
            if (!n2) return null;
            const i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, ht2);
            if (!i2) return null;
            let s2 = null;
            return r2.locale && (s2 = e2.parse(r2.locale, 1, ct2), !s2) ? null : new qe2(n2, i2, s2);
          }
          evaluate(t2) {
            return new Xt2(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }
          eachChild(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class Ne2 {
          constructor(t2, e2, r2, n2, i2) {
            this.type = ct2, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, ut2);
            if (!r2) return null;
            const n2 = t2[2];
            if ("object" != typeof n2 || Array.isArray(n2)) return e2.error("NumberFormat options argument must be an object.");
            let i2 = null;
            if (n2.locale && (i2 = e2.parse(n2.locale, 1, ct2), !i2)) return null;
            let s2 = null;
            if (n2.currency && (s2 = e2.parse(n2.currency, 1, ct2), !s2)) return null;
            let a2 = null;
            if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, ut2), !a2)) return null;
            let o2 = null;
            return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, ut2), !o2) ? null : new Ne2(r2, i2, s2, a2, o2);
          }
          evaluate(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }
          eachChild(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class Ze2 {
          constructor(t2) {
            this.type = mt2, this.sections = t2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            const r2 = t2[1];
            if (!Array.isArray(r2) && "object" == typeof r2) return e2.error("First argument must be an image or text section.");
            const n2 = [];
            let i2 = false;
            for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
              const s2 = t2[r3];
              if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                i2 = false;
                let t3 = null;
                if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, ut2), !t3)) return null;
                let r4 = null;
                if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, bt2(ct2)), !r4)) return null;
                let a2 = null;
                if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, pt2), !a2)) return null;
                const o2 = n2[n2.length - 1];
                o2.scale = t3, o2.font = r4, o2.textColor = a2;
              } else {
                const s3 = e2.parse(t2[r3], 1, dt2);
                if (!s3) return null;
                const a2 = s3.type.kind;
                if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2) return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
              }
            }
            return new Ze2(n2);
          }
          evaluate(t2) {
            return new Yt2(this.sections.map((e2) => {
              const r2 = e2.content.evaluate(t2);
              return ne2(r2) === xt2 ? new Ht2("", r2, null, null, null) : new Ht2(ie(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
            }));
          }
          eachChild(t2) {
            for (const e2 of this.sections) t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
          }
          outputDefined() {
            return false;
          }
        }
        class Ge2 {
          constructor(t2) {
            this.type = xt2, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, ct2);
            return r2 ? new Ge2(r2) : e2.error("No image name provided.");
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = te.fromString(e2);
            return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Ke2 {
          constructor(t2) {
            this.type = ut2, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("Expected 1 argument, but found ".concat(t2.length - 1, " instead."));
            const r2 = e2.parse(t2[1], 1);
            return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error("Expected argument of type string or array, but found ".concat(wt2(r2.type), " instead.")) : new Ke2(r2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            if ("string" == typeof e2) return [...e2].length;
            if (Array.isArray(e2)) return e2.length;
            throw new ae2("Expected value to be of type string or array, but found ".concat(wt2(ne2(e2)), " instead."));
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const Xe2 = 8192;
        function He2(t2, e2) {
          const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
          return [Math.round(r2 * i2 * Xe2), Math.round(n2 * i2 * Xe2)];
        }
        function Ye2(t2, e2) {
          const r2 = Math.pow(2, e2.z);
          return [(i2 = (t2[0] / Xe2 + e2.x) / r2, 360 * i2 - 180), (n2 = (t2[1] / Xe2 + e2.y) / r2, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n2) * Math.PI / 180)) - 90)];
          var n2, i2;
        }
        function Je2(t2, e2) {
          t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
        }
        function We2(t2, e2) {
          return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
        }
        function Qe2(t2, e2, r2) {
          const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
          return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
        }
        function tr2(t2, e2, r2, n2) {
          return 0 != (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] && !(!ar2(t2, e2, r2, n2) || !ar2(r2, n2, t2, e2));
          var i2, s2;
        }
        function er2(t2, e2, r2) {
          for (const n2 of r2) for (let r3 = 0; r3 < n2.length - 1; ++r3) if (tr2(t2, e2, n2[r3], n2[r3 + 1])) return true;
          return false;
        }
        function rr2(t2, e2, r2 = false) {
          let n2 = false;
          for (const o2 of e2) for (let e3 = 0; e3 < o2.length - 1; e3++) {
            if (Qe2(t2, o2[e3], o2[e3 + 1])) return r2;
            (s2 = o2[e3])[1] > (i2 = t2)[1] != (a2 = o2[e3 + 1])[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n2 = !n2);
          }
          var i2, s2, a2;
          return n2;
        }
        function nr2(t2, e2) {
          for (const r2 of e2) if (rr2(t2, r2)) return true;
          return false;
        }
        function ir2(t2, e2) {
          for (const r2 of t2) if (!rr2(r2, e2)) return false;
          for (let r2 = 0; r2 < t2.length - 1; ++r2) if (er2(t2[r2], t2[r2 + 1], e2)) return false;
          return true;
        }
        function sr2(t2, e2) {
          for (const r2 of e2) if (ir2(t2, r2)) return true;
          return false;
        }
        function ar2(t2, e2, r2, n2) {
          const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
          return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function or2(t2, e2, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = [];
            for (let n3 = 0; n3 < t2[i2].length; n3++) {
              const a2 = He2(t2[i2][n3], r2);
              Je2(e2, a2), s2.push(a2);
            }
            n2.push(s2);
          }
          return n2;
        }
        function lr2(t2, e2, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = or2(t2[i2], e2, r2);
            n2.push(s2);
          }
          return n2;
        }
        function ur2(t2, e2, r2, n2) {
          if (t2[0] < r2[0] || t2[0] > r2[2]) {
            const e3 = 0.5 * n2;
            let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
            0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
          }
          Je2(e2, t2);
        }
        function cr2(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z) * Xe2, s2 = [n2.x * Xe2, n2.y * Xe2], a2 = [];
          for (const n3 of t2) for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            ur2(n4, e2, r2, i2), a2.push(n4);
          }
          return a2;
        }
        function hr2(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z) * Xe2, s2 = [n2.x * Xe2, n2.y * Xe2], a2 = [];
          for (const r3 of t2) {
            const t3 = [];
            for (const n3 of r3) {
              const r4 = [n3.x + s2[0], n3.y + s2[1]];
              Je2(e2, r4), t3.push(r4);
            }
            a2.push(t3);
          }
          if (e2[2] - e2[0] <= i2 / 2) {
            (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t3 of a2) for (const n3 of t3) ur2(n3, e2, r2, i2);
          }
          var o2;
          return a2;
        }
        class pr2 {
          constructor(t2, e2) {
            this.type = ht2, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("'within' expression requires exactly one argument, but found ".concat(t2.length - 1, " instead."));
            if (re2(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type) {
                const t3 = [];
                for (const r2 of e3.features) {
                  const { type: e4, coordinates: n2 } = r2.geometry;
                  "Polygon" === e4 && t3.push(n2), "MultiPolygon" === e4 && t3.push(...n2);
                }
                if (t3.length) return new pr2(e3, { type: "MultiPolygon", coordinates: t3 });
              } else if ("Feature" === e3.type) {
                const t3 = e3.geometry.type;
                if ("Polygon" === t3 || "MultiPolygon" === t3) return new pr2(e3, e3.geometry);
              } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new pr2(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType()) return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if ("Polygon" === e2.type) {
                  const s2 = or2(e2.coordinates, n2, i2), a2 = cr2(t3.geometry(), r2, n2, i2);
                  if (!We2(r2, n2)) return false;
                  for (const t4 of a2) if (!rr2(t4, s2)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = lr2(e2.coordinates, n2, i2), a2 = cr2(t3.geometry(), r2, n2, i2);
                  if (!We2(r2, n2)) return false;
                  for (const t4 of a2) if (!nr2(t4, s2)) return false;
                }
                return true;
              }(t2, this.geometries);
              if ("LineString" === t2.geometryType()) return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if ("Polygon" === e2.type) {
                  const s2 = or2(e2.coordinates, n2, i2), a2 = hr2(t3.geometry(), r2, n2, i2);
                  if (!We2(r2, n2)) return false;
                  for (const t4 of a2) if (!ir2(t4, s2)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = lr2(e2.coordinates, n2, i2), a2 = hr2(t3.geometry(), r2, n2, i2);
                  if (!We2(r2, n2)) return false;
                  for (const t4 of a2) if (!sr2(t4, s2)) return false;
                }
                return true;
              }(t2, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let fr2 = class {
          constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this._up(this.length++);
          }
          pop() {
            if (0 === this.length) return;
            const t2 = this.data[0], e2 = this.data.pop();
            return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e2, compare: r2 } = this, n2 = e2[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s2 = e2[i2];
              if (r2(n2, s2) >= 0) break;
              e2[t2] = s2, t2 = i2;
            }
            e2[t2] = n2;
          }
          _down(t2) {
            const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1);
              const s2 = n3 + 1;
              if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0) break;
              e2[t2] = e2[n3], t2 = n3;
            }
            e2[t2] = i2;
          }
        };
        function dr2(t2, e2, r2, n2, i2) {
          yr2(t2, e2, r2, n2 || t2.length - 1, i2 || gr2);
        }
        function yr2(t2, e2, r2, n2, i2) {
          for (; n2 > r2; ) {
            if (n2 - r2 > 600) {
              var s2 = n2 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s2), l3 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l3 * (s2 - l3) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
              yr2(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l3 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l3 / s2 + u2)), i2);
            }
            var c2 = t2[e2], h2 = r2, p2 = n2;
            for (mr2(t2, r2, e2), i2(t2[n2], c2) > 0 && mr2(t2, r2, n2); h2 < p2; ) {
              for (mr2(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; ) h2++;
              for (; i2(t2[p2], c2) > 0; ) p2--;
            }
            0 === i2(t2[r2], c2) ? mr2(t2, r2, p2) : mr2(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
          }
        }
        function mr2(t2, e2, r2) {
          var n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function gr2(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function xr2(t2, e2) {
          if (t2.length <= 1) return [t2];
          const r2 = [];
          let n2, i2;
          for (const e3 of t2) {
            const t3 = br2(e3);
            0 !== t3 && (e3.area = Math.abs(t3), void 0 === i2 && (i2 = t3 < 0), i2 === t3 < 0 ? (n2 && r2.push(n2), n2 = [e3]) : n2.push(e3));
          }
          if (n2 && r2.push(n2), e2 > 1) for (let t3 = 0; t3 < r2.length; t3++) r2[t3].length <= e2 || (dr2(r2[t3], e2, 1, r2[t3].length - 1, vr2), r2[t3] = r2[t3].slice(0, e2));
          return r2;
        }
        function vr2(t2, e2) {
          return e2.area - t2.area;
        }
        function br2(t2) {
          let e2 = 0;
          for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        const wr2 = 1 / 298.257223563, _r2 = wr2 * (2 - wr2), Ar2 = Math.PI / 180;
        class Sr2 {
          constructor(t2) {
            const e2 = 6378.137 * Ar2 * 1e3, r2 = Math.cos(t2 * Ar2), n2 = 1 / (1 - _r2 * (1 - r2 * r2)), i2 = Math.sqrt(n2);
            this.kx = e2 * i2 * r2, this.ky = e2 * i2 * n2 * (1 - _r2);
          }
          distance(t2, e2) {
            const r2 = this.wrap(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
            return Math.sqrt(r2 * r2 + n2 * n2);
          }
          pointOnLine(t2, e2) {
            let r2, n2, i2, s2, a2 = 1 / 0;
            for (let o2 = 0; o2 < t2.length - 1; o2++) {
              let l3 = t2[o2][0], u2 = t2[o2][1], c2 = this.wrap(t2[o2 + 1][0] - l3) * this.kx, h2 = (t2[o2 + 1][1] - u2) * this.ky, p2 = 0;
              0 === c2 && 0 === h2 || (p2 = (this.wrap(e2[0] - l3) * this.kx * c2 + (e2[1] - u2) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l3 = t2[o2 + 1][0], u2 = t2[o2 + 1][1]) : p2 > 0 && (l3 += c2 / this.kx * p2, u2 += h2 / this.ky * p2)), c2 = this.wrap(e2[0] - l3) * this.kx, h2 = (e2[1] - u2) * this.ky;
              const f2 = c2 * c2 + h2 * h2;
              f2 < a2 && (a2 = f2, r2 = l3, n2 = u2, i2 = o2, s2 = p2);
            }
            return { point: [r2, n2], index: i2, t: Math.max(0, Math.min(1, s2)) };
          }
          wrap(t2) {
            for (; t2 < -180; ) t2 += 360;
            for (; t2 > 180; ) t2 -= 360;
            return t2;
          }
        }
        function kr2(t2, e2) {
          return e2[0] - t2[0];
        }
        function Mr2(t2) {
          return t2[1] - t2[0] + 1;
        }
        function Ir2(t2, e2) {
          return t2[1] >= t2[0] && t2[1] < e2;
        }
        function zr2(t2, e2) {
          if (t2[0] > t2[1]) return [null, null];
          const r2 = Mr2(t2);
          if (e2) {
            if (2 === r2) return [t2, null];
            const e3 = Math.floor(r2 / 2);
            return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
          }
          if (1 === r2) return [t2, null];
          const n2 = Math.floor(r2 / 2) - 1;
          return [[t2[0], t2[0] + n2], [t2[0] + n2 + 1, t2[1]]];
        }
        function Pr2(t2, e2) {
          if (!Ir2(e2, t2.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let n2 = e2[0]; n2 <= e2[1]; ++n2) Je2(r2, t2[n2]);
          return r2;
        }
        function Cr2(t2) {
          const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r2 of t2) for (const t3 of r2) Je2(e2, t3);
          return e2;
        }
        function Br2(t2) {
          return t2[0] !== -1 / 0 && t2[1] !== -1 / 0 && t2[2] !== 1 / 0 && t2[3] !== 1 / 0;
        }
        function Vr2(t2, e2, r2) {
          if (!Br2(t2) || !Br2(e2)) return NaN;
          let n2 = 0, i2 = 0;
          return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
        }
        function Er2(t2, e2, r2) {
          const n2 = r2.pointOnLine(e2, t2);
          return r2.distance(t2, n2.point);
        }
        function Fr2(t2, e2, r2, n2, i2) {
          const s2 = Math.min(Er2(t2, [r2, n2], i2), Er2(e2, [r2, n2], i2)), a2 = Math.min(Er2(r2, [t2, e2], i2), Er2(n2, [t2, e2], i2));
          return Math.min(s2, a2);
        }
        function Tr2(t2, e2, r2, n2, i2) {
          if (!Ir2(e2, t2.length) || !Ir2(n2, r2.length)) return 1 / 0;
          let s2 = 1 / 0;
          for (let a2 = e2[0]; a2 < e2[1]; ++a2) {
            const e3 = t2[a2], o2 = t2[a2 + 1];
            for (let t3 = n2[0]; t3 < n2[1]; ++t3) {
              const n3 = r2[t3], a3 = r2[t3 + 1];
              if (tr2(e3, o2, n3, a3)) return 0;
              s2 = Math.min(s2, Fr2(e3, o2, n3, a3, i2));
            }
          }
          return s2;
        }
        function $r2(t2, e2, r2, n2, i2) {
          if (!Ir2(e2, t2.length) || !Ir2(n2, r2.length)) return NaN;
          let s2 = 1 / 0;
          for (let a2 = e2[0]; a2 <= e2[1]; ++a2) for (let e3 = n2[0]; e3 <= n2[1]; ++e3) if (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3])), 0 === s2) return s2;
          return s2;
        }
        function Lr2(t2, e2, r2) {
          if (rr2(t2, e2, true)) return 0;
          let n2 = 1 / 0;
          for (const i2 of e2) {
            const e3 = i2[0], s2 = i2[i2.length - 1];
            if (e3 !== s2 && (n2 = Math.min(n2, Er2(t2, [s2, e3], r2)), 0 === n2)) return n2;
            const a2 = r2.pointOnLine(i2, t2);
            if (n2 = Math.min(n2, r2.distance(t2, a2.point)), 0 === n2) return n2;
          }
          return n2;
        }
        function Dr2(t2, e2, r2, n2) {
          if (!Ir2(e2, t2.length)) return NaN;
          for (let n3 = e2[0]; n3 <= e2[1]; ++n3) if (rr2(t2[n3], r2, true)) return 0;
          let i2 = 1 / 0;
          for (let s2 = e2[0]; s2 < e2[1]; ++s2) {
            const e3 = t2[s2], a2 = t2[s2 + 1];
            for (const t3 of r2) for (let r3 = 0, s3 = t3.length, o2 = s3 - 1; r3 < s3; o2 = r3++) {
              const s4 = t3[o2], l3 = t3[r3];
              if (tr2(e3, a2, s4, l3)) return 0;
              i2 = Math.min(i2, Fr2(e3, a2, s4, l3, n2));
            }
          }
          return i2;
        }
        function Or2(t2, e2) {
          for (const r2 of t2) for (const t3 of r2) if (rr2(t3, e2, true)) return true;
          return false;
        }
        function jr2(t2, e2, r2, n2 = 1 / 0) {
          const i2 = Cr2(t2), s2 = Cr2(e2);
          if (n2 !== 1 / 0 && Vr2(i2, s2, r2) >= n2) return n2;
          if (We2(i2, s2)) {
            if (Or2(t2, e2)) return 0;
          } else if (Or2(e2, t2)) return 0;
          let a2 = 1 / 0;
          for (const n3 of t2) for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++) {
            const i4 = n3[s3], o2 = n3[t3];
            for (const t4 of e2) for (let e3 = 0, n4 = t4.length, s4 = n4 - 1; e3 < n4; s4 = e3++) {
              const n5 = t4[s4], l3 = t4[e3];
              if (tr2(i4, o2, n5, l3)) return 0;
              a2 = Math.min(a2, Fr2(i4, o2, n5, l3, r2));
            }
          }
          return a2;
        }
        function Rr2(t2, e2, r2, n2, i2, s2) {
          if (!s2) return;
          const a2 = Vr2(Pr2(n2, s2), i2, r2);
          a2 < e2 && t2.push([a2, s2, [0, 0]]);
        }
        function Ur2(t2, e2, r2, n2, i2, s2, a2) {
          if (!s2 || !a2) return;
          const o2 = Vr2(Pr2(n2, s2), Pr2(i2, a2), r2);
          o2 < e2 && t2.push([o2, s2, a2]);
        }
        function qr2(t2, e2, r2, n2, i2 = 1 / 0) {
          let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
          if (0 === s2) return s2;
          const a2 = new fr2([[0, [0, t2.length - 1], [0, 0]]], kr2), o2 = Cr2(r2);
          for (; a2.length > 0; ) {
            const i3 = a2.pop();
            if (i3[0] >= s2) continue;
            const l3 = i3[1], u2 = e2 ? 50 : 100;
            if (Mr2(l3) <= u2) {
              if (!Ir2(l3, t2.length)) return NaN;
              if (e2) {
                const e3 = Dr2(t2, l3, r2, n2);
                if (isNaN(e3) || 0 === e3) return e3;
                s2 = Math.min(s2, e3);
              } else for (let e3 = l3[0]; e3 <= l3[1]; ++e3) {
                const i4 = Lr2(t2[e3], r2, n2);
                if (s2 = Math.min(s2, i4), 0 === s2) return 0;
              }
            } else {
              const r3 = zr2(l3, e2);
              Rr2(a2, s2, n2, t2, o2, r3[0]), Rr2(a2, s2, n2, t2, o2, r3[1]);
            }
          }
          return s2;
        }
        function Nr2(t2, e2, r2, n2, i2, s2 = 1 / 0) {
          let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
          if (0 === a2) return a2;
          const o2 = new fr2([[0, [0, t2.length - 1], [0, r2.length - 1]]], kr2);
          for (; o2.length > 0; ) {
            const s3 = o2.pop();
            if (s3[0] >= a2) continue;
            const l3 = s3[1], u2 = s3[2], c2 = e2 ? 50 : 100, h2 = n2 ? 50 : 100;
            if (Mr2(l3) <= c2 && Mr2(u2) <= h2) {
              if (!Ir2(l3, t2.length) && Ir2(u2, r2.length)) return NaN;
              let s4;
              if (e2 && n2) s4 = Tr2(t2, l3, r2, u2, i2), a2 = Math.min(a2, s4);
              else if (e2 && !n2) {
                const e3 = t2.slice(l3[0], l3[1] + 1);
                for (let t3 = u2[0]; t3 <= u2[1]; ++t3) if (s4 = Er2(r2[t3], e3, i2), a2 = Math.min(a2, s4), 0 === a2) return a2;
              } else if (!e2 && n2) {
                const e3 = r2.slice(u2[0], u2[1] + 1);
                for (let r3 = l3[0]; r3 <= l3[1]; ++r3) if (s4 = Er2(t2[r3], e3, i2), a2 = Math.min(a2, s4), 0 === a2) return a2;
              } else s4 = $r2(t2, l3, r2, u2, i2), a2 = Math.min(a2, s4);
            } else {
              const s4 = zr2(l3, e2), c3 = zr2(u2, n2);
              Ur2(o2, a2, i2, t2, r2, s4[0], c3[0]), Ur2(o2, a2, i2, t2, r2, s4[0], c3[1]), Ur2(o2, a2, i2, t2, r2, s4[1], c3[0]), Ur2(o2, a2, i2, t2, r2, s4[1], c3[1]);
            }
          }
          return a2;
        }
        function Zr2(t2) {
          return "MultiPolygon" === t2.type ? t2.coordinates.map((t3) => ({ type: "Polygon", coordinates: t3 })) : "MultiLineString" === t2.type ? t2.coordinates.map((t3) => ({ type: "LineString", coordinates: t3 })) : "MultiPoint" === t2.type ? t2.coordinates.map((t3) => ({ type: "Point", coordinates: t3 })) : [t2];
        }
        class Gr2 {
          constructor(t2, e2) {
            this.type = ut2, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("'distance' expression requires exactly one argument, but found ".concat(t2.length - 1, " instead."));
            if (re2(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type) return new Gr2(e3, e3.features.map((t3) => Zr2(t3.geometry)).flat());
              if ("Feature" === e3.type) return new Gr2(e3, Zr2(e3.geometry));
              if ("type" in e3 && "coordinates" in e3) return new Gr2(e3, Zr2(e3));
            }
            return e2.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType()) return function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Ye2([e3.x, e3.y], t3.canonical));
                if (0 === r2.length) return NaN;
                const i2 = new Sr2(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, Nr2(n2, false, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, Nr2(n2, false, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, qr2(n2, false, t4.coordinates, i2, s2));
                  }
                  if (0 === s2) return s2;
                }
                return s2;
              }(t2, this.geometries);
              if ("LineString" === t2.geometryType()) return function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Ye2([e3.x, e3.y], t3.canonical));
                if (0 === r2.length) return NaN;
                const i2 = new Sr2(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, Nr2(n2, true, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, Nr2(n2, true, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, qr2(n2, true, t4.coordinates, i2, s2));
                  }
                  if (0 === s2) return s2;
                }
                return s2;
              }(t2, this.geometries);
              if ("Polygon" === t2.geometryType()) return function(t3, e2) {
                const r2 = t3.geometry();
                if (0 === r2.length || 0 === r2[0].length) return NaN;
                const n2 = xr2(r2, 0).map((e3) => e3.map((e4) => e4.map((e5) => Ye2([e5.x, e5.y], t3.canonical)))), i2 = new Sr2(n2[0][0][0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) for (const e3 of n2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, qr2([t4.coordinates], false, e3, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, qr2(t4.coordinates, true, e3, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, jr2(e3, t4.coordinates, i2, s2));
                  }
                  if (0 === s2) return s2;
                }
                return s2;
              }(t2, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Kr2 = { "==": Le2, "!=": De2, ">": je2, "<": Oe2, ">=": Ue2, "<=": Re2, array: le, at: me2, boolean: le, case: be2, coalesce: Ee2, collator: qe2, format: Ze2, image: Ge2, in: ge2, "index-of": xe2, interpolate: Be2, "interpolate-hcl": Be2, "interpolate-lab": Be2, length: Ke2, let: de2, literal: se2, match: ve, number: le, "number-format": Ne2, object: le, slice: we2, step: Ae2, string: le, "to-boolean": ce2, "to-color": ce2, "to-number": ce2, "to-string": ce2, var: ye2, within: pr2, distance: Gr2 };
        class Xr2 {
          constructor(t2, e2, r2, n2) {
            this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
          }
          evaluate(t2) {
            return this._evaluate(t2, this.args);
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return false;
          }
          static parse(t2, e2) {
            const r2 = t2[0], n2 = Xr2.definitions[r2];
            if (!n2) return e2.error('Unknown expression "'.concat(r2, '". If you wanted a literal array, use ["literal", [...]].'), 0);
            const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
            let o2 = null;
            for (const [n3, s3] of a2) {
              o2 = new fe2(e2.registry, Qr2, e2.path, null, e2.scope);
              const a3 = [];
              let l3 = false;
              for (let e3 = 1; e3 < t2.length; e3++) {
                const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
                if (!s4) {
                  l3 = true;
                  break;
                }
                a3.push(s4);
              }
              if (!l3) if (Array.isArray(n3) && n3.length !== a3.length) o2.error("Expected ".concat(n3.length, " arguments, but found ").concat(a3.length, " instead."));
              else {
                for (let t3 = 0; t3 < a3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (0 === o2.errors.length) return new Xr2(r2, i2, s3, a3);
              }
            }
            if (1 === a2.length) e2.errors.push(...o2.errors);
            else {
              const r3 = (a2.length ? a2 : s2).map(([t3]) => {
                return e3 = t3, Array.isArray(e3) ? "(".concat(e3.map(wt2).join(", "), ")") : "(".concat(wt2(e3.type), "...)");
                var e3;
              }).join(" | "), n3 = [];
              for (let r4 = 1; r4 < t2.length; r4++) {
                const i3 = e2.parse(t2[r4], 1 + n3.length);
                if (!i3) return null;
                n3.push(wt2(i3.type));
              }
              e2.error("Expected arguments of type ".concat(r3, ", but found (").concat(n3.join(", "), ") instead."));
            }
            return null;
          }
          static register(t2, e2) {
            Xr2.definitions = e2;
            for (const r2 in e2) t2[r2] = Xr2;
          }
        }
        function Hr2(t2, [e2, r2, n2, i2]) {
          e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
          const s2 = i2 ? i2.evaluate(t2) : 1, a2 = ee2(e2, r2, n2, s2);
          if (a2) throw new ae2(a2);
          return new Kt2(e2 / 255, r2 / 255, n2 / 255, s2, false);
        }
        function Yr2(t2, e2) {
          return t2 in e2;
        }
        function Jr2(t2, e2) {
          const r2 = e2[t2];
          return void 0 === r2 ? null : r2;
        }
        function Wr2(t2) {
          return { type: t2 };
        }
        function Qr2(t2) {
          if (t2 instanceof ye2) return Qr2(t2.boundExpression);
          if (t2 instanceof Xr2 && "error" === t2.name) return false;
          if (t2 instanceof qe2) return false;
          if (t2 instanceof pr2) return false;
          if (t2 instanceof Gr2) return false;
          const e2 = t2 instanceof ce2 || t2 instanceof le;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 = e2 ? r2 && Qr2(t3) : r2 && t3 instanceof se2;
          }), !!r2 && tn2(t2) && rn2(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function tn2(t2) {
          if (t2 instanceof Xr2) {
            if ("get" === t2.name && 1 === t2.args.length) return false;
            if ("feature-state" === t2.name) return false;
            if ("has" === t2.name && 1 === t2.args.length) return false;
            if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name) return false;
            if (/^filter-/.test(t2.name)) return false;
          }
          if (t2 instanceof pr2) return false;
          if (t2 instanceof Gr2) return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !tn2(t3) && (e2 = false);
          }), e2;
        }
        function en2(t2) {
          if (t2 instanceof Xr2 && "feature-state" === t2.name) return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !en2(t3) && (e2 = false);
          }), e2;
        }
        function rn2(t2, e2) {
          if (t2 instanceof Xr2 && e2.indexOf(t2.name) >= 0) return false;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 && !rn2(t3, e2) && (r2 = false);
          }), r2;
        }
        function nn2(t2) {
          return { result: "success", value: t2 };
        }
        function sn2(t2) {
          return { result: "error", value: t2 };
        }
        function an2(t2) {
          return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
        }
        function on2(t2) {
          return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
        }
        function ln2(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function un2(t2) {
          return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
        }
        function cn2(t2) {
          return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
        }
        function hn2(t2) {
          return t2;
        }
        function pn2(t2, e2) {
          const r2 = "color" === e2.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (ln2(e2) ? "exponential" : "interval");
          if (r2 || "padding" === e2.type) {
            const n3 = r2 ? Kt2.parse : Jt2.parse;
            (t2 = st2({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], n3(t3[1])])), t2.default = n3(t2.default ? t2.default : e2.default);
          }
          if (t2.colorSpace && "rgb" !== (a2 = t2.colorSpace) && "hcl" !== a2 && "lab" !== a2) throw new Error('Unknown color space: "'.concat(t2.colorSpace, '"'));
          var a2;
          let o2, l3, u2;
          if ("exponential" === s2) o2 = mn2;
          else if ("interval" === s2) o2 = yn2;
          else if ("categorical" === s2) {
            o2 = dn2, l3 = /* @__PURE__ */ Object.create(null);
            for (const e3 of t2.stops) l3[e3[0]] = e3[1];
            u2 = typeof t2.stops[0][0];
          } else {
            if ("identity" !== s2) throw new Error('Unknown function type "'.concat(s2, '"'));
            o2 = gn2;
          }
          if (n2) {
            const r3 = {}, n3 = [];
            for (let e3 = 0; e3 < t2.stops.length; e3++) {
              const i4 = t2.stops[e3], s4 = i4[0].zoom;
              void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
            }
            const i3 = [];
            for (const t3 of n3) i3.push([r3[t3].zoom, pn2(r3[t3], e2)]);
            const s3 = { name: "linear" };
            return { kind: "composite", interpolationType: s3, interpolationFactor: Be2.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => mn2({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
          }
          if (i2) {
            const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
            return { kind: "camera", interpolationType: r3, interpolationFactor: Be2.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => o2(t2, e2, r4, l3, u2) };
          }
          return { kind: "source", evaluate(r3, n3) {
            const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
            return void 0 === i3 ? fn2(t2.default, e2.default) : o2(t2, e2, i3, l3, u2);
          } };
        }
        function fn2(t2, e2, r2) {
          return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
        }
        function dn2(t2, e2, r2, n2, i2) {
          return fn2(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
        }
        function yn2(t2, e2, r2) {
          if ("number" !== un2(r2)) return fn2(t2.default, e2.default);
          const n2 = t2.stops.length;
          if (1 === n2) return t2.stops[0][1];
          if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
          if (r2 >= t2.stops[n2 - 1][0]) return t2.stops[n2 - 1][1];
          const i2 = _e2(t2.stops.map((t3) => t3[0]), r2);
          return t2.stops[i2][1];
        }
        function mn2(t2, e2, r2) {
          const n2 = void 0 !== t2.base ? t2.base : 1;
          if ("number" !== un2(r2)) return fn2(t2.default, e2.default);
          const i2 = t2.stops.length;
          if (1 === i2) return t2.stops[0][1];
          if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
          if (r2 >= t2.stops[i2 - 1][0]) return t2.stops[i2 - 1][1];
          const s2 = _e2(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
            const i3 = n3 - r3, s3 = t3 - r3;
            return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
          }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l3 = t2.stops[s2 + 1][1], u2 = Ce2[e2.type] || hn2;
          return "function" == typeof o2.evaluate ? { evaluate(...e3) {
            const r3 = o2.evaluate.apply(void 0, e3), n3 = l3.evaluate.apply(void 0, e3);
            if (void 0 !== r3 && void 0 !== n3) return u2(r3, n3, a2, t2.colorSpace);
          } } : u2(o2, l3, a2, t2.colorSpace);
        }
        function gn2(t2, e2, r2) {
          switch (e2.type) {
            case "color":
              r2 = Kt2.parse(r2);
              break;
            case "formatted":
              r2 = Yt2.fromString(r2.toString());
              break;
            case "resolvedImage":
              r2 = te.fromString(r2.toString());
              break;
            case "padding":
              r2 = Jt2.parse(r2);
              break;
            default:
              un2(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0);
          }
          return fn2(r2, t2.default, e2.default);
        }
        Xr2.register(Kr2, { error: [{ kind: "error" }, [ct2], (t2, [e2]) => {
          throw new ae2(e2.evaluate(t2));
        }], typeof: [ct2, [dt2], (t2, [e2]) => wt2(ne2(e2.evaluate(t2)))], "to-rgba": [bt2(ut2, 4), [pt2], (t2, [e2]) => {
          const [r2, n2, i2, s2] = e2.evaluate(t2).rgb;
          return [255 * r2, 255 * n2, 255 * i2, s2];
        }], rgb: [pt2, [ut2, ut2, ut2], Hr2], rgba: [pt2, [ut2, ut2, ut2, ut2], Hr2], has: { type: ht2, overloads: [[[ct2], (t2, [e2]) => Yr2(e2.evaluate(t2), t2.properties())], [[ct2, ft2], (t2, [e2, r2]) => Yr2(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: dt2, overloads: [[[ct2], (t2, [e2]) => Jr2(e2.evaluate(t2), t2.properties())], [[ct2, ft2], (t2, [e2, r2]) => Jr2(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [dt2, [ct2], (t2, [e2]) => Jr2(e2.evaluate(t2), t2.featureState || {})], properties: [ft2, [], (t2) => t2.properties()], "geometry-type": [ct2, [], (t2) => t2.geometryType()], id: [dt2, [], (t2) => t2.id()], zoom: [ut2, [], (t2) => t2.globals.zoom], "heatmap-density": [ut2, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [ut2, [], (t2) => t2.globals.lineProgress || 0], accumulated: [dt2, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [ut2, Wr2(ut2), (t2, e2) => {
          let r2 = 0;
          for (const n2 of e2) r2 += n2.evaluate(t2);
          return r2;
        }], "*": [ut2, Wr2(ut2), (t2, e2) => {
          let r2 = 1;
          for (const n2 of e2) r2 *= n2.evaluate(t2);
          return r2;
        }], "-": { type: ut2, overloads: [[[ut2, ut2], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[ut2], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [ut2, [ut2, ut2], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [ut2, [ut2, ut2], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [ut2, [], () => Math.LN2], pi: [ut2, [], () => Math.PI], e: [ut2, [], () => Math.E], "^": [ut2, [ut2, ut2], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [ut2, [ut2], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [ut2, [ut2], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [ut2, [ut2], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [ut2, [ut2], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [ut2, [ut2], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [ut2, [ut2], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [ut2, [ut2], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [ut2, [ut2], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [ut2, [ut2], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [ut2, [ut2], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [ut2, Wr2(ut2), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [ut2, Wr2(ut2), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [ut2, [ut2], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [ut2, [ut2], (t2, [e2]) => {
          const r2 = e2.evaluate(t2);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [ut2, [ut2], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [ut2, [ut2], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [ht2, [ct2, dt2], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [ht2, [dt2], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [ht2, [ct2], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [ht2, [ct2, dt2], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 < i2;
        }], "filter-id-<": [ht2, [dt2], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 < n2;
        }], "filter->": [ht2, [ct2, dt2], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 > i2;
        }], "filter-id->": [ht2, [dt2], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 > n2;
        }], "filter-<=": [ht2, [ct2, dt2], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 <= i2;
        }], "filter-id-<=": [ht2, [dt2], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 <= n2;
        }], "filter->=": [ht2, [ct2, dt2], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 >= i2;
        }], "filter-id->=": [ht2, [dt2], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 >= n2;
        }], "filter-has": [ht2, [dt2], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [ht2, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [ht2, [bt2(ct2)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [ht2, [bt2(dt2)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [ht2, [ct2, bt2(dt2)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [ht2, [ct2, bt2(dt2)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
          for (; r3 <= n2; ) {
            const i2 = r3 + n2 >> 1;
            if (e3[i2] === t3) return true;
            e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
          }
          return false;
        }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: ht2, overloads: [[[ht2, ht2], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Wr2(ht2), (t2, e2) => {
          for (const r2 of e2) if (!r2.evaluate(t2)) return false;
          return true;
        }]] }, any: { type: ht2, overloads: [[[ht2, ht2], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Wr2(ht2), (t2, e2) => {
          for (const r2 of e2) if (r2.evaluate(t2)) return true;
          return false;
        }]] }, "!": [ht2, [ht2], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [ht2, [ct2], (t2, [e2]) => {
          const r2 = t2.globals && t2.globals.isSupportedScript;
          return !r2 || r2(e2.evaluate(t2));
        }], upcase: [ct2, [ct2], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ct2, [ct2], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ct2, Wr2(dt2), (t2, e2) => e2.map((e3) => ie(e3.evaluate(t2))).join("")], "resolved-locale": [ct2, [yt2], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
        class xn2 {
          constructor(t2, e2) {
            var r2;
            this.expression = t2, this._warningHistory = {}, this._evaluator = new pe(), this._defaultValue = e2 ? "color" === (r2 = e2).type && cn2(r2.default) ? new Kt2(0, 0, 0, 0) : "color" === r2.type ? Kt2.parse(r2.default) || null : "padding" === r2.type ? Jt2.parse(r2.default) || null : "variableAnchorOffsetCollection" === r2.type ? Qt2.parse(r2.default) || null : void 0 === r2.default ? null : r2.default : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
            try {
              const t3 = this.expression.evaluate(this._evaluator);
              if (null == t3 || "number" == typeof t3 && t3 != t3) return this._defaultValue;
              if (this._enumValues && !(t3 in this._enumValues)) throw new ae2("Expected value to be one of ".concat(Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", "), ", but found ").concat(JSON.stringify(t3), " instead."));
              return t3;
            } catch (t3) {
              return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
            }
          }
        }
        function vn2(t2) {
          return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Kr2;
        }
        function bn2(t2, e2) {
          const r2 = new fe2(Kr2, Qr2, [], e2 ? function(t3) {
            const e3 = { color: pt2, string: ct2, number: ut2, enum: ct2, boolean: ht2, formatted: mt2, padding: gt2, resolvedImage: xt2, variableAnchorOffsetCollection: vt2 };
            return "array" === t3.type ? bt2(e3[t3.value] || dt2, t3.length) : e3[t3.type];
          }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? nn2(new xn2(n2, e2)) : sn2(r2.errors);
        }
        class wn2 {
          constructor(t2, e2) {
            this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !en2(e2.expression);
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
          }
        }
        class _n2 {
          constructor(t2, e2, r2, n2) {
            this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !en2(e2.expression), this.interpolationType = n2;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
          }
          interpolationFactor(t2, e2, r2) {
            return this.interpolationType ? Be2.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
          }
        }
        function An2(t2, e2) {
          const r2 = bn2(t2, e2);
          if ("error" === r2.result) return r2;
          const n2 = r2.value.expression, i2 = tn2(n2);
          if (!i2 && !an2(e2)) return sn2([new at2("", "data expressions not supported")]);
          const s2 = rn2(n2, ["zoom"]);
          if (!s2 && !on2(e2)) return sn2([new at2("", "zoom expressions not supported")]);
          const a2 = kn2(n2);
          return a2 || s2 ? a2 instanceof at2 ? sn2([a2]) : a2 instanceof Be2 && !ln2(e2) ? sn2([new at2("", '"interpolate" expressions cannot be used with this property')]) : nn2(a2 ? new _n2(i2 ? "camera" : "composite", r2.value, a2.labels, a2 instanceof Be2 ? a2.interpolation : void 0) : new wn2(i2 ? "constant" : "source", r2.value)) : sn2([new at2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Sn2 {
          constructor(t2, e2) {
            this._parameters = t2, this._specification = e2, st2(this, pn2(this._parameters, this._specification));
          }
          static deserialize(t2) {
            return new Sn2(t2._parameters, t2._specification);
          }
          static serialize(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          }
        }
        function kn2(t2) {
          let e2 = null;
          if (t2 instanceof de2) e2 = kn2(t2.result);
          else if (t2 instanceof Ee2) {
            for (const r2 of t2.args) if (e2 = kn2(r2), e2) break;
          } else (t2 instanceof Ae2 || t2 instanceof Be2) && t2.input instanceof Xr2 && "zoom" === t2.input.name && (e2 = t2);
          return e2 instanceof at2 || t2.eachChild((t3) => {
            const r2 = kn2(t3);
            r2 instanceof at2 ? e2 = r2 : !e2 && r2 ? e2 = new at2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new at2("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e2;
        }
        function Mn2(t2) {
          if (true === t2 || false === t2) return true;
          if (!Array.isArray(t2) || 0 === t2.length) return false;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
            case "in":
              return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (const e2 of t2.slice(1)) if (!Mn2(e2) && "boolean" != typeof e2) return false;
              return true;
            default:
              return true;
          }
        }
        const In2 = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function zn2(t2) {
          if (null == t2) return { filter: () => true, needGeometry: false };
          Mn2(t2) || (t2 = Bn2(t2));
          const e2 = bn2(t2, In2);
          if ("error" === e2.result) throw new Error(e2.value.map((t3) => "".concat(t3.key, ": ").concat(t3.message)).join(", "));
          return { filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2), needGeometry: Cn2(t2) };
        }
        function Pn2(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Cn2(t2) {
          if (!Array.isArray(t2)) return false;
          if ("within" === t2[0] || "distance" === t2[0]) return true;
          for (let e2 = 1; e2 < t2.length; e2++) if (Cn2(t2[e2])) return true;
          return false;
        }
        function Bn2(t2) {
          if (!t2) return true;
          const e2 = t2[0];
          return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? Vn2(t2[1], t2[2], "==") : "!=" === e2 ? Tn2(Vn2(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? Vn2(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(Bn2))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(Bn2)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(Bn2).map(Tn2)) : "in" === e2 ? En2(t2[1], t2.slice(2)) : "!in" === e2 ? Tn2(En2(t2[1], t2.slice(2))) : "has" === e2 ? Fn2(t2[1]) : "!has" !== e2 || Tn2(Fn2(t2[1]));
          var r2;
        }
        function Vn2(t2, e2, r2) {
          switch (t2) {
            case "$type":
              return ["filter-type-".concat(r2), e2];
            case "$id":
              return ["filter-id-".concat(r2), e2];
            default:
              return ["filter-".concat(r2), t2, e2];
          }
        }
        function En2(t2, e2) {
          if (0 === e2.length) return false;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Pn2)]] : ["filter-in-small", t2, ["literal", e2]];
          }
        }
        function Fn2(t2) {
          switch (t2) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function Tn2(t2) {
          return ["!", t2];
        }
        function $n2(t2) {
          const e2 = typeof t2;
          if ("number" === e2 || "boolean" === e2 || "string" === e2 || null == t2) return JSON.stringify(t2);
          if (Array.isArray(t2)) {
            let e3 = "[";
            for (const r3 of t2) e3 += "".concat($n2(r3), ",");
            return "".concat(e3, "]");
          }
          const r2 = Object.keys(t2).sort();
          let n2 = "{";
          for (let e3 = 0; e3 < r2.length; e3++) n2 += "".concat(JSON.stringify(r2[e3]), ":").concat($n2(t2[r2[e3]]), ",");
          return "".concat(n2, "}");
        }
        function Ln2(t2) {
          let e2 = "";
          for (const r2 of K) e2 += "/".concat($n2(t2[r2]));
          return e2;
        }
        function Dn2(t2) {
          const e2 = t2.value;
          return e2 ? [new it2(t2.key, e2, "constants have been deprecated as of v8")] : [];
        }
        function On2(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function jn2(t2) {
          if (Array.isArray(t2)) return t2.map(jn2);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            const e2 = {};
            for (const r2 in t2) e2[r2] = jn2(t2[r2]);
            return e2;
          }
          return On2(t2);
        }
        function Rn2(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec, o2 = t2.validateSpec;
          let l3 = [];
          const u2 = un2(r2);
          if ("object" !== u2) return [new it2(e2, r2, "object expected, ".concat(u2, " found"))];
          for (const t3 in r2) {
            const u3 = t3.split(".")[0], c2 = n2[u3] || n2["*"];
            let h2;
            if (i2[u3]) h2 = i2[u3];
            else if (n2[u3]) h2 = o2;
            else if (i2["*"]) h2 = i2["*"];
            else {
              if (!n2["*"]) {
                l3.push(new it2(e2, r2[t3], 'unknown property "'.concat(t3, '"')));
                continue;
              }
              h2 = o2;
            }
            l3 = l3.concat(h2({ key: (e2 ? "".concat(e2, ".") : e2) + t3, value: r2[t3], valueSpec: c2, style: s2, styleSpec: a2, object: r2, objectKey: t3, validateSpec: o2 }, r2));
          }
          for (const t3 in n2) i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && l3.push(new it2(e2, r2, 'missing required property "'.concat(t3, '"')));
          return l3;
        }
        function Un2(t2) {
          const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || t2.validateSpec;
          if ("array" !== un2(e2)) return [new it2(s2, e2, "array expected, ".concat(un2(e2), " found"))];
          if (r2.length && e2.length !== r2.length) return [new it2(s2, e2, "array length ".concat(r2.length, " expected, length ").concat(e2.length, " found"))];
          if (r2["min-length"] && e2.length < r2["min-length"]) return [new it2(s2, e2, "array length at least ".concat(r2["min-length"], " expected, length ").concat(e2.length, " found"))];
          let o2 = { type: r2.value, values: r2.values };
          i2.$version < 7 && (o2.function = r2.function), "object" === un2(r2.value) && (o2 = r2.value);
          let l3 = [];
          for (let r3 = 0; r3 < e2.length; r3++) l3 = l3.concat(a2({ array: e2, arrayIndex: r3, value: e2[r3], valueSpec: o2, validateSpec: t2.validateSpec, style: n2, styleSpec: i2, key: "".concat(s2, "[").concat(r3, "]") }));
          return l3;
        }
        function qn2(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
          let i2 = un2(r2);
          return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new it2(e2, r2, "number expected, ".concat(i2, " found"))] : "minimum" in n2 && r2 < n2.minimum ? [new it2(e2, r2, "".concat(r2, " is less than the minimum value ").concat(n2.minimum))] : "maximum" in n2 && r2 > n2.maximum ? [new it2(e2, r2, "".concat(r2, " is greater than the maximum value ").concat(n2.maximum))] : [];
        }
        function Nn2(t2) {
          const e2 = t2.valueSpec, r2 = On2(t2.value.type);
          let n2, i2, s2, a2 = {};
          const o2 = "categorical" !== r2 && void 0 === t2.value.property, l3 = !o2, u2 = "array" === un2(t2.value.stops) && "array" === un2(t2.value.stops[0]) && "object" === un2(t2.value.stops[0][0]), c2 = Rn2({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, validateSpec: t2.validateSpec, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if ("identity" === r2) return [new it2(t3.key, t3.value, 'identity function may not have a "stops" property')];
            let e3 = [];
            const n3 = t3.value;
            return e3 = e3.concat(Un2({ key: t3.key, value: n3, valueSpec: t3.valueSpec, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), "array" === un2(n3) && 0 === n3.length && e3.push(new it2(t3.key, n3, "array must have at least one stop")), e3;
          }, default: function(t3) {
            return t3.validateSpec({ key: t3.key, value: t3.value, valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec });
          } } });
          return "identity" === r2 && o2 && c2.push(new it2(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new it2(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !ln2(t2.valueSpec) && c2.push(new it2(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l3 && !an2(t2.valueSpec) ? c2.push(new it2(t2.key, t2.value, "property functions not supported")) : o2 && !on2(t2.valueSpec) && c2.push(new it2(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new it2(t2.key, t2.value, '"property" property is required')), c2;
          function h2(t3) {
            let r3 = [];
            const n3 = t3.value, o3 = t3.key;
            if ("array" !== un2(n3)) return [new it2(o3, n3, "array expected, ".concat(un2(n3), " found"))];
            if (2 !== n3.length) return [new it2(o3, n3, "array length 2 expected, length ".concat(n3.length, " found"))];
            if (u2) {
              if ("object" !== un2(n3[0])) return [new it2(o3, n3, "object expected, ".concat(un2(n3[0]), " found"))];
              if (void 0 === n3[0].zoom) return [new it2(o3, n3, "object stop key must have zoom")];
              if (void 0 === n3[0].value) return [new it2(o3, n3, "object stop key must have value")];
              if (s2 && s2 > On2(n3[0].zoom)) return [new it2(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
              On2(n3[0].zoom) !== s2 && (s2 = On2(n3[0].zoom), i2 = void 0, a2 = {}), r3 = r3.concat(Rn2({ key: "".concat(o3, "[0]"), value: n3[0], valueSpec: { zoom: {} }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: qn2, value: p2 } }));
            } else r3 = r3.concat(p2({ key: "".concat(o3, "[0]"), value: n3[0], valueSpec: {}, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }, n3));
            return vn2(jn2(n3[1])) ? r3.concat([new it2("".concat(o3, "[1]"), n3[1], "expressions are not allowed in function stops.")]) : r3.concat(t3.validateSpec({ key: "".concat(o3, "[1]"), value: n3[1], valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function p2(t3, s3) {
            const o3 = un2(t3.value), l4 = On2(t3.value), u3 = null !== t3.value ? t3.value : s3;
            if (n2) {
              if (o3 !== n2) return [new it2(t3.key, u3, "".concat(o3, " stop domain type must match previous stop domain type ").concat(n2))];
            } else n2 = o3;
            if ("number" !== o3 && "string" !== o3 && "boolean" !== o3) return [new it2(t3.key, u3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o3 && "categorical" !== r2) {
              let n3 = "number expected, ".concat(o3, " found");
              return an2(e2) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new it2(t3.key, u3, n3)];
            }
            return "categorical" !== r2 || "number" !== o3 || isFinite(l4) && Math.floor(l4) === l4 ? "categorical" !== r2 && "number" === o3 && void 0 !== i2 && l4 < i2 ? [new it2(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l4, "categorical" === r2 && l4 in a2 ? [new it2(t3.key, u3, "stop domain values must be unique")] : (a2[l4] = true, [])) : [new it2(t3.key, u3, "integer expected, found ".concat(l4))];
          }
        }
        function Zn(t2) {
          const e2 = ("property" === t2.expressionContext ? An2 : bn2)(jn2(t2.value), t2.valueSpec);
          if ("error" === e2.result) return e2.value.map((e3) => new it2("".concat(t2.key).concat(e3.key), t2.value, e3.message));
          const r2 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined()) return [new it2(t2.key, t2.value, 'Invalid data expression for "'.concat(t2.propertyKey, '". Output values must be contained as literals within the expression.'))];
          if ("property" === t2.expressionContext && "layout" === t2.propertyType && !en2(r2)) return [new it2(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t2.expressionContext && !en2(r2)) return [new it2(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
          if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
            if (!rn2(r2, ["zoom", "feature-state"])) return [new it2(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t2.expressionContext && !tn2(r2)) return [new it2(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function Gn2(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
          return Array.isArray(n2.values) ? -1 === n2.values.indexOf(On2(r2)) && i2.push(new it2(e2, r2, "expected one of [".concat(n2.values.join(", "), "], ").concat(JSON.stringify(r2), " found"))) : -1 === Object.keys(n2.values).indexOf(On2(r2)) && i2.push(new it2(e2, r2, "expected one of [".concat(Object.keys(n2.values).join(", "), "], ").concat(JSON.stringify(r2), " found"))), i2;
        }
        function Kn2(t2) {
          return Mn2(jn2(t2.value)) ? Zn(st2({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Xn2(t2);
        }
        function Xn2(t2) {
          const e2 = t2.value, r2 = t2.key;
          if ("array" !== un2(e2)) return [new it2(r2, e2, "array expected, ".concat(un2(e2), " found"))];
          const n2 = t2.styleSpec;
          let i2, s2 = [];
          if (e2.length < 1) return [new it2(r2, e2, "filter array must have at least 1 element")];
          switch (s2 = s2.concat(Gn2({ key: "".concat(r2, "[0]"), value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), On2(e2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e2.length >= 2 && "$type" === On2(e2[1]) && s2.push(new it2(r2, e2, '"$type" cannot be use with operator "'.concat(e2[0], '"')));
            case "==":
            case "!=":
              3 !== e2.length && s2.push(new it2(r2, e2, 'filter array for operator "'.concat(e2[0], '" must have 3 elements')));
            case "in":
            case "!in":
              e2.length >= 2 && (i2 = un2(e2[1]), "string" !== i2 && s2.push(new it2("".concat(r2, "[1]"), e2[1], "string expected, ".concat(i2, " found"))));
              for (let a2 = 2; a2 < e2.length; a2++) i2 = un2(e2[a2]), "$type" === On2(e2[1]) ? s2 = s2.concat(Gn2({ key: "".concat(r2, "[").concat(a2, "]"), value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new it2("".concat(r2, "[").concat(a2, "]"), e2[a2], "string, number, or boolean expected, ".concat(i2, " found")));
              break;
            case "any":
            case "all":
            case "none":
              for (let n3 = 1; n3 < e2.length; n3++) s2 = s2.concat(Xn2({ key: "".concat(r2, "[").concat(n3, "]"), value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
              break;
            case "has":
            case "!has":
              i2 = un2(e2[1]), 2 !== e2.length ? s2.push(new it2(r2, e2, 'filter array for "'.concat(e2[0], '" operator must have 2 elements'))) : "string" !== i2 && s2.push(new it2("".concat(r2, "[1]"), e2[1], "string expected, ".concat(i2, " found")));
          }
          return s2;
        }
        function Hn2(t2, e2) {
          const r2 = t2.key, n2 = t2.validateSpec, i2 = t2.style, s2 = t2.styleSpec, a2 = t2.value, o2 = t2.objectKey, l3 = s2["".concat(e2, "_").concat(t2.layerType)];
          if (!l3) return [];
          const u2 = o2.match(/^(.*)-transition$/);
          if ("paint" === e2 && u2 && l3[u2[1]] && l3[u2[1]].transition) return n2({ key: r2, value: a2, valueSpec: s2.transition, style: i2, styleSpec: s2 });
          const c2 = t2.valueSpec || l3[o2];
          if (!c2) return [new it2(r2, a2, 'unknown property "'.concat(o2, '"'))];
          let h2;
          if ("string" === un2(a2) && an2(c2) && !c2.tokens && (h2 = /^{([^}]+)}$/.exec(a2))) return [new it2(r2, a2, '"'.concat(o2, '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ').concat(JSON.stringify(h2[1]), " }`."))];
          const p2 = [];
          return "symbol" === t2.layerType && ("text-field" === o2 && i2 && !i2.glyphs && p2.push(new it2(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && cn2(jn2(a2)) && "identity" === On2(a2.type) && p2.push(new it2(r2, a2, '"text-font" does not support identity functions'))), p2.concat(n2({ key: t2.key, value: a2, valueSpec: c2, style: i2, styleSpec: s2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
        }
        function Yn2(t2) {
          return Hn2(t2, "paint");
        }
        function Jn2(t2) {
          return Hn2(t2, "layout");
        }
        function Wn2(t2) {
          let e2 = [];
          const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
          r2.type || r2.ref || e2.push(new it2(n2, r2, 'either "type" or "ref" is required'));
          let a2 = On2(r2.type);
          const o2 = On2(r2.ref);
          if (r2.id) {
            const s3 = On2(r2.id);
            for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
              const t3 = i2.layers[a3];
              On2(t3.id) === s3 && e2.push(new it2(n2, r2.id, 'duplicate layer id "'.concat(r2.id, '", previously used at line ').concat(t3.id.__line__)));
            }
          }
          if ("ref" in r2) {
            let t3;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
              t4 in r2 && e2.push(new it2(n2, r2[t4], '"'.concat(t4, '" is prohibited for ref layers')));
            }), i2.layers.forEach((e3) => {
              On2(e3.id) === o2 && (t3 = e3);
            }), t3 ? t3.ref ? e2.push(new it2(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = On2(t3.type) : e2.push(new it2(n2, r2.ref, 'ref layer "'.concat(o2, '" not found')));
          } else if ("background" !== a2) if (r2.source) {
            const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && On2(t3.type);
            t3 ? "vector" === s3 && "raster" === a2 ? e2.push(new it2(n2, r2.source, 'layer "'.concat(r2.id, '" requires a raster source'))) : "raster-dem" !== s3 && "hillshade" === a2 ? e2.push(new it2(n2, r2.source, 'layer "'.concat(r2.id, '" requires a raster-dem source'))) : "raster" === s3 && "raster" !== a2 ? e2.push(new it2(n2, r2.source, 'layer "'.concat(r2.id, '" requires a vector source'))) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 ? e2.push(new it2(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === s3 && t3.lineMetrics || e2.push(new it2(n2, r2, 'layer "'.concat(r2.id, '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'))) : e2.push(new it2(n2, r2, 'layer "'.concat(r2.id, '" must specify a "source-layer"'))) : e2.push(new it2(n2, r2.source, 'source "'.concat(r2.source, '" not found')));
          } else e2.push(new it2(n2, r2, 'missing required property "source"'));
          return e2 = e2.concat(Rn2({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, objectElementValidators: { "*": () => [], type: () => t2.validateSpec({ key: "".concat(n2, ".type"), value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, object: r2, objectKey: "type" }), filter: Kn2, layout: (t3) => Rn2({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Jn2(st2({ layerType: a2 }, t4)) } }), paint: (t3) => Rn2({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Yn2(st2({ layerType: a2 }, t4)) } }) } })), e2;
        }
        function Qn2(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = un2(e2);
          return "string" !== n2 ? [new it2(r2, e2, "string expected, ".concat(n2, " found"))] : [];
        }
        const ti2 = { promoteId: function({ key: t2, value: e2 }) {
          if ("string" === un2(e2)) return Qn2({ key: t2, value: e2 });
          {
            const r2 = [];
            for (const n2 in e2) r2.push(...Qn2({ key: "".concat(t2, ".").concat(n2), value: e2[n2] }));
            return r2;
          }
        } };
        function ei2(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style, s2 = t2.validateSpec;
          if (!e2.type) return [new it2(r2, e2, '"type" is required')];
          const a2 = On2(e2.type);
          let o2;
          switch (a2) {
            case "vector":
            case "raster":
              return o2 = Rn2({ key: r2, value: e2, valueSpec: n2["source_".concat(a2.replace("-", "_"))], style: t2.style, styleSpec: n2, objectElementValidators: ti2, validateSpec: s2 }), o2;
            case "raster-dem":
              return o2 = function(t3) {
                var e3;
                const r3 = null !== (e3 = t3.sourceName) && void 0 !== e3 ? e3 : "", n3 = t3.value, i3 = t3.styleSpec, s3 = i3.source_raster_dem, a3 = t3.style;
                let o3 = [];
                const l3 = un2(n3);
                if (void 0 === n3) return o3;
                if ("object" !== l3) return o3.push(new it2("source_raster_dem", n3, "object expected, ".concat(l3, " found"))), o3;
                const u2 = "custom" === On2(n3.encoding), c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = t3.value.encoding ? '"'.concat(t3.value.encoding, '"') : "Default";
                for (const e4 in n3) !u2 && c2.includes(e4) ? o3.push(new it2(e4, n3[e4], 'In "'.concat(r3, '": "').concat(e4, '" is only valid when "encoding" is set to "custom". ').concat(h2, " encoding found"))) : s3[e4] ? o3 = o3.concat(t3.validateSpec({ key: e4, value: n3[e4], valueSpec: s3[e4], validateSpec: t3.validateSpec, style: a3, styleSpec: i3 })) : o3.push(new it2(e4, n3[e4], 'unknown property "'.concat(e4, '"')));
                return o3;
              }({ sourceName: r2, value: e2, style: t2.style, styleSpec: n2, validateSpec: s2 }), o2;
            case "geojson":
              if (o2 = Rn2({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, validateSpec: s2, objectElementValidators: ti2 }), e2.cluster) for (const t3 in e2.clusterProperties) {
                const [n3, i3] = e2.clusterProperties[t3], a3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                o2.push(...Zn({ key: "".concat(r2, ".").concat(t3, ".map"), value: i3, validateSpec: s2, expressionContext: "cluster-map" })), o2.push(...Zn({ key: "".concat(r2, ".").concat(t3, ".reduce"), value: a3, validateSpec: s2, expressionContext: "cluster-reduce" }));
              }
              return o2;
            case "video":
              return Rn2({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, validateSpec: s2, styleSpec: n2 });
            case "image":
              return Rn2({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, validateSpec: s2, styleSpec: n2 });
            case "canvas":
              return [new it2(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Gn2({ key: "".concat(r2, ".type"), value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, validateSpec: s2, styleSpec: n2 });
          }
        }
        function ri2(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
          let s2 = [];
          const a2 = un2(e2);
          if (void 0 === e2) return s2;
          if ("object" !== a2) return s2 = s2.concat([new it2("light", e2, "object expected, ".concat(a2, " found"))]), s2;
          for (const a3 in e2) {
            const o2 = a3.match(/^(.*)-transition$/);
            s2 = s2.concat(o2 && n2[o2[1]] && n2[o2[1]].transition ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: r2.transition, validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new it2(a3, e2[a3], 'unknown property "'.concat(a3, '"'))]);
          }
          return s2;
        }
        function ni2(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.sky, i2 = t2.style, s2 = un2(e2);
          if (void 0 === e2) return [];
          if ("object" !== s2) return [new it2("sky", e2, "object expected, ".concat(s2, " found"))];
          let a2 = [];
          for (const s3 in e2) a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new it2(s3, e2[s3], 'unknown property "'.concat(s3, '"'))]);
          return a2;
        }
        function ii2(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.terrain, i2 = t2.style;
          let s2 = [];
          const a2 = un2(e2);
          if (void 0 === e2) return s2;
          if ("object" !== a2) return s2 = s2.concat([new it2("terrain", e2, "object expected, ".concat(a2, " found"))]), s2;
          for (const a3 in e2) s2 = s2.concat(n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new it2(a3, e2[a3], 'unknown property "'.concat(a3, '"'))]);
          return s2;
        }
        function si2(t2) {
          let e2 = [];
          const r2 = t2.value, n2 = t2.key;
          if (Array.isArray(r2)) {
            const i2 = [], s2 = [];
            for (const a2 in r2) r2[a2].id && i2.includes(r2[a2].id) && e2.push(new it2(n2, r2, "all the sprites' ids must be unique, but ".concat(r2[a2].id, " is duplicated"))), i2.push(r2[a2].id), r2[a2].url && s2.includes(r2[a2].url) && e2.push(new it2(n2, r2, "all the sprites' URLs must be unique, but ".concat(r2[a2].url, " is duplicated"))), s2.push(r2[a2].url), e2 = e2.concat(Rn2({ key: "".concat(n2, "[").concat(a2, "]"), value: r2[a2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t2.validateSpec }));
            return e2;
          }
          return Qn2({ key: n2, value: r2 });
        }
        const ai2 = { "*": () => [], array: Un2, boolean: function(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = un2(e2);
          return "boolean" !== n2 ? [new it2(r2, e2, "boolean expected, ".concat(n2, " found"))] : [];
        }, number: qn2, color: function(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = un2(r2);
          return "string" !== n2 ? [new it2(e2, r2, "color expected, ".concat(n2, " found"))] : Kt2.parse(String(r2)) ? [] : [new it2(e2, r2, 'color expected, "'.concat(r2, '" found'))];
        }, constants: Dn2, enum: Gn2, filter: Kn2, function: Nn2, layer: Wn2, object: Rn2, source: ei2, light: ri2, sky: ni2, terrain: ii2, projection: function(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.projection, i2 = t2.style, s2 = un2(e2);
          if (void 0 === e2) return [];
          if ("object" !== s2) return [new it2("projection", e2, "object expected, ".concat(s2, " found"))];
          let a2 = [];
          for (const s3 in e2) a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new it2(s3, e2[s3], 'unknown property "'.concat(s3, '"'))]);
          return a2;
        }, string: Qn2, formatted: function(t2) {
          return 0 === Qn2(t2).length ? [] : Zn(t2);
        }, resolvedImage: function(t2) {
          return 0 === Qn2(t2).length ? [] : Zn(t2);
        }, padding: function(t2) {
          const e2 = t2.key, r2 = t2.value;
          if ("array" === un2(r2)) {
            if (r2.length < 1 || r2.length > 4) return [new it2(e2, r2, "padding requires 1 to 4 values; ".concat(r2.length, " values found"))];
            const n2 = { type: "number" };
            let i2 = [];
            for (let s2 = 0; s2 < r2.length; s2++) i2 = i2.concat(t2.validateSpec({ key: "".concat(e2, "[").concat(s2, "]"), value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
            return i2;
          }
          return qn2({ key: e2, value: r2, valueSpec: {} });
        }, variableAnchorOffsetCollection: function(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = un2(r2), i2 = t2.styleSpec;
          if ("array" !== n2 || r2.length < 1 || r2.length % 2 != 0) return [new it2(e2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let s2 = [];
          for (let n3 = 0; n3 < r2.length; n3 += 2) s2 = s2.concat(Gn2({ key: "".concat(e2, "[").concat(n3, "]"), value: r2[n3], valueSpec: i2.layout_symbol["text-anchor"] })), s2 = s2.concat(Un2({ key: "".concat(e2, "[").concat(n3 + 1, "]"), value: r2[n3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t2.validateSpec, style: t2.style, styleSpec: i2 }));
          return s2;
        }, sprite: si2 };
        function oi2(t2) {
          const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
          return t2.validateSpec = oi2, r2.expression && cn2(On2(e2)) ? Nn2(t2) : r2.expression && vn2(jn2(e2)) ? Zn(t2) : r2.type && ai2[r2.type] ? ai2[r2.type](t2) : Rn2(st2({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
        }
        function li2(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = Qn2(t2);
          return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new it2(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new it2(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function ui2(t2, e2 = G) {
          let r2 = [];
          return r2 = r2.concat(oi2({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, validateSpec: oi2, objectElementValidators: { glyphs: li2, "*": () => [] } })), t2.constants && (r2 = r2.concat(Dn2({ key: "constants", value: t2.constants, style: t2, styleSpec: e2, validateSpec: oi2 }))), hi2(r2);
        }
        function ci2(t2) {
          return function(e2) {
            return t2(__spreadProps(__spreadValues({}, e2), { validateSpec: oi2 }));
          };
        }
        function hi2(t2) {
          return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
        }
        function pi2(t2) {
          return function(...e2) {
            return hi2(t2.apply(this, e2));
          };
        }
        ui2.source = pi2(ci2(ei2)), ui2.sprite = pi2(ci2(si2)), ui2.glyphs = pi2(ci2(li2)), ui2.light = pi2(ci2(ri2)), ui2.sky = pi2(ci2(ni2)), ui2.terrain = pi2(ci2(ii2)), ui2.layer = pi2(ci2(Wn2)), ui2.filter = pi2(ci2(Kn2)), ui2.paintProperty = pi2(ci2(Yn2)), ui2.layoutProperty = pi2(ci2(Jn2));
        const fi2 = ui2, di2 = fi2.light, yi2 = fi2.sky, mi2 = fi2.paintProperty, gi2 = fi2.layoutProperty;
        function xi2(t2, e2) {
          let r2 = false;
          if (e2 && e2.length) for (const n2 of e2) t2.fire(new N(new Error(n2.message))), r2 = true;
          return r2;
        }
        class vi2 {
          constructor(t2, e2, r2) {
            const n2 = this.cells = [];
            if (t2 instanceof ArrayBuffer) {
              this.arrayBuffer = t2;
              const i3 = new Int32Array(this.arrayBuffer);
              t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
              for (let t3 = 0; t3 < this.d * this.d; t3++) {
                const e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
                n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
              }
              const s2 = i3[3 + n2.length + 1];
              this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r2;
              for (let t3 = 0; t3 < this.d * this.d; t3++) n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
            const i2 = r2 / e2 * t2;
            this.min = -i2, this.max = t2 + i2;
          }
          insert(t2, e2, r2, n2, i2) {
            this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t2, e2, r2, n2, i2, s2) {
            this.cells[i2].push(s2);
          }
          query(t2, e2, r2, n2, i2) {
            const s2 = this.min, a2 = this.max;
            if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2) return Array.prototype.slice.call(this.keys);
            {
              const s3 = [];
              return this._forEachCell(t2, e2, r2, n2, this._queryCell, s3, {}, i2), s3;
            }
          }
          _queryCell(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l3 = this.cells[i2];
            if (null !== l3) {
              const i3 = this.keys, u2 = this.bboxes;
              for (let c2 = 0; c2 < l3.length; c2++) {
                const h2 = l3[c2];
                if (void 0 === a2[h2]) {
                  const l4 = 4 * h2;
                  (o2 ? o2(u2[l4 + 0], u2[l4 + 1], u2[l4 + 2], u2[l4 + 3]) : t2 <= u2[l4 + 2] && e2 <= u2[l4 + 3] && r2 >= u2[l4 + 0] && n2 >= u2[l4 + 1]) ? (a2[h2] = true, s2.push(i3[h2])) : a2[h2] = false;
                }
              }
            }
          }
          _forEachCell(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l3 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
            for (let p2 = l3; p2 <= c2; p2++) for (let l4 = u2; l4 <= h2; l4++) {
              const u3 = this.d * l4 + p2;
              if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l4), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l4 + 1))) && i2.call(this, t2, e2, r2, n2, u3, s2, a2, o2)) return;
            }
          }
          _convertFromCellCoord(t2) {
            return (t2 - this.padding) / this.scale;
          }
          _convertToCellCoord(t2) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
            let r2 = 0;
            for (let t3 = 0; t3 < this.cells.length; t3++) r2 += this.cells[t3].length;
            const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
            n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
            let i2 = e2;
            for (let e3 = 0; e3 < t2.length; e3++) {
              const r3 = t2[e3];
              n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
            }
            return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
          }
          static serialize(t2, e2) {
            const r2 = t2.toArrayBuffer();
            return e2 && e2.push(r2), { buffer: r2 };
          }
          static deserialize(t2) {
            return new vi2(t2.buffer);
          }
        }
        const bi2 = {};
        function wi2(t2, e2, r2 = {}) {
          if (bi2[t2]) throw new Error("".concat(t2, " is already registered."));
          Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), bi2[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
        }
        wi2("Object", Object), wi2("TransferableGridIndex", vi2), wi2("Color", Kt2), wi2("Error", Error), wi2("AJAXError", L2), wi2("ResolvedImage", te), wi2("StylePropertyFunction", Sn2), wi2("StyleExpression", xn2, { omit: ["_evaluator"] }), wi2("ZoomDependentExpression", _n2), wi2("ZoomConstantExpression", wn2), wi2("CompoundExpression", Xr2, { omit: ["_evaluate"] });
        for (const t2 in Kr2) Kr2[t2]._classRegistryKey || wi2("Expression_".concat(t2), Kr2[t2]);
        function _i2(t2) {
          return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
        }
        function Ai2(t2) {
          return t2.$name || t2.constructor._classRegistryKey;
        }
        function Si2(t2) {
          return !function(t3) {
            if (null === t3 || "object" != typeof t3) return false;
            const e2 = Ai2(t3);
            return !(!e2 || "Object" === e2);
          }(t2) && (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || t2 instanceof Error || _i2(t2) || I(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData);
        }
        function ki2(t2, e2) {
          if (Si2(t2)) return (_i2(t2) || I(t2)) && e2 && e2.push(t2), ArrayBuffer.isView(t2) && e2 && e2.push(t2.buffer), t2 instanceof ImageData && e2 && e2.push(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            const r3 = [];
            for (const n3 of t2) r3.push(ki2(n3, e2));
            return r3;
          }
          if ("object" != typeof t2) throw new Error("can't serialize object of type " + typeof t2);
          const r2 = Ai2(t2);
          if (!r2) throw new Error("can't serialize object of unregistered class ".concat(t2.constructor.name));
          if (!bi2[r2]) throw new Error("".concat(r2, " is not registered."));
          const { klass: n2 } = bi2[r2], i2 = n2.serialize ? n2.serialize(t2, e2) : {};
          if (n2.serialize) {
            if (e2 && i2 === e2[e2.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const n3 in t2) {
              if (!t2.hasOwnProperty(n3)) continue;
              if (bi2[r2].omit.indexOf(n3) >= 0) continue;
              const s2 = t2[n3];
              i2[n3] = bi2[r2].shallow.indexOf(n3) >= 0 ? s2 : ki2(s2, e2);
            }
            t2 instanceof Error && (i2.message = t2.message);
          }
          if (i2.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== r2 && (i2.$name = r2), i2;
        }
        function Mi2(t2) {
          if (Si2(t2)) return t2;
          if (Array.isArray(t2)) return t2.map(Mi2);
          if ("object" != typeof t2) throw new Error("can't deserialize object of type " + typeof t2);
          const e2 = Ai2(t2) || "Object";
          if (!bi2[e2]) throw new Error("can't deserialize unregistered class ".concat(e2));
          const { klass: r2 } = bi2[e2];
          if (!r2) throw new Error("can't deserialize unregistered class ".concat(e2));
          if (r2.deserialize) return r2.deserialize(t2);
          const n2 = Object.create(r2.prototype);
          for (const r3 of Object.keys(t2)) {
            if ("$name" === r3) continue;
            const i2 = t2[r3];
            n2[r3] = bi2[e2].shallow.indexOf(r3) >= 0 ? i2 : Mi2(i2);
          }
          return n2;
        }
        class Ii2 {
          constructor() {
            this.first = true;
          }
          update(t2, e2) {
            const r2 = Math.floor(t2);
            return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
          }
        }
        const zi2 = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
        function Pi2(t2) {
          for (const e2 of t2) if (Ti2(e2.charCodeAt(0))) return true;
          return false;
        }
        function Ci2(t2) {
          for (const e2 of t2) if (!Ei2(e2.charCodeAt(0))) return false;
          return true;
        }
        function Bi2(t2) {
          const e2 = t2.map((t3) => {
            try {
              return new RegExp("\\p{sc=".concat(t3, "}"), "u").source;
            } catch (t4) {
              return null;
            }
          }).filter((t3) => t3);
          return new RegExp(e2.join("|"), "u");
        }
        const Vi2 = Bi2(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Ei2(t2) {
          return !Vi2.test(String.fromCodePoint(t2));
        }
        const Fi2 = Bi2(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function Ti2(t2) {
          return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(zi2["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || zi2["CJK Compatibility"](t2) || zi2["CJK Strokes"](t2) || !(!zi2["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || zi2["Enclosed CJK Letters and Months"](t2) || zi2["Ideographic Description Characters"](t2) || zi2.Kanbun(t2) || zi2.Katakana(t2) && 12540 !== t2 || !(!zi2["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!zi2["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || zi2["Vertical Forms"](t2) || zi2["Yijing Hexagram Symbols"](t2) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(t2)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(t2)) || Fi2.test(String.fromCodePoint(t2)))));
        }
        function $i2(t2) {
          return !(Ti2(t2) || function(t3) {
            return !!(zi2["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || zi2["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || zi2["Letterlike Symbols"](t3) || zi2["Number Forms"](t3) || zi2["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || zi2["Control Pictures"](t3) && 9251 !== t3 || zi2["Optical Character Recognition"](t3) || zi2["Enclosed Alphanumerics"](t3) || zi2["Geometric Shapes"](t3) || zi2["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || zi2["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || zi2["CJK Symbols and Punctuation"](t3) || zi2.Katakana(t3) || zi2["Private Use Area"](t3) || zi2["CJK Compatibility Forms"](t3) || zi2["Small Form Variants"](t3) || zi2["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
          }(t2));
        }
        const Li2 = Bi2(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function Di2(t2) {
          return Li2.test(String.fromCodePoint(t2));
        }
        function Oi2(t2, e2) {
          return !(!e2 && Di2(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || zi2.Khmer(t2));
        }
        function ji2(t2) {
          for (const e2 of t2) if (Di2(e2.charCodeAt(0))) return true;
          return false;
        }
        const Ri2 = new class {
          constructor() {
            this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
          }
          setState(t2) {
            this.pluginStatus = t2.pluginStatus, this.pluginURL = t2.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(t2) {
            this.applyArabicShaping = t2.applyArabicShaping, this.processBidirectionalText = t2.processBidirectionalText, this.processStyledBidirectionalText = t2.processStyledBidirectionalText;
          }
          isParsed() {
            return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
          }
          getPluginURL() {
            return this.pluginURL;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
        }();
        class Ui2 {
          constructor(t2, e2) {
            this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ii2(), this.transition = {});
          }
          isSupportedScript(t2) {
            return function(t3, e2) {
              for (const r2 of t3) if (!Oi2(r2.charCodeAt(0), e2)) return false;
              return true;
            }(t2, "loaded" === Ri2.getRTLTextPluginStatus());
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
            return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
          }
        }
        class qi2 {
          constructor(t2, e2) {
            this.property = t2, this.value = e2, this.expression = function(t3, e3) {
              if (cn2(t3)) return new Sn2(t3, e3);
              if (vn2(t3)) {
                const r2 = An2(t3, e3);
                if ("error" === r2.result) throw new Error(r2.value.map((t4) => "".concat(t4.key, ": ").concat(t4.message)).join(", "));
                return r2.value;
              }
              {
                let r2 = t3;
                return "color" === e3.type && "string" == typeof t3 ? r2 = Kt2.parse(t3) : "padding" !== e3.type || "number" != typeof t3 && !Array.isArray(t3) ? "variableAnchorOffsetCollection" === e3.type && Array.isArray(t3) && (r2 = Qt2.parse(t3)) : r2 = Jt2.parse(t3), { kind: "constant", evaluate: () => r2 };
              }
            }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t2, e2, r2) {
            return this.property.possiblyEvaluate(this, t2, e2, r2);
          }
        }
        class Ni2 {
          constructor(t2) {
            this.property = t2, this.value = new qi2(t2, void 0);
          }
          transitioned(t2, e2) {
            return new Gi2(this.property, this.value, e2, g({}, t2.transition, this.transition), t2.now);
          }
          untransitioned() {
            return new Gi2(this.property, this.value, null, {}, 0);
          }
        }
        class Zi2 {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
          }
          getValue(t2) {
            return w(this._values[t2].value.value);
          }
          setValue(t2, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Ni2(this._values[t2].property)), this._values[t2].value = new qi2(this._values[t2].property, null === e2 ? void 0 : w(e2));
          }
          getTransition(t2) {
            return w(this._values[t2].transition);
          }
          setTransition(t2, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Ni2(this._values[t2].property)), this._values[t2].transition = w(e2) || void 0;
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
              const n2 = this.getTransition(e2);
              void 0 !== n2 && (t2["".concat(e2, "-transition")] = n2);
            }
            return t2;
          }
          transitioned(t2, e2) {
            const r2 = new Ki2(this._properties);
            for (const n2 of Object.keys(this._values)) r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
            return r2;
          }
          untransitioned() {
            const t2 = new Ki2(this._properties);
            for (const e2 of Object.keys(this._values)) t2._values[e2] = this._values[e2].untransitioned();
            return t2;
          }
        }
        class Gi2 {
          constructor(t2, e2, r2, n2, i2) {
            this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
            if (s2) {
              if (n2 > this.end) return this.prior = null, i2;
              if (this.value.isDataDriven()) return this.prior = null, i2;
              if (n2 < this.begin) return s2.possiblyEvaluate(t2, e2, r2);
              {
                const a2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, function(t3) {
                  if (t3 <= 0) return 0;
                  if (t3 >= 1) return 1;
                  const e3 = t3 * t3, r3 = e3 * t3;
                  return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
                }(a2));
              }
            }
            return i2;
          }
        }
        class Ki2 {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = new Yi2(this._properties);
            for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
          hasTransition() {
            for (const t2 of Object.keys(this._values)) if (this._values[t2].prior) return true;
            return false;
          }
        }
        class Xi2 {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
          }
          hasValue(t2) {
            return void 0 !== this._values[t2].value;
          }
          getValue(t2) {
            return w(this._values[t2].value);
          }
          setValue(t2, e2) {
            this._values[t2] = new qi2(this._values[t2].property, null === e2 ? void 0 : w(e2));
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
            }
            return t2;
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = new Yi2(this._properties);
            for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
        }
        class Hi2 {
          constructor(t2, e2, r2) {
            this.property = t2, this.value = e2, this.parameters = r2;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t2) {
            return "constant" === this.value.kind ? this.value.value : t2;
          }
          evaluate(t2, e2, r2, n2) {
            return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
          }
        }
        class Yi2 {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          }
          get(t2) {
            return this._values[t2];
          }
        }
        class Ji2 {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            if (t2.isDataDriven()) throw new Error("Value should not be data driven");
            return t2.expression.evaluate(e2);
          }
          interpolate(t2, e2, r2) {
            const n2 = Ce2[this.specification.type];
            return n2 ? n2(t2, e2, r2) : t2;
          }
        }
        class Wi2 {
          constructor(t2, e2) {
            this.specification = t2, this.overrides = e2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return new Hi2(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
          }
          interpolate(t2, e2, r2) {
            if ("constant" !== t2.value.kind || "constant" !== e2.value.kind) return t2;
            if (void 0 === t2.value.value || void 0 === e2.value.value) return new Hi2(this, { kind: "constant", value: void 0 }, t2.parameters);
            const n2 = Ce2[this.specification.type];
            if (n2) {
              const i2 = n2(t2.value.value, e2.value.value, r2);
              return new Hi2(this, { kind: "constant", value: i2 }, t2.parameters);
            }
            return t2;
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
          }
        }
        class Qi2 extends Wi2 {
          possiblyEvaluate(t2, e2, r2, n2) {
            if (void 0 === t2.value) return new Hi2(this, { kind: "constant", value: void 0 }, e2);
            if ("constant" === t2.expression.kind) {
              const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = "resolvedImage" === t2.property.specification.type && "string" != typeof i2 ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
              return new Hi2(this, { kind: "constant", value: a2 }, e2);
            }
            if ("camera" === t2.expression.kind) {
              const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
              return new Hi2(this, { kind: "constant", value: r3 }, e2);
            }
            return new Hi2(this, t2.expression, e2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            if ("source" === t2.kind) {
              const a2 = t2.evaluate(e2, r2, n2, i2, s2);
              return this._calculate(a2, a2, a2, e2);
            }
            return "composite" === t2.kind ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
          }
          _calculate(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class ts2 {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            if (void 0 !== t2.value) {
              if ("constant" === t2.expression.kind) {
                const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
                return this._calculate(i2, i2, i2, e2);
              }
              return this._calculate(t2.expression.evaluate(new Ui2(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new Ui2(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new Ui2(Math.floor(e2.zoom + 1), e2)), e2);
            }
          }
          _calculate(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class es2 {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return !!t2.expression.evaluate(e2, null, {}, r2, n2);
          }
          interpolate() {
            return false;
          }
        }
        class rs2 {
          constructor(t2) {
            this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e2 in t2) {
              const r2 = t2[e2];
              r2.specification.overridable && this.overridableProperties.push(e2);
              const n2 = this.defaultPropertyValues[e2] = new qi2(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new Ni2(r2);
              this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
            }
          }
        }
        wi2("DataDrivenProperty", Wi2), wi2("DataConstantProperty", Ji2), wi2("CrossFadedDataDrivenProperty", Qi2), wi2("CrossFadedProperty", ts2), wi2("ColorRampProperty", es2);
        const ns2 = "-transition";
        class is2 extends Z {
          constructor(t2, e2) {
            if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Xi2(e2.layout)), e2.paint)) {
              this._transitionablePaint = new Zi2(e2.paint);
              for (const e3 in t2.paint) this.setPaintProperty(e3, t2.paint[e3], { validate: false });
              for (const e3 in t2.layout) this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Yi2(e2.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t2) {
            return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
          }
          setLayoutProperty(t2, e2, r2 = {}) {
            null != e2 && this._validate(gi2, "layers.".concat(this.id, ".layout.").concat(t2), t2, e2, r2) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
          }
          getPaintProperty(t2) {
            return t2.endsWith(ns2) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
          }
          setPaintProperty(t2, e2, r2 = {}) {
            if (null != e2 && this._validate(mi2, "layers.".concat(this.id, ".paint.").concat(t2), t2, e2, r2)) return false;
            if (t2.endsWith(ns2)) return this._transitionablePaint.setTransition(t2.slice(0, -11), e2 || void 0), false;
            {
              const r3 = this._transitionablePaint._values[t2], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i2 = r3.value.isDataDriven(), s2 = r3.value;
              this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
              const a2 = this._transitionablePaint._values[t2].value;
              return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
            }
          }
          _handleSpecialPaintPropertyUpdate(t2) {
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return false;
          }
          isHidden(t2) {
            return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t2) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t2, e2) {
            t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
          }
          serialize() {
            const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), b(t2, (t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length));
          }
          _validate(t2, e2, r2, n2, i2 = {}) {
            return (!i2 || false !== i2.validate) && xi2(this, t2.call(fi2, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: G, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t2 in this.paint._values) {
              const e2 = this.paint.get(t2);
              if (e2 instanceof Hi2 && an2(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent) return true;
            }
            return false;
          }
        }
        const ss2 = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class as2 {
          constructor(t2, e2) {
            this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class os2 {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t2, e2) {
            return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }
          static deserialize(t2) {
            const e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t2) {
            this.reserve(t2), this.length = t2;
          }
          reserve(t2) {
            if (t2 > this.capacity) {
              this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function ls2(t2, e2 = 1) {
          let r2 = 0, n2 = 0;
          return { members: t2.map((t3) => {
            const i2 = ss2[t3.type].BYTES_PER_ELEMENT, s2 = r2 = us2(r2, Math.max(e2, i2)), a2 = t3.components || 1;
            return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
          }), size: us2(r2, Math.max(n2, e2)), alignment: e2 };
        }
        function us2(t2, e2) {
          return Math.ceil(t2 / e2) * e2;
        }
        class cs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
          }
        }
        cs2.prototype.bytesPerElement = 4, wi2("StructArrayLayout2i4", cs2);
        class hs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
          }
        }
        hs2.prototype.bytesPerElement = 6, wi2("StructArrayLayout3i6", hs2);
        class ps2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
          }
        }
        ps2.prototype.bytesPerElement = 8, wi2("StructArrayLayout4i8", ps2);
        class fs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        fs2.prototype.bytesPerElement = 12, wi2("StructArrayLayout2i4i12", fs2);
        class ds2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 4 * t2, l3 = 8 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l3 + 4] = n2, this.uint8[l3 + 5] = i2, this.uint8[l3 + 6] = s2, this.uint8[l3 + 7] = a2, t2;
          }
        }
        ds2.prototype.bytesPerElement = 8, wi2("StructArrayLayout2i4ub8", ds2);
        class ys2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
          }
        }
        ys2.prototype.bytesPerElement = 8, wi2("StructArrayLayout2f8", ys2);
        class ms2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2) {
            const c2 = this.length;
            return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l3, u2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2) {
            const h2 = 10 * t2;
            return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l3, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
          }
        }
        ms2.prototype.bytesPerElement = 20, wi2("StructArrayLayout10ui20", ms2);
        class gs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2) {
            const p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2) {
            const f2 = 12 * t2;
            return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l3, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
          }
        }
        gs2.prototype.bytesPerElement = 24, wi2("StructArrayLayout4i4ui4i24", gs2);
        class xs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        xs2.prototype.bytesPerElement = 12, wi2("StructArrayLayout3f12", xs2);
        class vs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint32[1 * t2 + 0] = e2, t2;
          }
        }
        vs2.prototype.bytesPerElement = 4, wi2("StructArrayLayout1ul4", vs2);
        class bs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
            const u2 = this.length;
            return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, s2, a2, o2, l3);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2) {
            const c2 = 10 * t2, h2 = 5 * t2;
            return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l3, this.uint16[c2 + 9] = u2, t2;
          }
        }
        bs2.prototype.bytesPerElement = 20, wi2("StructArrayLayout6i1ul2ui20", bs2);
        class ws2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        ws2.prototype.bytesPerElement = 12, wi2("StructArrayLayout2i2i2i12", ws2);
        class _s2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
          }
          emplace(t2, e2, r2, n2, i2, s2) {
            const a2 = 4 * t2, o2 = 8 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
          }
        }
        _s2.prototype.bytesPerElement = 16, wi2("StructArrayLayout2f1f2i16", _s2);
        class As2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 16 * t2, l3 = 4 * t2, u2 = 8 * t2;
            return this.uint8[o2 + 0] = e2, this.uint8[o2 + 1] = r2, this.float32[l3 + 1] = n2, this.float32[l3 + 2] = i2, this.int16[u2 + 6] = s2, this.int16[u2 + 7] = a2, t2;
          }
        }
        As2.prototype.bytesPerElement = 16, wi2("StructArrayLayout2ub2f2i16", As2);
        class Ss2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
          }
        }
        Ss2.prototype.bytesPerElement = 6, wi2("StructArrayLayout3ui6", Ss2);
        class ks2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3, m2) {
            const g2 = this.length;
            return this.resize(g2 + 1), this.emplace(g2, t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3, m2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3, m2, g2) {
            const x2 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
            return this.int16[x2 + 0] = e2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = a2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l3, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y3, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, t2;
          }
        }
        ks2.prototype.bytesPerElement = 48, wi2("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ks2);
        class Ms2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3, m2, g2, x2, v2, b2, w2, _2, A3, S2, k2, M3, I2) {
            const z3 = this.length;
            return this.resize(z3 + 1), this.emplace(z3, t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3, m2, g2, x2, v2, b2, w2, _2, A3, S2, k2, M3, I2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3, m2, g2, x2, v2, b2, w2, _2, A3, S2, k2, M3, I2, z3) {
            const P2 = 32 * t2, C3 = 16 * t2;
            return this.int16[P2 + 0] = e2, this.int16[P2 + 1] = r2, this.int16[P2 + 2] = n2, this.int16[P2 + 3] = i2, this.int16[P2 + 4] = s2, this.int16[P2 + 5] = a2, this.int16[P2 + 6] = o2, this.int16[P2 + 7] = l3, this.uint16[P2 + 8] = u2, this.uint16[P2 + 9] = c2, this.uint16[P2 + 10] = h2, this.uint16[P2 + 11] = p2, this.uint16[P2 + 12] = f2, this.uint16[P2 + 13] = d2, this.uint16[P2 + 14] = y3, this.uint16[P2 + 15] = m2, this.uint16[P2 + 16] = g2, this.uint16[P2 + 17] = x2, this.uint16[P2 + 18] = v2, this.uint16[P2 + 19] = b2, this.uint16[P2 + 20] = w2, this.uint16[P2 + 21] = _2, this.uint16[P2 + 22] = A3, this.uint32[C3 + 12] = S2, this.float32[C3 + 13] = k2, this.float32[C3 + 14] = M3, this.uint16[P2 + 30] = I2, this.uint16[P2 + 31] = z3, t2;
          }
        }
        Ms2.prototype.bytesPerElement = 64, wi2("StructArrayLayout8i15ui1ul2f2ui64", Ms2);
        class Is2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.float32[1 * t2 + 0] = e2, t2;
          }
        }
        Is2.prototype.bytesPerElement = 4, wi2("StructArrayLayout1f4", Is2);
        class zs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.uint16[6 * t2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        zs2.prototype.bytesPerElement = 12, wi2("StructArrayLayout1ui2f12", zs2);
        class Ps2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 4 * t2;
            return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
          }
        }
        Ps2.prototype.bytesPerElement = 8, wi2("StructArrayLayout1ul2ui8", Ps2);
        class Cs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
          }
        }
        Cs2.prototype.bytesPerElement = 4, wi2("StructArrayLayout2ui4", Cs2);
        class Bs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint16[1 * t2 + 0] = e2, t2;
          }
        }
        Bs2.prototype.bytesPerElement = 2, wi2("StructArrayLayout1ui2", Bs2);
        class Vs2 extends os2 {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
          }
        }
        Vs2.prototype.bytesPerElement = 16, wi2("StructArrayLayout4f16", Vs2);
        class Es2 extends as2 {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new s(this.anchorPointX, this.anchorPointY);
          }
        }
        Es2.prototype.size = 20;
        class Fs2 extends bs2 {
          get(t2) {
            return new Es2(this, t2);
          }
        }
        wi2("CollisionBoxArray", Fs2);
        class Ts2 extends as2 {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t2) {
            this._structArray.uint8[this._pos1 + 37] = t2;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t2) {
            this._structArray.uint8[this._pos1 + 38] = t2;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 10] = t2;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        Ts2.prototype.size = 48;
        class $s2 extends ks2 {
          get(t2) {
            return new Ts2(this, t2);
          }
        }
        wi2("PlacedSymbolArray", $s2);
        class Ls2 extends as2 {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 12] = t2;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        Ls2.prototype.size = 64;
        class Ds2 extends Ms2 {
          get(t2) {
            return new Ls2(this, t2);
          }
        }
        wi2("SymbolInstanceArray", Ds2);
        class Os2 extends Is2 {
          getoffsetX(t2) {
            return this.float32[1 * t2 + 0];
          }
        }
        wi2("GlyphOffsetArray", Os2);
        class js2 extends hs2 {
          getx(t2) {
            return this.int16[3 * t2 + 0];
          }
          gety(t2) {
            return this.int16[3 * t2 + 1];
          }
          gettileUnitDistanceFromAnchor(t2) {
            return this.int16[3 * t2 + 2];
          }
        }
        wi2("SymbolLineVertexArray", js2);
        class Rs2 extends as2 {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Rs2.prototype.size = 12;
        class Us2 extends zs2 {
          get(t2) {
            return new Rs2(this, t2);
          }
        }
        wi2("TextAnchorOffsetArray", Us2);
        class qs2 extends as2 {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        qs2.prototype.size = 8;
        class Ns2 extends Ps2 {
          get(t2) {
            return new qs2(this, t2);
          }
        }
        wi2("FeatureIndexArray", Ns2);
        class Zs2 extends cs2 {
        }
        class Gs2 extends cs2 {
        }
        class Ks2 extends cs2 {
        }
        class Xs2 extends fs2 {
        }
        class Hs2 extends ds2 {
        }
        class Ys2 extends ys2 {
        }
        class Js2 extends ms2 {
        }
        class Ws2 extends gs2 {
        }
        class Qs2 extends xs2 {
        }
        class ta2 extends vs2 {
        }
        class ea2 extends ws2 {
        }
        class ra2 extends As2 {
        }
        class na2 extends Ss2 {
        }
        class ia2 extends Cs2 {
        }
        const sa2 = ls2([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: aa2 } = sa2;
        class oa2 {
          constructor(t2 = []) {
            this.segments = t2;
          }
          prepareSegment(t2, e2, r2, n2) {
            let i2 = this.segments[this.segments.length - 1];
            return t2 > oa2.MAX_VERTEX_ARRAY_LENGTH && A2("Max vertices per segment is ".concat(oa2.MAX_VERTEX_ARRAY_LENGTH, ": bucket requested ").concat(t2)), (!i2 || i2.vertexLength + t2 > oa2.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t2 of this.segments) for (const e2 in t2.vaos) t2.vaos[e2].destroy();
          }
          static simpleSegment(t2, e2, r2, n2) {
            return new oa2([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        function la2(t2, e2) {
          return 256 * (t2 = y2(Math.floor(t2), 0, 255)) + y2(Math.floor(e2), 0, 255);
        }
        oa2.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, wi2("SegmentVector", oa2);
        const ua2 = ls2([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var ca2 = { exports: {} }, ha2 = { exports: {} };
        ha2.exports = function(t2, e2) {
          var r2, n2, i2, s2, a2, o2, l3, u2;
          for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; ) l3 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l3 = (65535 & (l3 = (l3 = (65535 & l3) * a2 + (((l3 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o2 + (((l3 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l3 = 0, r2) {
            case 3:
              l3 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
            case 2:
              l3 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
            case 1:
              i2 ^= l3 = (65535 & (l3 = (l3 = (65535 & (l3 ^= 255 & t2.charCodeAt(u2))) * a2 + (((l3 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o2 + (((l3 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
        var pa2 = ha2.exports, fa2 = { exports: {} };
        fa2.exports = function(t2, e2) {
          for (var r2, n2 = t2.length, i2 = e2 ^ n2, s2 = 0; n2 >= 4; ) r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
        var da2 = pa2, ya2 = fa2.exports;
        ca2.exports = da2, ca2.exports.murmur3 = da2, ca2.exports.murmur2 = ya2;
        var ma2 = r(ca2.exports);
        class ga2 {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t2, e2, r2, n2) {
            this.ids.push(xa2(t2)), this.positions.push(e2, r2, n2);
          }
          getPositions(t2) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const e2 = xa2(t2);
            let r2 = 0, n2 = this.ids.length - 1;
            for (; r2 < n2; ) {
              const t3 = r2 + n2 >> 1;
              this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
            }
            const i2 = [];
            for (; this.ids[r2] === e2; ) i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
            return i2;
          }
          static serialize(t2, e2) {
            const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
            return va2(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
          }
          static deserialize(t2) {
            const e2 = new ga2();
            return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
          }
        }
        function xa2(t2) {
          const e2 = +t2;
          return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : ma2(String(t2));
        }
        function va2(t2, e2, r2, n2) {
          for (; r2 < n2; ) {
            const i2 = t2[r2 + n2 >> 1];
            let s2 = r2 - 1, a2 = n2 + 1;
            for (; ; ) {
              do {
                s2++;
              } while (t2[s2] < i2);
              do {
                a2--;
              } while (t2[a2] > i2);
              if (s2 >= a2) break;
              ba2(t2, s2, a2), ba2(e2, 3 * s2, 3 * a2), ba2(e2, 3 * s2 + 1, 3 * a2 + 1), ba2(e2, 3 * s2 + 2, 3 * a2 + 2);
            }
            a2 - r2 < n2 - a2 ? (va2(t2, e2, r2, a2), r2 = a2 + 1) : (va2(t2, e2, a2 + 1, n2), n2 = a2);
          }
        }
        function ba2(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        wi2("FeaturePositionMap", ga2);
        class wa2 {
          constructor(t2, e2) {
            this.gl = t2.gl, this.location = e2;
          }
        }
        class _a2 extends wa2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
          }
        }
        class Aa2 extends wa2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
          }
        }
        class Sa2 extends wa2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = Kt2.transparent;
          }
          set(t2) {
            t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
          }
        }
        const ka2 = new Float32Array(16);
        function Ma2(t2) {
          return [la2(255 * t2.r, 255 * t2.g), la2(255 * t2.b, 255 * t2.a)];
        }
        class Ia2 {
          constructor(t2, e2, r2) {
            this.value = t2, this.uniformNames = e2.map((t3) => "u_".concat(t3)), this.type = r2;
          }
          setUniform(t2, e2, r2) {
            t2.set(r2.constantOr(this.value));
          }
          getBinding(t2, e2, r2) {
            return "color" === this.type ? new Sa2(t2, e2) : new _a2(t2, e2);
          }
        }
        class za2 {
          constructor(t2, e2) {
            this.uniformNames = e2.map((t3) => "u_".concat(t3)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t2, e2) {
            this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
          }
          setUniform(t2, e2, r2, n2) {
            const i2 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
            i2 && t2.set(i2);
          }
          getBinding(t2, e2, r2) {
            return "u_pattern" === r2.substr(0, 9) ? new Aa2(t2, e2) : new _a2(t2, e2);
          }
        }
        class Pa2 {
          constructor(t2, e2, r2, n2) {
            this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: "a_".concat(t3), type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
          }
          populatePaintArray(t2, e2, r2, n2, i2) {
            const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new Ui2(0), e2, {}, n2, [], i2);
            this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
          }
          updatePaintArray(t2, e2, r2, n2) {
            const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
            this._setPaintValue(t2, e2, i2);
          }
          _setPaintValue(t2, e2, r2) {
            if ("color" === this.type) {
              const n2 = Ma2(r2);
              for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, n2[0], n2[1]);
            } else {
              for (let n2 = t2; n2 < e2; n2++) this.paintVertexArray.emplace(n2, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Ca2 {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.expression = t2, this.uniformNames = e2.map((t3) => "u_".concat(t3, "_t")), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: "a_".concat(t3), type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
          }
          populatePaintArray(t2, e2, r2, n2, i2) {
            const s2 = this.expression.evaluate(new Ui2(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new Ui2(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
          }
          updatePaintArray(t2, e2, r2, n2) {
            const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
            this._setPaintValue(t2, e2, i2, s2);
          }
          _setPaintValue(t2, e2, r2, n2) {
            if ("color" === this.type) {
              const i2 = Ma2(r2), s2 = Ma2(n2);
              for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
            } else {
              for (let i2 = t2; i2 < e2; i2++) this.paintVertexArray.emplace(i2, r2, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t2, e2) {
            const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = y2(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
            t2.set(n2);
          }
          getBinding(t2, e2, r2) {
            return new _a2(t2, e2);
          }
        }
        class Ba2 {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
          }
          populatePaintArray(t2, e2, r2) {
            const n2 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
          }
          updatePaintArray(t2, e2, r2, n2, i2) {
            this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
          }
          _setPaintValues(t2, e2, r2, n2) {
            if (!n2 || !r2) return;
            const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l3 = n2[s2], u2 = n2[a2];
            if (o2 && l3 && u2) for (let r3 = t2; r3 < e2; r3++) this.zoomInPaintVertexArray.emplace(r3, l3.tl[0], l3.tl[1], l3.br[0], l3.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l3.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l3.tl[0], l3.tl[1], l3.br[0], l3.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l3.pixelRatio, u2.pixelRatio);
          }
          upload(t2) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, ua2.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, ua2.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Va2 {
          constructor(t2, e2, r2) {
            this.binders = {}, this._buffers = [];
            const n2 = [];
            for (const i2 in t2.paint._values) {
              if (!r2(i2)) continue;
              const s2 = t2.paint.get(i2);
              if (!(s2 instanceof Hi2 && an2(s2.property.specification))) continue;
              const a2 = Fa2(i2, t2.type), o2 = s2.value, l3 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = "cross-faded" === c2 || "cross-faded-data-driven" === c2;
              if ("constant" === o2.kind) this.binders[i2] = h2 ? new za2(o2.value, a2) : new Ia2(o2.value, a2, l3), n2.push("/u_".concat(i2));
              else if ("source" === o2.kind || h2) {
                const r3 = Ta2(i2, l3, "source");
                this.binders[i2] = h2 ? new Ba2(o2, l3, u2, e2, r3, t2.id) : new Pa2(o2, a2, l3, r3), n2.push("/a_".concat(i2));
              } else {
                const t3 = Ta2(i2, l3, "composite");
                this.binders[i2] = new Ca2(o2, a2, l3, u2, e2, t3), n2.push("/z_".concat(i2));
              }
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t2) {
            const e2 = this.binders[t2];
            return e2 instanceof Pa2 || e2 instanceof Ca2 ? e2.maxValue : 0;
          }
          populatePaintArrays(t2, e2, r2, n2, i2) {
            for (const s2 in this.binders) {
              const a2 = this.binders[s2];
              (a2 instanceof Pa2 || a2 instanceof Ca2 || a2 instanceof Ba2) && a2.populatePaintArray(t2, e2, r2, n2, i2);
            }
          }
          setConstantPatternPositions(t2, e2) {
            for (const r2 in this.binders) {
              const n2 = this.binders[r2];
              n2 instanceof za2 && n2.setConstantPatternPositions(t2, e2);
            }
          }
          updatePaintArrays(t2, e2, r2, n2, i2) {
            let s2 = false;
            for (const a2 in t2) {
              const o2 = e2.getPositions(a2);
              for (const e3 of o2) {
                const o3 = r2.feature(e3.index);
                for (const r3 in this.binders) {
                  const l3 = this.binders[r3];
                  if ((l3 instanceof Pa2 || l3 instanceof Ca2 || l3 instanceof Ba2) && true === l3.expression.isStateDependent) {
                    const u2 = n2.paint.get(r3);
                    l3.expression = u2.value, l3.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                  }
                }
              }
            }
            return s2;
          }
          defines() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof Ia2 || r2 instanceof za2) && t2.push(...r2.uniformNames.map((t3) => "#define HAS_UNIFORM_".concat(t3)));
            }
            return t2;
          }
          getBinderAttributes() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof Pa2 || r2 instanceof Ca2) for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++) t2.push(r2.paintVertexAttributes[e3].name);
              else if (r2 instanceof Ba2) for (let e3 = 0; e3 < ua2.members.length; e3++) t2.push(ua2.members[e3].name);
            }
            return t2;
          }
          getBinderUniforms() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof Ia2 || r2 instanceof za2 || r2 instanceof Ca2) for (const e3 of r2.uniformNames) t2.push(e3);
            }
            return t2;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t2, e2) {
            const r2 = [];
            for (const n2 in this.binders) {
              const i2 = this.binders[n2];
              if (i2 instanceof Ia2 || i2 instanceof za2 || i2 instanceof Ca2) {
                for (const s2 of i2.uniformNames) if (e2[s2]) {
                  const a2 = i2.getBinding(t2, e2[s2], s2);
                  r2.push({ name: s2, property: n2, binding: a2 });
                }
              }
            }
            return r2;
          }
          setUniforms(t2, e2, r2, n2) {
            for (const { name: t3, property: i2, binding: s2 } of e2) this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
          }
          updatePaintBuffers(t2) {
            this._buffers = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (t2 && r2 instanceof Ba2) {
                const e3 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                e3 && this._buffers.push(e3);
              } else (r2 instanceof Pa2 || r2 instanceof Ca2) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
            }
          }
          upload(t2) {
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof Pa2 || r2 instanceof Ca2 || r2 instanceof Ba2) && r2.upload(t2);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof Pa2 || e2 instanceof Ca2 || e2 instanceof Ba2) && e2.destroy();
            }
          }
        }
        class Ea2 {
          constructor(t2, e2, r2 = () => true) {
            this.programConfigurations = {};
            for (const n2 of t2) this.programConfigurations[n2.id] = new Va2(n2, e2, r2);
            this.needsUpload = false, this._featureMap = new ga2(), this._bufferOffset = 0;
          }
          populatePaintArrays(t2, e2, r2, n2, i2, s2) {
            for (const r3 in this.programConfigurations) this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2);
            void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
          }
          updatePaintArrays(t2, e2, r2, n2) {
            for (const i2 of r2) this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
          }
          get(t2) {
            return this.programConfigurations[t2];
          }
          upload(t2) {
            if (this.needsUpload) {
              for (const e2 in this.programConfigurations) this.programConfigurations[e2].upload(t2);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t2 in this.programConfigurations) this.programConfigurations[t2].destroy();
          }
        }
        function Fa2(t2, e2) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace("".concat(e2, "-"), "").replace(/-/g, "_")];
        }
        function Ta2(t2, e2, r2) {
          const n2 = { color: { source: ys2, composite: Vs2 }, number: { source: Is2, composite: ys2 } }, i2 = function(t3) {
            return { "line-pattern": { source: Js2, composite: Js2 }, "fill-pattern": { source: Js2, composite: Js2 }, "fill-extrusion-pattern": { source: Js2, composite: Js2 } }[t3];
          }(t2);
          return i2 && i2[r2] || n2[e2][r2];
        }
        wi2("ConstantBinder", Ia2), wi2("CrossFadedConstantBinder", za2), wi2("SourceExpressionBinder", Pa2), wi2("CrossFadedCompositeBinder", Ba2), wi2("CompositeExpressionBinder", Ca2), wi2("ProgramConfiguration", Va2, { omit: ["_buffers"] }), wi2("ProgramConfigurationSet", Ea2);
        const $a2 = 8192, La2 = Math.pow(2, 14) - 1, Da2 = -La2 - 1;
        function Oa2(t2) {
          const e2 = $a2 / t2.extent, r2 = t2.loadGeometry();
          for (let t3 = 0; t3 < r2.length; t3++) {
            const n2 = r2[t3];
            for (let t4 = 0; t4 < n2.length; t4++) {
              const r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
              r3.x = y2(i2, Da2, La2), r3.y = y2(s2, Da2, La2), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && A2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r2;
        }
        function ja2(t2, e2) {
          return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Oa2(t2) : [] };
        }
        function Ra2(t2, e2, r2, n2, i2) {
          t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
        }
        class Ua2 {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Gs2(), this.indexArray = new na2(), this.segments = new oa2(), this.programConfigurations = new Ea2(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            const n2 = this.layers[0], i2 = [];
            let s2 = null, a2 = false;
            "circle" === n2.type && (s2 = n2.layout.get("circle-sort-key"), a2 = !s2.isConstant());
            for (const { feature: e3, id: n3, index: o2, sourceLayerIndex: l3 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = ja2(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new Ui2(this.zoom), u2, r2)) continue;
              const c2 = a2 ? s2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o2, geometry: t3 ? u2.geometry : Oa2(e3), patterns: {}, sortKey: c2 };
              i2.push(h2);
            }
            a2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n3 of i2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o2 = t2[s3].feature;
              this.addFeature(n3, i3, s3, r2), e2.featureIndex.insert(o2, i3, s3, a3, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, aa2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e2, r2, n2) {
            for (const r3 of e2) for (const e3 of r3) {
              const r4 = e3.x, n3 = e3.y;
              if (r4 < 0 || r4 >= $a2 || n3 < 0 || n3 >= $a2) continue;
              const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), s2 = i2.vertexLength;
              Ra2(this.layoutVertexArray, r4, n3, -1, -1), Ra2(this.layoutVertexArray, r4, n3, 1, -1), Ra2(this.layoutVertexArray, r4, n3, 1, 1), Ra2(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(s2, s2 + 1, s2 + 2), this.indexArray.emplaceBack(s2, s2 + 3, s2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
          }
        }
        function qa2(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) if (Wa2(e2, t2[r2])) return true;
          for (let r2 = 0; r2 < e2.length; r2++) if (Wa2(t2, e2[r2])) return true;
          return !!Ka2(t2, e2);
        }
        function Na2(t2, e2, r2) {
          return !!Wa2(t2, e2) || !!Ha2(e2, t2, r2);
        }
        function Za2(t2, e2) {
          if (1 === t2.length) return Ja2(e2, t2[0]);
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n2 = e2[r2];
            for (let e3 = 0; e3 < n2.length; e3++) if (Wa2(t2, n2[e3])) return true;
          }
          for (let r2 = 0; r2 < t2.length; r2++) if (Ja2(e2, t2[r2])) return true;
          for (let r2 = 0; r2 < e2.length; r2++) if (Ka2(t2, e2[r2])) return true;
          return false;
        }
        function Ga2(t2, e2, r2) {
          if (t2.length > 1) {
            if (Ka2(t2, e2)) return true;
            for (let n2 = 0; n2 < e2.length; n2++) if (Ha2(e2[n2], t2, r2)) return true;
          }
          for (let n2 = 0; n2 < t2.length; n2++) if (Ha2(t2[n2], e2, r2)) return true;
          return false;
        }
        function Ka2(t2, e2) {
          if (0 === t2.length || 0 === e2.length) return false;
          for (let r2 = 0; r2 < t2.length - 1; r2++) {
            const n2 = t2[r2], i2 = t2[r2 + 1];
            for (let t3 = 0; t3 < e2.length - 1; t3++) if (Xa2(n2, i2, e2[t3], e2[t3 + 1])) return true;
          }
          return false;
        }
        function Xa2(t2, e2, r2, n2) {
          return S(t2, r2, n2) !== S(e2, r2, n2) && S(t2, e2, r2) !== S(t2, e2, n2);
        }
        function Ha2(t2, e2, r2) {
          const n2 = r2 * r2;
          if (1 === e2.length) return t2.distSqr(e2[0]) < n2;
          for (let r3 = 1; r3 < e2.length; r3++) if (Ya2(t2, e2[r3 - 1], e2[r3]) < n2) return true;
          return false;
        }
        function Ya2(t2, e2, r2) {
          const n2 = e2.distSqr(r2);
          if (0 === n2) return t2.distSqr(e2);
          const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
          return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
        }
        function Ja2(t2, e2) {
          let r2, n2, i2, s2 = false;
          for (let a2 = 0; a2 < t2.length; a2++) {
            r2 = t2[a2];
            for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++) n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
          }
          return s2;
        }
        function Wa2(t2, e2) {
          let r2 = false;
          for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
            const s2 = t2[n2], a2 = t2[i2];
            s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
          }
          return r2;
        }
        function Qa2(t2, e2, r2) {
          const n2 = r2[0], i2 = r2[2];
          if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y) return false;
          const s2 = S(t2, e2, r2[0]);
          return s2 !== S(t2, e2, r2[1]) || s2 !== S(t2, e2, r2[2]) || s2 !== S(t2, e2, r2[3]);
        }
        function to2(t2, e2, r2) {
          const n2 = e2.paint.get(t2).value;
          return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
        }
        function eo2(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function ro2(t2, e2, r2, n2, i2) {
          if (!e2[0] && !e2[1]) return t2;
          const a2 = s.convert(e2)._mult(i2);
          "viewport" === r2 && a2._rotate(-n2);
          const o2 = [];
          for (let e3 = 0; e3 < t2.length; e3++) o2.push(t2[e3].sub(a2));
          return o2;
        }
        let no2, io2;
        wi2("CircleBucket", Ua2, { omit: ["layers"] });
        var so2 = { get paint() {
          return io2 = io2 || new rs2({ "circle-radius": new Wi2(G.paint_circle["circle-radius"]), "circle-color": new Wi2(G.paint_circle["circle-color"]), "circle-blur": new Wi2(G.paint_circle["circle-blur"]), "circle-opacity": new Wi2(G.paint_circle["circle-opacity"]), "circle-translate": new Ji2(G.paint_circle["circle-translate"]), "circle-translate-anchor": new Ji2(G.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ji2(G.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ji2(G.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Wi2(G.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Wi2(G.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Wi2(G.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return no2 = no2 || new rs2({ "circle-sort-key": new Wi2(G.layout_circle["circle-sort-key"]) });
        } }, ao2 = 1e-6, oo2 = "undefined" != typeof Float32Array ? Float32Array : Array;
        function lo2(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function uo2(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y3 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
          return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y3, t2[1] = v2 * i2 + b2 * l3 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y3, t2[5] = v2 * i2 + b2 * l3 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y3, t2[9] = v2 * i2 + b2 * l3 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y3, t2[13] = v2 * i2 + b2 * l3 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t2 = 0, e2 = arguments.length; e2--; ) t2 += arguments[e2] * arguments[e2];
          return Math.sqrt(t2);
        });
        var co2, ho2 = uo2;
        function po2(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
        }
        co2 = new oo2(4), oo2 != Float32Array && (co2[0] = 0, co2[1] = 0, co2[2] = 0, co2[3] = 0);
        class fo2 extends is2 {
          constructor(t2) {
            super(t2, so2);
          }
          createBucket(t2) {
            return new Ua2(t2);
          }
          queryRadius(t2) {
            const e2 = t2;
            return to2("circle-radius", this, e2) + to2("circle-stroke-width", this, e2) + eo2(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l3 = ro2(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, a2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = "map" === this.paint.get("circle-pitch-alignment"), h2 = c2 ? l3 : function(t3, e3) {
              return t3.map((t4) => yo2(t4, e3));
            }(l3, o2), p2 = c2 ? u2 * a2 : u2;
            for (const t3 of n2) for (const e3 of t3) {
              const t4 = c2 ? e3 : yo2(e3, o2);
              let r3 = p2;
              const n3 = po2([], [e3.x, e3.y, 0, 1], o2);
              if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r3 *= n3[3] / s2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r3 *= s2.cameraToCenterDistance / n3[3]), Na2(h2, t4, r3)) return true;
            }
            return false;
          }
        }
        function yo2(t2, e2) {
          const r2 = po2([], [t2.x, t2.y, 0, 1], e2);
          return new s(r2[0] / r2[3], r2[1] / r2[3]);
        }
        class mo2 extends Ua2 {
        }
        let go2;
        wi2("HeatmapBucket", mo2, { omit: ["layers"] });
        var xo2 = { get paint() {
          return go2 = go2 || new rs2({ "heatmap-radius": new Wi2(G.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Wi2(G.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ji2(G.paint_heatmap["heatmap-intensity"]), "heatmap-color": new es2(G.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ji2(G.paint_heatmap["heatmap-opacity"]) });
        } };
        function vo2(t2, { width: e2, height: r2 }, n2, i2) {
          if (i2) {
            if (i2 instanceof Uint8ClampedArray) i2 = new Uint8Array(i2.buffer);
            else if (i2.length !== e2 * r2 * n2) throw new RangeError("mismatched image size. expected: ".concat(i2.length, " but got: ").concat(e2 * r2 * n2));
          } else i2 = new Uint8Array(e2 * r2 * n2);
          return t2.width = e2, t2.height = r2, t2.data = i2, t2;
        }
        function bo2(t2, { width: e2, height: r2 }, n2) {
          if (e2 === t2.width && r2 === t2.height) return;
          const i2 = vo2({}, { width: e2, height: r2 }, n2);
          wo2(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
        }
        function wo2(t2, e2, r2, n2, i2, s2) {
          if (0 === i2.width || 0 === i2.height) return e2;
          if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height) throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height) throw new RangeError("out of range destination coordinates for image copy");
          const a2 = t2.data, o2 = e2.data;
          if (a2 === o2) throw new Error("srcData equals dstData, so image is already copied");
          for (let l3 = 0; l3 < i2.height; l3++) {
            const u2 = ((r2.y + l3) * t2.width + r2.x) * s2, c2 = ((n2.y + l3) * e2.width + n2.x) * s2;
            for (let t3 = 0; t3 < i2.width * s2; t3++) o2[c2 + t3] = a2[u2 + t3];
          }
          return e2;
        }
        class _o2 {
          constructor(t2, e2) {
            vo2(this, t2, 1, e2);
          }
          resize(t2) {
            bo2(this, t2, 1);
          }
          clone() {
            return new _o2({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            wo2(t2, e2, r2, n2, i2, 1);
          }
        }
        class Ao2 {
          constructor(t2, e2) {
            vo2(this, t2, 4, e2);
          }
          resize(t2) {
            bo2(this, t2, 4);
          }
          replace(t2, e2) {
            e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }
          clone() {
            return new Ao2({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            wo2(t2, e2, r2, n2, i2, 4);
          }
        }
        function So2(t2) {
          const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Ao2({ width: r2, height: n2 });
          if (Math.log(r2) / Math.LN2 % 1 != 0) throw new Error("width is not a power of 2 - ".concat(r2));
          const s2 = (r3, n3, s3) => {
            e2[t2.evaluationKey] = s3;
            const a2 = t2.expression.evaluate(e2);
            i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
          };
          if (t2.clips) for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2) for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
            const o2 = n3 / (r2 - 1), { start: l3, end: u2 } = t2.clips[e3];
            s2(i3, a2, l3 * (1 - o2) + u2 * o2);
          }
          else for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4) s2(0, e3, t3 / (r2 - 1));
          return i2;
        }
        wi2("AlphaImage", _o2), wi2("RGBAImage", Ao2);
        const ko2 = "big-fb";
        class Mo2 extends is2 {
          createBucket(t2) {
            return new mo2(t2);
          }
          constructor(t2) {
            super(t2, xo2), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "heatmap-color" === t2 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = So2({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(ko2) && this.heatmapFbos.delete(ko2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
        }
        let Io2;
        var zo2 = { get paint() {
          return Io2 = Io2 || new rs2({ "hillshade-illumination-direction": new Ji2(G.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ji2(G.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ji2(G.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ji2(G.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ji2(G.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ji2(G.paint_hillshade["hillshade-accent-color"]) });
        } };
        class Po2 extends is2 {
          constructor(t2) {
            super(t2, zo2);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
        }
        const Co2 = ls2([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Bo2 } = Co2;
        function Vo2(t2, e2, r2 = 2) {
          const n2 = e2 && e2.length, i2 = n2 ? e2[0] * r2 : t2.length;
          let s2 = Eo2(t2, 0, i2, r2, true);
          const a2 = [];
          if (!s2 || s2.next === s2.prev) return a2;
          let o2, l3, u2;
          if (n2 && (s2 = function(t3, e3, r3, n3) {
            const i3 = [];
            for (let r4 = 0, s3 = e3.length; r4 < s3; r4++) {
              const a3 = Eo2(t3, e3[r4] * n3, r4 < s3 - 1 ? e3[r4 + 1] * n3 : t3.length, n3, false);
              a3 === a3.next && (a3.steiner = true), i3.push(No2(a3));
            }
            i3.sort(jo2);
            for (let t4 = 0; t4 < i3.length; t4++) r3 = Ro2(i3[t4], r3);
            return r3;
          }(t2, e2, s2, r2)), t2.length > 80 * r2) {
            o2 = 1 / 0, l3 = 1 / 0;
            let e3 = -1 / 0, n3 = -1 / 0;
            for (let s3 = r2; s3 < i2; s3 += r2) {
              const r3 = t2[s3], i3 = t2[s3 + 1];
              r3 < o2 && (o2 = r3), i3 < l3 && (l3 = i3), r3 > e3 && (e3 = r3), i3 > n3 && (n3 = i3);
            }
            u2 = Math.max(e3 - o2, n3 - l3), u2 = 0 !== u2 ? 32767 / u2 : 0;
          }
          return To2(s2, a2, r2, o2, l3, u2, 0), a2;
        }
        function Eo2(t2, e2, r2, n2, i2) {
          let s2;
          if (i2 === function(t3, e3, r3, n3) {
            let i3 = 0;
            for (let s3 = e3, a2 = r3 - n3; s3 < r3; s3 += n3) i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
            return i3;
          }(t2, e2, r2, n2) > 0) for (let i3 = e2; i3 < r2; i3 += n2) s2 = tl2(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
          else for (let i3 = r2 - n2; i3 >= e2; i3 -= n2) s2 = tl2(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
          return s2 && Xo2(s2, s2.next) && (el2(s2), s2 = s2.next), s2;
        }
        function Fo2(t2, e2) {
          if (!t2) return t2;
          e2 || (e2 = t2);
          let r2, n2 = t2;
          do {
            if (r2 = false, n2.steiner || !Xo2(n2, n2.next) && 0 !== Ko2(n2.prev, n2, n2.next)) n2 = n2.next;
            else {
              if (el2(n2), n2 = e2 = n2.prev, n2 === n2.next) break;
              r2 = true;
            }
          } while (r2 || n2 !== e2);
          return e2;
        }
        function To2(t2, e2, r2, n2, i2, s2, a2) {
          if (!t2) return;
          !a2 && s2 && function(t3, e3, r3, n3) {
            let i3 = t3;
            do {
              0 === i3.z && (i3.z = qo2(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
            } while (i3 !== t3);
            i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
              let e4, r4 = 1;
              do {
                let n4, i4 = t4;
                t4 = null;
                let s3 = null;
                for (e4 = 0; i4; ) {
                  e4++;
                  let a3 = i4, o3 = 0;
                  for (let t5 = 0; t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++) ;
                  let l3 = r4;
                  for (; o3 > 0 || l3 > 0 && a3; ) 0 !== o3 && (0 === l3 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l3--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                  i4 = a3;
                }
                s3.nextZ = null, r4 *= 2;
              } while (e4 > 1);
            }(i3);
          }(t2, n2, i2, s2);
          let o2 = t2;
          for (; t2.prev !== t2.next; ) {
            const l3 = t2.prev, u2 = t2.next;
            if (s2 ? Lo2(t2, n2, i2, s2) : $o2(t2)) e2.push(l3.i, t2.i, u2.i), el2(t2), t2 = u2.next, o2 = u2.next;
            else if ((t2 = u2) === o2) {
              a2 ? 1 === a2 ? To2(t2 = Do2(Fo2(t2), e2), e2, r2, n2, i2, s2, 2) : 2 === a2 && Oo2(t2, e2, r2, n2, i2, s2) : To2(Fo2(t2), e2, r2, n2, i2, s2, 1);
              break;
            }
          }
        }
        function $o2(t2) {
          const e2 = t2.prev, r2 = t2, n2 = t2.next;
          if (Ko2(e2, r2, n2) >= 0) return false;
          const i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l3 = r2.y, u2 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h2 = o2 < l3 ? o2 < u2 ? o2 : u2 : l3 < u2 ? l3 : u2, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l3 ? o2 > u2 ? o2 : u2 : l3 > u2 ? l3 : u2;
          let d2 = n2.next;
          for (; d2 !== e2; ) {
            if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && Zo2(i2, o2, s2, l3, a2, u2, d2.x, d2.y) && Ko2(d2.prev, d2, d2.next) >= 0) return false;
            d2 = d2.next;
          }
          return true;
        }
        function Lo2(t2, e2, r2, n2) {
          const i2 = t2.prev, s2 = t2, a2 = t2.next;
          if (Ko2(i2, s2, a2) >= 0) return false;
          const o2 = i2.x, l3 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f2 = o2 < l3 ? o2 < u2 ? o2 : u2 : l3 < u2 ? l3 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y3 = o2 > l3 ? o2 > u2 ? o2 : u2 : l3 > u2 ? l3 : u2, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = qo2(f2, d2, e2, r2, n2), x2 = qo2(y3, m2, e2, r2, n2);
          let v2 = t2.prevZ, b2 = t2.nextZ;
          for (; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
            if (v2.x >= f2 && v2.x <= y3 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Zo2(o2, c2, l3, h2, u2, p2, v2.x, v2.y) && Ko2(v2.prev, v2, v2.next) >= 0) return false;
            if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y3 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Zo2(o2, c2, l3, h2, u2, p2, b2.x, b2.y) && Ko2(b2.prev, b2, b2.next) >= 0) return false;
            b2 = b2.nextZ;
          }
          for (; v2 && v2.z >= g2; ) {
            if (v2.x >= f2 && v2.x <= y3 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Zo2(o2, c2, l3, h2, u2, p2, v2.x, v2.y) && Ko2(v2.prev, v2, v2.next) >= 0) return false;
            v2 = v2.prevZ;
          }
          for (; b2 && b2.z <= x2; ) {
            if (b2.x >= f2 && b2.x <= y3 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Zo2(o2, c2, l3, h2, u2, p2, b2.x, b2.y) && Ko2(b2.prev, b2, b2.next) >= 0) return false;
            b2 = b2.nextZ;
          }
          return true;
        }
        function Do2(t2, e2) {
          let r2 = t2;
          do {
            const n2 = r2.prev, i2 = r2.next.next;
            !Xo2(n2, i2) && Ho2(n2, r2, r2.next, i2) && Wo2(n2, i2) && Wo2(i2, n2) && (e2.push(n2.i, r2.i, i2.i), el2(r2), el2(r2.next), r2 = t2 = i2), r2 = r2.next;
          } while (r2 !== t2);
          return Fo2(r2);
        }
        function Oo2(t2, e2, r2, n2, i2, s2) {
          let a2 = t2;
          do {
            let t3 = a2.next.next;
            for (; t3 !== a2.prev; ) {
              if (a2.i !== t3.i && Go2(a2, t3)) {
                let o2 = Qo2(a2, t3);
                return a2 = Fo2(a2, a2.next), o2 = Fo2(o2, o2.next), To2(a2, e2, r2, n2, i2, s2, 0), void To2(o2, e2, r2, n2, i2, s2, 0);
              }
              t3 = t3.next;
            }
            a2 = a2.next;
          } while (a2 !== t2);
        }
        function jo2(t2, e2) {
          return t2.x - e2.x;
        }
        function Ro2(t2, e2) {
          const r2 = function(t3, e3) {
            let r3 = e3;
            const n3 = t3.x, i2 = t3.y;
            let s2, a2 = -1 / 0;
            do {
              if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
                const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
                if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3)) return s2;
              }
              r3 = r3.next;
            } while (r3 !== e3);
            if (!s2) return null;
            const o2 = s2, l3 = s2.x, u2 = s2.y;
            let c2 = 1 / 0;
            r3 = s2;
            do {
              if (n3 >= r3.x && r3.x >= l3 && n3 !== r3.x && Zo2(i2 < u2 ? n3 : a2, i2, l3, u2, i2 < u2 ? a2 : n3, i2, r3.x, r3.y)) {
                const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
                Wo2(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && Uo2(s2, r3))) && (s2 = r3, c2 = e4);
              }
              r3 = r3.next;
            } while (r3 !== o2);
            return s2;
          }(t2, e2);
          if (!r2) return e2;
          const n2 = Qo2(r2, t2);
          return Fo2(n2, n2.next), Fo2(r2, r2.next);
        }
        function Uo2(t2, e2) {
          return Ko2(t2.prev, t2, e2.prev) < 0 && Ko2(e2.next, t2, t2.next) < 0;
        }
        function qo2(t2, e2, r2, n2, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function No2(t2) {
          let e2 = t2, r2 = t2;
          do {
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          } while (e2 !== t2);
          return r2;
        }
        function Zo2(t2, e2, r2, n2, i2, s2, a2, o2) {
          return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
        }
        function Go2(t2, e2) {
          return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
            let r2 = t3;
            do {
              if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Ho2(r2, r2.next, t3, e3)) return true;
              r2 = r2.next;
            } while (r2 !== t3);
            return false;
          }(t2, e2) && (Wo2(t2, e2) && Wo2(e2, t2) && function(t3, e3) {
            let r2 = t3, n2 = false;
            const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
            do {
              r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            } while (r2 !== t3);
            return n2;
          }(t2, e2) && (Ko2(t2.prev, t2, e2.prev) || Ko2(t2, e2.prev, e2)) || Xo2(t2, e2) && Ko2(t2.prev, t2, t2.next) > 0 && Ko2(e2.prev, e2, e2.next) > 0);
        }
        function Ko2(t2, e2, r2) {
          return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
        }
        function Xo2(t2, e2) {
          return t2.x === e2.x && t2.y === e2.y;
        }
        function Ho2(t2, e2, r2, n2) {
          const i2 = Jo2(Ko2(t2, e2, r2)), s2 = Jo2(Ko2(t2, e2, n2)), a2 = Jo2(Ko2(r2, n2, t2)), o2 = Jo2(Ko2(r2, n2, e2));
          return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !Yo2(t2, r2, e2)) || !(0 !== s2 || !Yo2(t2, n2, e2)) || !(0 !== a2 || !Yo2(r2, t2, n2)) || !(0 !== o2 || !Yo2(r2, e2, n2));
        }
        function Yo2(t2, e2, r2) {
          return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
        }
        function Jo2(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function Wo2(t2, e2) {
          return Ko2(t2.prev, t2, t2.next) < 0 ? Ko2(t2, e2, t2.next) >= 0 && Ko2(t2, t2.prev, e2) >= 0 : Ko2(t2, e2, t2.prev) < 0 || Ko2(t2, t2.next, e2) < 0;
        }
        function Qo2(t2, e2) {
          const r2 = rl2(t2.i, t2.x, t2.y), n2 = rl2(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
          return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
        }
        function tl2(t2, e2, r2, n2) {
          const i2 = rl2(t2, e2, r2);
          return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function el2(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function rl2(t2, e2, r2) {
          return { i: t2, x: e2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        function nl2(t2, e2, r2) {
          const n2 = r2.patternDependencies;
          let i2 = false;
          for (const r3 of e2) {
            const e3 = r3.paint.get("".concat(t2, "-pattern"));
            e3.isConstant() || (i2 = true);
            const s2 = e3.constantOr(null);
            s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
          }
          return i2;
        }
        function il2(t2, e2, r2, n2, i2) {
          const s2 = i2.patternDependencies;
          for (const a2 of e2) {
            const e3 = a2.paint.get("".concat(t2, "-pattern")).value;
            if ("constant" !== e3.kind) {
              let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l3 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
              t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l3 = l3 && l3.name ? l3.name : l3, s2[t3] = true, s2[o2] = true, s2[l3] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l3 };
            }
          }
          return r2;
        }
        class sl2 {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ks2(), this.indexArray = new na2(), this.indexArray2 = new ia2(), this.programConfigurations = new Ea2(t2.layers, t2.zoom), this.segments = new oa2(), this.segments2 = new oa2(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.hasPattern = nl2("fill", this.layers, e2);
            const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
            for (const { feature: a2, id: o2, index: l3, sourceLayerIndex: u2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c2 = ja2(a2, t3);
              if (!this.layers[0]._featureFilter.filter(new Ui2(this.zoom), c2, r2)) continue;
              const h2 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l3, geometry: t3 ? c2.geometry : Oa2(a2), patterns: {}, sortKey: h2 };
              s2.push(p2);
            }
            i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t3 = il2("fill", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else this.addFeature(n3, i3, s3, r2, {});
              e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          addFeatures(t2, e2, r2) {
            for (const t3 of this.patternFeatures) this.addFeature(t3, t3.geometry, t3.index, e2, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Bo2), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t2, e2, r2, n2, i2) {
            for (const t3 of xr2(e2, 500)) {
              let e3 = 0;
              for (const r4 of t3) e3 += r4.length;
              const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s2 = [];
              for (const e4 of t3) {
                if (0 === e4.length) continue;
                e4 !== t3[0] && s2.push(i3.length / 2);
                const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
                for (let t4 = 1; t4 < e4.length; t4++) this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
              }
              const a2 = Vo2(i3, s2);
              for (let t4 = 0; t4 < a2.length; t4 += 3) this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
              r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
        }
        let al2, ol2;
        wi2("FillBucket", sl2, { omit: ["layers", "patternFeatures"] });
        var ll2 = { get paint() {
          return ol2 = ol2 || new rs2({ "fill-antialias": new Ji2(G.paint_fill["fill-antialias"]), "fill-opacity": new Wi2(G.paint_fill["fill-opacity"]), "fill-color": new Wi2(G.paint_fill["fill-color"]), "fill-outline-color": new Wi2(G.paint_fill["fill-outline-color"]), "fill-translate": new Ji2(G.paint_fill["fill-translate"]), "fill-translate-anchor": new Ji2(G.paint_fill["fill-translate-anchor"]), "fill-pattern": new Qi2(G.paint_fill["fill-pattern"]) });
        }, get layout() {
          return al2 = al2 || new rs2({ "fill-sort-key": new Wi2(G.layout_fill["fill-sort-key"]) });
        } };
        class ul2 extends is2 {
          constructor(t2) {
            super(t2, ll2);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2);
            const r2 = this.paint._values["fill-outline-color"];
            "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t2) {
            return new sl2(t2);
          }
          queryRadius() {
            return eo2(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2) {
            return Za2(ro2(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, a2), n2);
          }
          isTileClipped() {
            return true;
          }
        }
        const cl2 = ls2([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), hl2 = ls2([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: pl2 } = cl2;
        var fl2 = {}, dl2 = n, yl2 = ml2;
        function ml2(t2, e2, r2, n2, i2) {
          this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(gl2, this, e2);
        }
        function gl2(t2, e2, r2) {
          1 == t2 ? e2.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
            for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
              e3.properties[n2] = i2;
            }
          }(r2, e2) : 3 == t2 ? e2.type = r2.readVarint() : 4 == t2 && (e2._geometry = r2.pos);
        }
        function xl2(t2) {
          for (var e2, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) n2 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
          return n2;
        }
        ml2.types = ["Unknown", "Point", "LineString", "Polygon"], ml2.prototype.loadGeometry = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = []; t2.pos < r2; ) {
            if (i2 <= 0) {
              var l3 = t2.readVarint();
              n2 = 7 & l3, i2 = l3 >> 3;
            }
            if (i2--, 1 === n2 || 2 === n2) s2 += t2.readSVarint(), a2 += t2.readSVarint(), 1 === n2 && (e2 && o2.push(e2), e2 = []), e2.push(new dl2(s2, a2));
            else {
              if (7 !== n2) throw new Error("unknown command " + n2);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && o2.push(e2), o2;
        }, ml2.prototype.bbox = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l3 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
            if (n2 <= 0) {
              var c2 = t2.readVarint();
              r2 = 7 & c2, n2 = c2 >> 3;
            }
            if (n2--, 1 === r2 || 2 === r2) (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l3 && (l3 = s2), s2 > u2 && (u2 = s2);
            else if (7 !== r2) throw new Error("unknown command " + r2);
          }
          return [a2, l3, o2, u2];
        }, ml2.prototype.toGeoJSON = function(t2, e2, r2) {
          var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l3 = this.loadGeometry(), u2 = ml2.types[this.type];
          function c2(t3) {
            for (var e3 = 0; e3 < t3.length; e3++) {
              var r3 = t3[e3];
              t3[e3] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h2 = [];
              for (n2 = 0; n2 < l3.length; n2++) h2[n2] = l3[n2][0];
              c2(l3 = h2);
              break;
            case 2:
              for (n2 = 0; n2 < l3.length; n2++) c2(l3[n2]);
              break;
            case 3:
              for (l3 = function(t3) {
                var e3 = t3.length;
                if (e3 <= 1) return [t3];
                for (var r3, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                  var a3 = xl2(t3[s3]);
                  0 !== a3 && (void 0 === n3 && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
                }
                return r3 && i3.push(r3), i3;
              }(l3), n2 = 0; n2 < l3.length; n2++) for (i2 = 0; i2 < l3[n2].length; i2++) c2(l3[n2][i2]);
          }
          1 === l3.length ? l3 = l3[0] : u2 = "Multi" + u2;
          var p2 = { type: "Feature", geometry: { type: u2, coordinates: l3 }, properties: this.properties };
          return "id" in this && (p2.id = this.id), p2;
        };
        var vl2 = yl2, bl2 = wl;
        function wl(t2, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(_l, this, e2), this.length = this._features.length;
        }
        function _l(t2, e2, r2) {
          15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
            for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n2 = t3.readVarint() >> 3;
              e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
            }
            return e3;
          }(r2));
        }
        wl.prototype.feature = function(t2) {
          if (t2 < 0 || t2 >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t2];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new vl2(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var Al = bl2;
        function Sl(t2, e2, r2) {
          if (3 === t2) {
            var n2 = new Al(r2, r2.readVarint() + r2.pos);
            n2.length && (e2[n2.name] = n2);
          }
        }
        fl2.VectorTile = function(t2, e2) {
          this.layers = t2.readFields(Sl, {}, e2);
        }, fl2.VectorTileFeature = yl2, fl2.VectorTileLayer = bl2;
        const kl = fl2.VectorTileFeature.types, Ml = Math.pow(2, 13);
        function Il(t2, e2, r2, n2, i2, s2, a2, o2) {
          t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * Ml) + a2, i2 * Ml * 2, s2 * Ml * 2, Math.round(o2));
        }
        class zl {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Xs2(), this.centroidVertexArray = new Zs2(), this.indexArray = new na2(), this.programConfigurations = new Ea2(t2.layers, t2.zoom), this.segments = new oa2(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.features = [], this.hasPattern = nl2("fill-extrusion", this.layers, e2);
            for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, o2 = ja2(n2, t3);
              if (!this.layers[0]._featureFilter.filter(new Ui2(this.zoom), o2, r2)) continue;
              const l3 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : Oa2(n2), properties: n2.properties, type: n2.type, patterns: {} };
              this.hasPattern ? this.features.push(il2("fill-extrusion", this.layers, l3, this.zoom, e2)) : this.addFeature(l3, l3.geometry, s2, r2, {}), e2.featureIndex.insert(n2, l3.geometry, s2, a2, this.index, true);
            }
          }
          addFeatures(t2, e2, r2) {
            for (const t3 of this.features) {
              const { geometry: n2 } = t3;
              this.addFeature(t3, n2, t3.index, e2, r2);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, pl2), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, hl2.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t2, e2, r2, n2, i2) {
            for (const r3 of xr2(e2, 500)) {
              const e3 = { x: 0, y: 0, vertexCount: 0 };
              let n3 = 0;
              for (const t3 of r3) n3 += t3.length;
              let i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              for (const t3 of r3) {
                if (0 === t3.length) continue;
                if (Cl(t3)) continue;
                let r4 = 0;
                for (let n4 = 0; n4 < t3.length; n4++) {
                  const s3 = t3[n4];
                  if (n4 >= 1) {
                    const a3 = t3[n4 - 1];
                    if (!Pl(s3, a3)) {
                      i3.vertexLength + 4 > oa2.MAX_VERTEX_ARRAY_LENGTH && (i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      const t4 = s3.sub(a3)._perp()._unit(), n5 = a3.dist(s3);
                      r4 + n5 > 32768 && (r4 = 0), Il(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 0, r4), Il(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 1, r4), e3.x += 2 * s3.x, e3.y += 2 * s3.y, e3.vertexCount += 2, r4 += n5, Il(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 0, r4), Il(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 1, r4), e3.x += 2 * a3.x, e3.y += 2 * a3.y, e3.vertexCount += 2;
                      const o3 = i3.vertexLength;
                      this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), i3.vertexLength += 4, i3.primitiveLength += 2;
                    }
                  }
                }
              }
              if (i3.vertexLength + n3 > oa2.MAX_VERTEX_ARRAY_LENGTH && (i3 = this.segments.prepareSegment(n3, this.layoutVertexArray, this.indexArray)), "Polygon" !== kl[t2.type]) continue;
              const s2 = [], a2 = [], o2 = i3.vertexLength;
              for (const t3 of r3) if (0 !== t3.length) {
                t3 !== r3[0] && a2.push(s2.length / 2);
                for (let r4 = 0; r4 < t3.length; r4++) {
                  const n4 = t3[r4];
                  Il(this.layoutVertexArray, n4.x, n4.y, 0, 0, 1, 1, 0), e3.x += n4.x, e3.y += n4.y, e3.vertexCount += 1, s2.push(n4.x), s2.push(n4.y);
                }
              }
              const l3 = Vo2(s2, a2);
              for (let t3 = 0; t3 < l3.length; t3 += 3) this.indexArray.emplaceBack(o2 + l3[t3], o2 + l3[t3 + 2], o2 + l3[t3 + 1]);
              i3.primitiveLength += l3.length / 3, i3.vertexLength += n3;
              for (let t3 = 0; t3 < e3.vertexCount; t3++) {
                const t4 = Math.floor(e3.x / e3.vertexCount), r4 = Math.floor(e3.y / e3.vertexCount);
                this.centroidVertexArray.emplaceBack(t4, r4);
              }
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
        }
        function Pl(t2, e2) {
          return t2.x === e2.x && (t2.x < 0 || t2.x > $a2) || t2.y === e2.y && (t2.y < 0 || t2.y > $a2);
        }
        function Cl(t2) {
          return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > $a2) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > $a2);
        }
        let Bl;
        wi2("FillExtrusionBucket", zl, { omit: ["layers", "features"] });
        var Vl = { get paint() {
          return Bl = Bl || new rs2({ "fill-extrusion-opacity": new Ji2(G["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Wi2(G["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ji2(G["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ji2(G["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Qi2(G["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Wi2(G["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Wi2(G["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ji2(G["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class El extends is2 {
          constructor(t2) {
            super(t2, Vl);
          }
          createBucket(t2) {
            return new zl(t2);
          }
          queryRadius() {
            return eo2(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, a2, o2, l3) {
            const u2 = ro2(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, o2), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = function(t3, e3, r3, n3) {
              const i3 = [];
              for (const r4 of t3) {
                const t4 = [r4.x, r4.y, 0, 1];
                po2(t4, t4, e3), i3.push(new s(t4[0] / t4[3], t4[1] / t4[3]));
              }
              return i3;
            }(u2, l3), f2 = function(t3, e3, r3, n3) {
              const i3 = [], a3 = [], o3 = n3[8] * e3, l4 = n3[9] * e3, u3 = n3[10] * e3, c3 = n3[11] * e3, h3 = n3[8] * r3, p3 = n3[9] * r3, f3 = n3[10] * r3, d2 = n3[11] * r3;
              for (const e4 of t3) {
                const t4 = [], r4 = [];
                for (const i4 of e4) {
                  const e5 = i4.x, a4 = i4.y, y3 = n3[0] * e5 + n3[4] * a4 + n3[12], m2 = n3[1] * e5 + n3[5] * a4 + n3[13], g2 = n3[2] * e5 + n3[6] * a4 + n3[14], x2 = n3[3] * e5 + n3[7] * a4 + n3[15], v2 = g2 + u3, b2 = x2 + c3, w2 = y3 + h3, _2 = m2 + p3, A3 = g2 + f3, S2 = x2 + d2, k2 = new s((y3 + o3) / b2, (m2 + l4) / b2);
                  k2.z = v2 / b2, t4.push(k2);
                  const M3 = new s(w2 / S2, _2 / S2);
                  M3.z = A3 / S2, r4.push(M3);
                }
                i3.push(t4), a3.push(r4);
              }
              return [i3, a3];
            }(n2, h2, c2, l3);
            return function(t3, e3, r3) {
              let n3 = 1 / 0;
              Za2(r3, e3) && (n3 = Tl(r3, e3[0]));
              for (let i3 = 0; i3 < e3.length; i3++) {
                const s2 = e3[i3], a3 = t3[i3];
                for (let t4 = 0; t4 < s2.length - 1; t4++) {
                  const e4 = s2[t4], i4 = [e4, s2[t4 + 1], a3[t4 + 1], a3[t4], e4];
                  qa2(r3, i4) && (n3 = Math.min(n3, Tl(r3, i4)));
                }
              }
              return n3 !== 1 / 0 && n3;
            }(f2[0], f2[1], p2);
          }
        }
        function Fl(t2, e2) {
          return t2.x * e2.x + t2.y * e2.y;
        }
        function Tl(t2, e2) {
          if (1 === t2.length) {
            let r2 = 0;
            const n2 = e2[r2++];
            let i2;
            for (; !i2 || n2.equals(i2); ) if (i2 = e2[r2++], !i2) return 1 / 0;
            for (; r2 < e2.length; r2++) {
              const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l3 = s2.sub(n2), u2 = a2.sub(n2), c2 = Fl(o2, o2), h2 = Fl(o2, l3), p2 = Fl(l3, l3), f2 = Fl(u2, o2), d2 = Fl(u2, l3), y3 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y3, g2 = (c2 * d2 - h2 * f2) / y3, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
              if (isFinite(x2)) return x2;
            }
            return 1 / 0;
          }
          {
            let t3 = 1 / 0;
            for (const r2 of e2) t3 = Math.min(t3, r2.z);
            return t3;
          }
        }
        const $l = ls2([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Ll } = $l, Dl = ls2([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Ol } = Dl, jl = fl2.VectorTileFeature.types, Rl = Math.cos(Math.PI / 180 * 37.5), Ul = Math.pow(2, 14) / 0.5;
        class ql {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
              this.gradients[t3.id] = {};
            }), this.layoutVertexArray = new Hs2(), this.layoutVertexArray2 = new Ys2(), this.indexArray = new na2(), this.programConfigurations = new Ea2(t2.layers, t2.zoom), this.segments = new oa2(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.hasPattern = nl2("line", this.layers, e2);
            const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
            for (const { feature: e3, id: a2, index: o2, sourceLayerIndex: l3 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = ja2(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new Ui2(this.zoom), u2, r2)) continue;
              const c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: a2, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o2, geometry: t3 ? u2.geometry : Oa2(e3), patterns: {}, sortKey: c2 };
              s2.push(h2);
            }
            i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t3 = il2("line", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else this.addFeature(n3, i3, s3, r2, {});
              e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          addFeatures(t2, e2, r2) {
            for (const t3 of this.patternFeatures) this.addFeature(t3, t3.geometry, t3.index, e2, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Ol)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ll), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t2) {
            if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end")) return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
          }
          addFeature(t2, e2, r2, n2, i2) {
            const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(t2, {}), o2 = s2.get("line-cap"), l3 = s2.get("line-miter-limit"), u2 = s2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2);
            for (const r3 of e2) this.addLine(r3, t2, a2, o2, l3, u2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
          addLine(t2, e2, r2, n2, i2, s2) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e3 = 0; e3 < t2.length - 1; e3++) this.totalDistance += t2[e3].dist(t2[e3 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const a2 = "Polygon" === jl[e2.type];
            let o2 = t2.length;
            for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); ) o2--;
            let l3 = 0;
            for (; l3 < o2 - 1 && t2[l3].equals(t2[l3 + 1]); ) l3++;
            if (o2 < (a2 ? 3 : 2)) return;
            "bevel" === r2 && (i2 = 1.05);
            const u2 = this.overscaling <= 16 ? 15 * $a2 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
            let h2, p2, f2, d2, y3;
            this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y3 = t2[l3].sub(h2)._unit()._perp());
            for (let e3 = l3; e3 < o2; e3++) {
              if (f2 = e3 === o2 - 1 ? a2 ? t2[l3 + 1] : void 0 : t2[e3 + 1], f2 && t2[e3].equals(f2)) continue;
              y3 && (d2 = y3), h2 && (p2 = h2), h2 = t2[e3], y3 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y3;
              let m2 = d2.add(y3);
              0 === m2.x && 0 === m2.y || m2._unit();
              const g2 = d2.x * y3.x + d2.y * y3.y, x2 = m2.x * y3.x + m2.y * y3.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Rl && p2 && f2, _2 = d2.x * y3.y - d2.y * y3.x > 0;
              if (w2 && e3 > l3) {
                const t3 = h2.dist(p2);
                if (t3 > 2 * u2) {
                  const e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                  this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
                }
              }
              const A3 = p2 && f2;
              let S2 = A3 ? r2 : a2 ? "butt" : n2;
              if (A3 && "round" === S2 && (v2 < s2 ? S2 = "miter" : v2 <= 2 && (S2 = "fakeround")), "miter" === S2 && v2 > i2 && (S2 = "bevel"), "bevel" === S2 && (v2 > 2 && (S2 = "flipbevel"), v2 < i2 && (S2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === S2) m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("flipbevel" === S2) {
                if (v2 > 100) m2 = y3.mult(-1);
                else {
                  const t3 = v2 * d2.add(y3).mag() / d2.sub(y3).mag();
                  m2._perp()._mult(t3 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
              } else if ("bevel" === S2 || "fakeround" === S2) {
                const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
                if (p2 && this.addCurrentVertex(h2, d2, e4, r3, c2), "fakeround" === S2) {
                  const t4 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e5 = 1; e5 < t4; e5++) {
                    let r4 = e5 / t4;
                    if (0.5 !== r4) {
                      const t5 = r4 - 0.5;
                      r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                    }
                    const n3 = y3.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                  }
                }
                f2 && this.addCurrentVertex(h2, y3, -e4, -r3, c2);
              } else if ("butt" === S2) this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("square" === S2) {
                const t3 = p2 ? 1 : -1;
                this.addCurrentVertex(h2, m2, t3, t3, c2);
              } else "round" === S2 && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y3, -1, -1, c2, true), this.addCurrentVertex(h2, y3, 0, 0, c2)));
              if (w2 && e3 < o2 - 1) {
                const t3 = h2.dist(f2);
                if (t3 > 2 * u2) {
                  const e4 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                  this.updateDistance(h2, e4), this.addCurrentVertex(e4, y3, 0, 0, c2), h2 = e4;
                }
              }
            }
          }
          addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
            const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
            this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > Ul / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t2, e2, r2, n2, i2, s2));
          }
          addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
            const l3 = 0.5 * (this.lineClips ? this.scaledDistance * (Ul - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & l3) << 2, l3 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const u2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t2, e2) {
            this.distance += t2.dist(e2), this.updateScaledDistance();
          }
        }
        let Nl, Zl;
        wi2("LineBucket", ql, { omit: ["layers", "patternFeatures"] });
        var Gl = { get paint() {
          return Zl = Zl || new rs2({ "line-opacity": new Wi2(G.paint_line["line-opacity"]), "line-color": new Wi2(G.paint_line["line-color"]), "line-translate": new Ji2(G.paint_line["line-translate"]), "line-translate-anchor": new Ji2(G.paint_line["line-translate-anchor"]), "line-width": new Wi2(G.paint_line["line-width"]), "line-gap-width": new Wi2(G.paint_line["line-gap-width"]), "line-offset": new Wi2(G.paint_line["line-offset"]), "line-blur": new Wi2(G.paint_line["line-blur"]), "line-dasharray": new ts2(G.paint_line["line-dasharray"]), "line-pattern": new Qi2(G.paint_line["line-pattern"]), "line-gradient": new es2(G.paint_line["line-gradient"]) });
        }, get layout() {
          return Nl = Nl || new rs2({ "line-cap": new Ji2(G.layout_line["line-cap"]), "line-join": new Wi2(G.layout_line["line-join"]), "line-miter-limit": new Ji2(G.layout_line["line-miter-limit"]), "line-round-limit": new Ji2(G.layout_line["line-round-limit"]), "line-sort-key": new Wi2(G.layout_line["line-sort-key"]) });
        } };
        class Kl extends Wi2 {
          possiblyEvaluate(t2, e2) {
            return e2 = new Ui2(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
          }
          evaluate(t2, e2, r2, n2) {
            return e2 = g({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
          }
        }
        let Xl;
        class Hl extends is2 {
          constructor(t2) {
            super(t2, Gl), this.gradientVersion = 0, Xl || (Xl = new Kl(Gl.paint.properties["line-width"].specification), Xl.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            if ("line-gradient" === t2) {
              const t3 = this.gradientExpression();
              this.stepInterpolant = !!function(t4) {
                return void 0 !== t4._styleExpression;
              }(t3) && t3._styleExpression.expression instanceof Ae2, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = Xl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
          }
          createBucket(t2) {
            return new ql(t2);
          }
          queryRadius(t2) {
            const e2 = t2, r2 = Yl(to2("line-width", this, e2), to2("line-gap-width", this, e2)), n2 = to2("line-offset", this, e2);
            return r2 / 2 + Math.abs(n2) + eo2(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, a2, o2) {
            const l3 = ro2(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, o2), u2 = o2 / 2 * Yl(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), c2 = this.paint.get("line-offset").evaluate(e2, r2);
            return c2 && (n2 = function(t3, e3) {
              const r3 = [];
              for (let n3 = 0; n3 < t3.length; n3++) {
                const i3 = t3[n3], a3 = [];
                for (let t4 = 0; t4 < i3.length; t4++) {
                  const r4 = i3[t4 - 1], n4 = i3[t4], o3 = i3[t4 + 1], l4 = 0 === t4 ? new s(0, 0) : n4.sub(r4)._unit()._perp(), u3 = t4 === i3.length - 1 ? new s(0, 0) : o3.sub(n4)._unit()._perp(), c3 = l4._add(u3)._unit(), h2 = c3.x * u3.x + c3.y * u3.y;
                  0 !== h2 && c3._mult(1 / h2), a3.push(c3._mult(e3)._add(n4));
                }
                r3.push(a3);
              }
              return r3;
            }(n2, c2 * o2)), function(t3, e3, r3) {
              for (let n3 = 0; n3 < e3.length; n3++) {
                const i3 = e3[n3];
                if (t3.length >= 3) {
                  for (let e4 = 0; e4 < i3.length; e4++) if (Wa2(t3, i3[e4])) return true;
                }
                if (Ga2(t3, i3, r3)) return true;
              }
              return false;
            }(l3, n2, u2);
          }
          isTileClipped() {
            return true;
          }
        }
        function Yl(t2, e2) {
          return e2 > 0 ? e2 + 2 * t2 : t2;
        }
        const Jl = ls2([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Wl = ls2([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        ls2([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Ql = ls2([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        ls2([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const tu = ls2([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), eu = ls2([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function ru(t2, e2, r2) {
          return t2.sections.forEach((t3) => {
            t3.text = function(t4, e3, r3) {
              const n2 = e3.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), Ri2.applyArabicShaping && (t4 = Ri2.applyArabicShaping(t4)), t4;
            }(t3.text, e2, r2);
          }), t2;
        }
        ls2([{ name: "triangle", components: 3, type: "Uint16" }]), ls2([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), ls2([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), ls2([{ type: "Float32", name: "offsetX" }]), ls2([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), ls2([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const nu = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var iu = 24, su = lu, au = function(t2, e2, r2, n2, i2) {
          var s2, a2, o2 = 8 * i2 - n2 - 1, l3 = (1 << o2) - 1, u2 = l3 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
          for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8) ;
          for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8) ;
          if (0 === s2) s2 = 1 - u2;
          else {
            if (s2 === l3) return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            a2 += Math.pow(2, n2), s2 -= u2;
          }
          return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
        }, ou = function(t2, e2, r2, n2, i2, s2) {
          var a2, o2, l3, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y3 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l3 = Math.pow(2, -a2)) < 1 && (a2--, l3 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l3 : p2 * Math.pow(2, 1 - h2)) * l3 >= 2 && (a2++, l3 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l3 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8) ;
          for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8) ;
          t2[r2 + f2 - d2] |= 128 * y3;
        };
        function lu(t2) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        lu.Varint = 0, lu.Fixed64 = 1, lu.Bytes = 2, lu.Fixed32 = 5;
        var uu = 4294967296, cu = 1 / uu, hu = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
        function pu(t2) {
          return t2.type === lu.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
        }
        function fu(t2, e2, r2) {
          return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
        }
        function du(t2, e2, r2) {
          var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n2);
          for (var i2 = r2.pos - 1; i2 >= t2; i2--) r2.buf[i2 + n2] = r2.buf[i2];
        }
        function yu(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeVarint(t2[r2]);
        }
        function mu(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeSVarint(t2[r2]);
        }
        function gu(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeFloat(t2[r2]);
        }
        function xu(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeDouble(t2[r2]);
        }
        function vu(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeBoolean(t2[r2]);
        }
        function bu(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeFixed32(t2[r2]);
        }
        function wu(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeSFixed32(t2[r2]);
        }
        function _u(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeFixed64(t2[r2]);
        }
        function Au(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++) e2.writeSFixed64(t2[r2]);
        }
        function Su(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
        }
        function ku(t2, e2, r2) {
          t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
        }
        function Mu(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
        }
        lu.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t2, e2, r2) {
          for (r2 = r2 || this.length; this.pos < r2; ) {
            var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
            this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
          }
          return e2;
        }, readMessage: function(t2, e2) {
          return this.readFields(t2, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t2 = Su(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readSFixed32: function() {
          var t2 = Mu(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readFixed64: function() {
          var t2 = Su(this.buf, this.pos) + Su(this.buf, this.pos + 4) * uu;
          return this.pos += 8, t2;
        }, readSFixed64: function() {
          var t2 = Su(this.buf, this.pos) + Mu(this.buf, this.pos + 4) * uu;
          return this.pos += 8, t2;
        }, readFloat: function() {
          var t2 = au(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t2;
        }, readDouble: function() {
          var t2 = au(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t2;
        }, readVarint: function(t2) {
          var e2, r2, n2 = this.buf;
          return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
            var n3, i2, s2 = r3.buf;
            if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128) return fu(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128) return fu(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128) return fu(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128) return fu(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128) return fu(t3, n3, e3);
            if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128) return fu(t3, n3, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t2 = this.readVarint();
          return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t2, t2 - e2 >= 12 && hu ? function(t3, e3, r2) {
            return hu.decode(t3.subarray(e3, r2));
          }(this.buf, e2, t2) : function(t3, e3, r2) {
            for (var n2 = "", i2 = e3; i2 < r2; ) {
              var s2, a2, o2, l3 = t3[i2], u2 = null, c2 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
              if (i2 + c2 > r2) break;
              1 === c2 ? l3 < 128 && (u2 = l3) : 2 === c2 ? 128 == (192 & (s2 = t3[i2 + 1])) && (u2 = (31 & l3) << 6 | 63 & s2) <= 127 && (u2 = null) : 3 === c2 ? (a2 = t3[i2 + 2], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && ((u2 = (15 & l3) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && 128 == (192 & o2) && ((u2 = (15 & l3) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
            }
            return n2;
          }(this.buf, e2, t2);
        }, readBytes: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
          return this.pos = t2, e2;
        }, readPackedVarint: function(t2, e2) {
          if (this.type !== lu.Bytes) return t2.push(this.readVarint(e2));
          var r2 = pu(this);
          for (t2 = t2 || []; this.pos < r2; ) t2.push(this.readVarint(e2));
          return t2;
        }, readPackedSVarint: function(t2) {
          if (this.type !== lu.Bytes) return t2.push(this.readSVarint());
          var e2 = pu(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readSVarint());
          return t2;
        }, readPackedBoolean: function(t2) {
          if (this.type !== lu.Bytes) return t2.push(this.readBoolean());
          var e2 = pu(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readBoolean());
          return t2;
        }, readPackedFloat: function(t2) {
          if (this.type !== lu.Bytes) return t2.push(this.readFloat());
          var e2 = pu(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readFloat());
          return t2;
        }, readPackedDouble: function(t2) {
          if (this.type !== lu.Bytes) return t2.push(this.readDouble());
          var e2 = pu(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readDouble());
          return t2;
        }, readPackedFixed32: function(t2) {
          if (this.type !== lu.Bytes) return t2.push(this.readFixed32());
          var e2 = pu(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readFixed32());
          return t2;
        }, readPackedSFixed32: function(t2) {
          if (this.type !== lu.Bytes) return t2.push(this.readSFixed32());
          var e2 = pu(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readSFixed32());
          return t2;
        }, readPackedFixed64: function(t2) {
          if (this.type !== lu.Bytes) return t2.push(this.readFixed64());
          var e2 = pu(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readFixed64());
          return t2;
        }, readPackedSFixed64: function(t2) {
          if (this.type !== lu.Bytes) return t2.push(this.readSFixed64());
          var e2 = pu(this);
          for (t2 = t2 || []; this.pos < e2; ) t2.push(this.readSFixed64());
          return t2;
        }, skip: function(t2) {
          var e2 = 7 & t2;
          if (e2 === lu.Varint) for (; this.buf[this.pos++] > 127; ) ;
          else if (e2 === lu.Bytes) this.pos = this.readVarint() + this.pos;
          else if (e2 === lu.Fixed32) this.pos += 4;
          else {
            if (e2 !== lu.Fixed64) throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t2, e2) {
          this.writeVarint(t2 << 3 | e2);
        }, realloc: function(t2) {
          for (var e2 = this.length || 16; e2 < this.pos + t2; ) e2 *= 2;
          if (e2 !== this.length) {
            var r2 = new Uint8Array(e2);
            r2.set(this.buf), this.buf = r2, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t2) {
          this.realloc(4), ku(this.buf, t2, this.pos), this.pos += 4;
        }, writeSFixed32: function(t2) {
          this.realloc(4), ku(this.buf, t2, this.pos), this.pos += 4;
        }, writeFixed64: function(t2) {
          this.realloc(8), ku(this.buf, -1 & t2, this.pos), ku(this.buf, Math.floor(t2 * cu), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t2) {
          this.realloc(8), ku(this.buf, -1 & t2, this.pos), ku(this.buf, Math.floor(t2 * cu), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t2) {
          (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
            var r2, n2;
            if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t4, e3, r3) {
              r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
            }(r2, 0, e2), function(t4, e3) {
              var r3 = (7 & t4) << 4;
              e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
            }(n2, e2);
          }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
        }, writeSVarint: function(t2) {
          this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
        }, writeBoolean: function(t2) {
          this.writeVarint(Boolean(t2));
        }, writeString: function(t2) {
          t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t3, e3, r3) {
            for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
              if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
                if (!i2) {
                  n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                  continue;
                }
                n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
              } else i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
              n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
            }
            return r3;
          }(this.buf, t2, this.pos);
          var r2 = this.pos - e2;
          r2 >= 128 && du(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
        }, writeFloat: function(t2) {
          this.realloc(4), ou(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t2) {
          this.realloc(8), ou(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t2) {
          var e2 = t2.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r2 = 0; r2 < e2; r2++) this.buf[this.pos++] = t2[r2];
        }, writeRawMessage: function(t2, e2) {
          this.pos++;
          var r2 = this.pos;
          t2(e2, this);
          var n2 = this.pos - r2;
          n2 >= 128 && du(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t2, e2, r2) {
          this.writeTag(t2, lu.Bytes), this.writeRawMessage(e2, r2);
        }, writePackedVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, yu, e2);
        }, writePackedSVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, mu, e2);
        }, writePackedBoolean: function(t2, e2) {
          e2.length && this.writeMessage(t2, vu, e2);
        }, writePackedFloat: function(t2, e2) {
          e2.length && this.writeMessage(t2, gu, e2);
        }, writePackedDouble: function(t2, e2) {
          e2.length && this.writeMessage(t2, xu, e2);
        }, writePackedFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, bu, e2);
        }, writePackedSFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, wu, e2);
        }, writePackedFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, _u, e2);
        }, writePackedSFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, Au, e2);
        }, writeBytesField: function(t2, e2) {
          this.writeTag(t2, lu.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t2, e2) {
          this.writeTag(t2, lu.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t2, e2) {
          this.writeTag(t2, lu.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t2, e2) {
          this.writeTag(t2, lu.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t2, e2) {
          this.writeTag(t2, lu.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t2, e2) {
          this.writeTag(t2, lu.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t2, e2) {
          this.writeTag(t2, lu.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t2, e2) {
          this.writeTag(t2, lu.Bytes), this.writeString(e2);
        }, writeFloatField: function(t2, e2) {
          this.writeTag(t2, lu.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t2, e2) {
          this.writeTag(t2, lu.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t2, e2) {
          this.writeVarintField(t2, Boolean(e2));
        } };
        var Iu = r(su);
        const zu = 3;
        function Pu(t2, e2, r2) {
          1 === t2 && r2.readMessage(Cu, e2);
        }
        function Cu(t2, e2, r2) {
          if (3 === t2) {
            const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l3 } = r2.readMessage(Bu, {});
            e2.push({ id: t3, bitmap: new _o2({ width: i2 + 2 * zu, height: s2 + 2 * zu }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l3 } });
          }
        }
        function Bu(t2, e2, r2) {
          1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
        }
        const Vu = zu;
        function Eu(t2) {
          let e2 = 0, r2 = 0;
          for (const n3 of t2) e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
          t2.sort((t3, e3) => e3.h - t3.h);
          const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
          let i2 = 0, s2 = 0;
          for (const e3 of t2) for (let t3 = n2.length - 1; t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                t3 < n2.length && (n2[t3] = e4);
              } else e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
          return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
        }
        const Fu = 1;
        class Tu {
          constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2, textFitWidth: a2, textFitHeight: o2 }) {
            this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2, this.textFitWidth = a2, this.textFitHeight = o2;
          }
          get tl() {
            return [this.paddedRect.x + Fu, this.paddedRect.y + Fu];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - Fu, this.paddedRect.y + this.paddedRect.h - Fu];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * Fu) / this.pixelRatio, (this.paddedRect.h - 2 * Fu) / this.pixelRatio];
          }
        }
        class $u {
          constructor(t2, e2) {
            const r2 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            const i2 = [];
            this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
            const { w: s2, h: a2 } = Eu(i2), o2 = new Ao2({ width: s2 || 1, height: a2 || 1 });
            for (const e3 in t2) {
              const n3 = t2[e3], i3 = r2[e3].paddedRect;
              Ao2.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + Fu, y: i3.y + Fu }, n3.data);
            }
            for (const t3 in e2) {
              const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + Fu, a3 = i3.y + Fu, l3 = r3.data.width, u2 = r3.data.height;
              Ao2.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Ao2.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l3, height: 1 }), Ao2.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l3, height: 1 }), Ao2.copy(r3.data, o2, { x: l3 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Ao2.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l3, y: a3 }, { width: 1, height: u2 });
            }
            this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
          }
          addImages(t2, e2, r2) {
            for (const n2 in t2) {
              const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2 * Fu, h: i2.data.height + 2 * Fu };
              r2.push(s2), e2[n2] = new Tu(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }
          patchUpdatedImages(t2, e2) {
            t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r2 in t2.updatedImages) this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
          }
          patchUpdatedImage(t2, e2, r2) {
            if (!t2 || !e2) return;
            if (t2.version === e2.version) return;
            t2.version = e2.version;
            const [n2, i2] = t2.tl;
            r2.update(e2.data, void 0, { x: n2, y: i2 });
          }
        }
        var Lu;
        wi2("ImagePosition", Tu), wi2("ImageAtlas", $u), t.ah = void 0, (Lu = t.ah || (t.ah = {}))[Lu.none = 0] = "none", Lu[Lu.horizontal = 1] = "horizontal", Lu[Lu.vertical = 2] = "vertical", Lu[Lu.horizontalOnly = 3] = "horizontalOnly";
        const Du = -17;
        class Ou {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t2, e2) {
            const r2 = new Ou();
            return r2.scale = t2 || 1, r2.fontStack = e2, r2;
          }
          static forImage(t2) {
            const e2 = new Ou();
            return e2.imageName = t2, e2;
          }
        }
        class ju {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t2, e2) {
            const r2 = new ju();
            for (let n2 = 0; n2 < t2.sections.length; n2++) {
              const i2 = t2.sections[n2];
              i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
            }
            return r2;
          }
          length() {
            return this.text.length;
          }
          getSection(t2) {
            return this.sections[this.sectionIndex[t2]];
          }
          getSectionIndex(t2) {
            return this.sectionIndex[t2];
          }
          getCharCode(t2) {
            return this.text.charCodeAt(t2);
          }
          verticalizePunctuation() {
            this.text = function(t2) {
              let e2 = "";
              for (let r2 = 0; r2 < t2.length; r2++) {
                const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
                e2 += n2 && $i2(n2) && !nu[t2[r2 + 1]] || i2 && $i2(i2) && !nu[t2[r2 - 1]] || !nu[t2[r2]] ? t2[r2] : nu[t2[r2]];
              }
              return e2;
            }(this.text);
          }
          trim() {
            let t2 = 0;
            for (let e3 = 0; e3 < this.text.length && Uu[this.text.charCodeAt(e3)]; e3++) t2++;
            let e2 = this.text.length;
            for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && Uu[this.text.charCodeAt(r2)]; r2--) e2--;
            this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
          }
          substring(t2, e2) {
            const r2 = new ju();
            return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
          }
          addTextSection(t2, e2) {
            this.text += t2.text, this.sections.push(Ou.forText(t2.scale, t2.fontStack || e2));
            const r2 = this.sections.length - 1;
            for (let e3 = 0; e3 < t2.text.length; ++e3) this.sectionIndex.push(r2);
          }
          addImageSection(t2) {
            const e2 = t2.image ? t2.image.name : "";
            if (0 === e2.length) return void A2("Can't add FormattedSection with an empty image.");
            const r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Ou.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A2("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Ru(e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3) {
          const m2 = ju.fromFeature(e2, s2);
          let g2;
          p2 === t.ah.vertical && m2.verticalizePunctuation();
          const { processBidirectionalText: x2, processStyledBidirectionalText: v2 } = Ri2;
          if (x2 && 1 === m2.sections.length) {
            g2 = [];
            const t2 = x2(m2.toString(), Yu(m2, c2, a2, r2, i2, d2));
            for (const e3 of t2) {
              const t3 = new ju();
              t3.text = e3, t3.sections = m2.sections;
              for (let r3 = 0; r3 < e3.length; r3++) t3.sectionIndex.push(0);
              g2.push(t3);
            }
          } else if (v2) {
            g2 = [];
            const t2 = v2(m2.text, m2.sectionIndex, Yu(m2, c2, a2, r2, i2, d2));
            for (const e3 of t2) {
              const t3 = new ju();
              t3.text = e3[0], t3.sectionIndex = e3[1], t3.sections = m2.sections, g2.push(t3);
            }
          } else g2 = function(t2, e3) {
            const r3 = [], n3 = t2.text;
            let i3 = 0;
            for (const n4 of e3) r3.push(t2.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
          }(m2, Yu(m2, c2, a2, r2, i2, d2));
          const b2 = [], w2 = { positionedLines: b2, text: m2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
          return function(e3, r3, n3, i3, s3, a3, o3, l4, u3, c3, h3, p3) {
            let f3 = 0, d3 = Du, y4 = 0, m3 = 0;
            const g3 = "right" === l4 ? 1 : "left" === l4 ? 0 : 0.5;
            let x3 = 0;
            for (const o4 of s3) {
              o4.trim();
              const s4 = o4.getMaxScale(), l5 = (s4 - 1) * iu, b4 = { positionedGlyphs: [], lineOffset: 0 };
              e3.positionedLines[x3] = b4;
              const w4 = b4.positionedGlyphs;
              let _3 = 0;
              if (!o4.length()) {
                d3 += a3, ++x3;
                continue;
              }
              for (let a4 = 0; a4 < o4.length(); a4++) {
                const y5 = o4.getSection(a4), m4 = o4.getSectionIndex(a4), g4 = o4.getCharCode(a4);
                let x4 = 0, b5 = null, A4 = null, S2 = null, k2 = iu;
                const M3 = !(u3 === t.ah.horizontal || !h3 && !Ti2(g4) || h3 && (Uu[g4] || (v3 = g4, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(v3)))));
                if (y5.imageName) {
                  const t2 = i3[y5.imageName];
                  if (!t2) continue;
                  S2 = y5.imageName, e3.iconsInText = e3.iconsInText || true, A4 = t2.paddedRect;
                  const r4 = t2.displaySize;
                  y5.scale = y5.scale * iu / p3, b5 = { width: r4[0], height: r4[1], left: Fu, top: -Vu, advance: M3 ? r4[1] : r4[0] }, x4 = l5 + (iu - r4[1] * y5.scale), k2 = b5.advance;
                  const n4 = M3 ? r4[0] * y5.scale - iu * s4 : r4[1] * y5.scale - iu * s4;
                  n4 > 0 && n4 > _3 && (_3 = n4);
                } else {
                  const t2 = n3[y5.fontStack], e4 = t2 && t2[g4];
                  if (e4 && e4.rect) A4 = e4.rect, b5 = e4.metrics;
                  else {
                    const t3 = r3[y5.fontStack], e5 = t3 && t3[g4];
                    if (!e5) continue;
                    b5 = e5.metrics;
                  }
                  x4 = (s4 - y5.scale) * iu;
                }
                M3 ? (e3.verticalizable = true, w4.push({ glyph: g4, imageName: S2, x: f3, y: d3 + x4, vertical: M3, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m4, metrics: b5, rect: A4 }), f3 += k2 * y5.scale + c3) : (w4.push({ glyph: g4, imageName: S2, x: f3, y: d3 + x4, vertical: M3, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m4, metrics: b5, rect: A4 }), f3 += b5.advance * y5.scale + c3);
              }
              0 !== w4.length && (y4 = Math.max(f3 - c3, y4), Wu(w4, 0, w4.length - 1, g3, _3)), f3 = 0;
              const A3 = a3 * s4 + _3;
              b4.lineOffset = Math.max(_3, l5), d3 += A3, m3 = Math.max(A3, m3), ++x3;
            }
            var v3;
            const b3 = d3 - Du, { horizontalAlign: w3, verticalAlign: _2 } = Ju(o3);
            (function(t2, e4, r4, n4, i4, s4, a4, o4, l5) {
              const u4 = (e4 - r4) * i4;
              let c4 = 0;
              c4 = s4 !== a4 ? -o4 * n4 - Du : (-n4 * l5 + 0.5) * a4;
              for (const e5 of t2) for (const t3 of e5.positionedGlyphs) t3.x += u4, t3.y += c4;
            })(e3.positionedLines, g3, w3, _2, y4, m3, a3, b3, s3.length), e3.top += -_2 * b3, e3.bottom = e3.top + b3, e3.left += -w3 * y4, e3.right = e3.left + y4;
          }(w2, r2, n2, i2, g2, o2, l3, u2, p2, c2, f2, y3), !function(t2) {
            for (const e3 of t2) if (0 !== e3.positionedGlyphs.length) return false;
            return true;
          }(b2) && w2;
        }
        const Uu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, qu = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, Nu = { 40: true };
        function Zu(t2, e2, r2, n2, i2, s2) {
          if (e2.imageName) {
            const t3 = n2[e2.imageName];
            return t3 ? t3.displaySize[0] * e2.scale * iu / s2 + i2 : 0;
          }
          {
            const n3 = r2[e2.fontStack], s3 = n3 && n3[t2];
            return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
          }
        }
        function Gu(t2, e2, r2, n2) {
          const i2 = Math.pow(t2 - e2, 2);
          return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
        }
        function Ku(t2, e2, r2) {
          let n2 = 0;
          return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
        }
        function Xu(t2, e2, r2, n2, i2, s2) {
          let a2 = null, o2 = Gu(e2, r2, i2, s2);
          for (const t3 of n2) {
            const n3 = Gu(e2 - t3.x, r2, i2, s2) + t3.badness;
            n3 <= o2 && (a2 = t3, o2 = n3);
          }
          return { index: t2, x: e2, priorBreak: a2, badness: o2 };
        }
        function Hu(t2) {
          return t2 ? Hu(t2.priorBreak).concat(t2.index) : [];
        }
        function Yu(t2, e2, r2, n2, i2, s2) {
          if (!t2) return [];
          const a2 = [], o2 = function(t3, e3, r3, n3, i3, s3) {
            let a3 = 0;
            for (let r4 = 0; r4 < t3.length(); r4++) {
              const o3 = t3.getSection(r4);
              a3 += Zu(t3.getCharCode(r4), o3, n3, i3, e3, s3);
            }
            return a3 / Math.max(1, Math.ceil(a3 / r3));
          }(t2, e2, r2, n2, i2, s2), l3 = t2.text.indexOf("\u200B") >= 0;
          let u2 = 0;
          for (let r3 = 0; r3 < t2.length(); r3++) {
            const h2 = t2.getSection(r3), p2 = t2.getCharCode(r3);
            if (Uu[p2] || (u2 += Zu(p2, h2, n2, i2, e2, s2)), r3 < t2.length() - 1) {
              const e3 = !((c2 = p2) < 11904) && (!!zi2["CJK Compatibility Forms"](c2) || !!zi2["CJK Compatibility"](c2) || !!zi2["CJK Strokes"](c2) || !!zi2["CJK Symbols and Punctuation"](c2) || !!zi2["Enclosed CJK Letters and Months"](c2) || !!zi2["Halfwidth and Fullwidth Forms"](c2) || !!zi2["Ideographic Description Characters"](c2) || !!zi2["Vertical Forms"](c2) || Fi2.test(String.fromCodePoint(c2)));
              (qu[p2] || e3 || h2.imageName || r3 !== t2.length() - 2 && Nu[t2.getCharCode(r3 + 1)]) && a2.push(Xu(r3 + 1, u2, o2, a2, Ku(p2, t2.getCharCode(r3 + 1), e3 && l3), false));
            }
          }
          var c2;
          return Hu(Xu(t2.length(), u2, o2, a2, 0, true));
        }
        function Ju(t2) {
          let e2 = 0.5, r2 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function Wu(t2, e2, r2, n2, i2) {
          if (!n2 && !i2) return;
          const s2 = t2[r2], a2 = (t2[r2].x + s2.metrics.advance * s2.scale) * n2;
          for (let n3 = e2; n3 <= r2; n3++) t2[n3].x -= a2, t2[n3].y += i2;
        }
        function Qu(t2, e2, r2) {
          const { horizontalAlign: n2, verticalAlign: i2 } = Ju(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
          return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
        }
        function tc(t2) {
          var e2, r2;
          let n2 = t2.left, i2 = t2.top, s2 = t2.right - n2, a2 = t2.bottom - i2;
          const o2 = null !== (e2 = t2.image.textFitWidth) && void 0 !== e2 ? e2 : "stretchOrShrink", l3 = null !== (r2 = t2.image.textFitHeight) && void 0 !== r2 ? r2 : "stretchOrShrink", u2 = (t2.image.content[2] - t2.image.content[0]) / (t2.image.content[3] - t2.image.content[1]);
          if ("proportional" === l3) {
            if ("stretchOnly" === o2 && s2 / a2 < u2 || "proportional" === o2) {
              const t3 = Math.ceil(a2 * u2);
              n2 *= t3 / s2, s2 = t3;
            }
          } else if ("proportional" === o2 && "stretchOnly" === l3 && 0 !== u2 && s2 / a2 > u2) {
            const t3 = Math.ceil(s2 / u2);
            i2 *= t3 / a2, a2 = t3;
          }
          return { x1: n2, y1: i2, x2: n2 + s2, y2: i2 + a2 };
        }
        function ec(t2, e2, r2, n2, i2, s2) {
          const a2 = t2.image;
          let o2;
          if (a2.content) {
            const t3 = a2.content, e3 = a2.pixelRatio || 1;
            o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
          }
          const l3 = e2.left * s2, u2 = e2.right * s2;
          let c2, h2, p2, f2;
          "width" === r2 || "both" === r2 ? (f2 = i2[0] + l3 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l3 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
          const d2 = e2.top * s2, y3 = e2.bottom * s2;
          return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y3 + n2[2]) : (c2 = i2[1] + (d2 + y3 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
        }
        const rc = 255, nc = 128, ic = rc * nc;
        function sc(t2, e2) {
          const { expression: r2 } = e2;
          if ("constant" === r2.kind) return { kind: "constant", layoutSize: r2.evaluate(new Ui2(t2 + 1)) };
          if ("source" === r2.kind) return { kind: "source" };
          {
            const { zoomStops: e3, interpolationType: n2 } = r2;
            let i2 = 0;
            for (; i2 < e3.length && e3[i2] <= t2; ) i2++;
            i2 = Math.max(0, i2 - 1);
            let s2 = i2;
            for (; s2 < e3.length && e3[s2] < t2 + 1; ) s2++;
            s2 = Math.min(e3.length - 1, s2);
            const a2 = e3[i2], o2 = e3[s2];
            return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new Ui2(a2)), maxSize: r2.evaluate(new Ui2(o2)), interpolationType: n2 };
          }
        }
        function ac(t2, e2, r2) {
          let n2 = "never";
          const i2 = t2.get(e2);
          return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
        }
        const oc = fl2.VectorTileFeature.types, lc = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function uc(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2) {
          const f2 = o2 ? Math.min(ic, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(ic, Math.round(o2[1])) : 0;
          t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l3 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
        }
        function cc(t2, e2, r2) {
          t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
        }
        function hc(t2) {
          for (const e2 of t2.sections) if (ji2(e2.text)) return true;
          return false;
        }
        class pc {
          constructor(t2) {
            this.layoutVertexArray = new Ws2(), this.indexArray = new na2(), this.programConfigurations = t2, this.segments = new oa2(), this.dynamicLayoutVertexArray = new Qs2(), this.opacityVertexArray = new ta2(), this.hasVisibleVertices = false, this.placedSymbolArray = new $s2();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t2, e2, r2, n2) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Jl.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Wl.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, lc, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        wi2("SymbolBuffers", pc);
        class fc {
          constructor(t2, e2, r2) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new oa2(), this.collisionVertexArray = new ra2();
          }
          upload(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Ql.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        wi2("CollisionBuffers", fc);
        class dc {
          constructor(e2) {
            this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = lo2([]), this.placementViewportMatrix = lo2([]);
            const r2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = sc(this.zoom, r2["text-size"]), this.iconSizeData = sc(this.zoom, r2["icon-size"]);
            const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
            this.canOverlap = "never" !== ac(n2, "text-overlap", "text-allow-overlap") || "never" !== ac(n2, "icon-overlap", "icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s2 && !i2.isConstant(), this.sortFeaturesByY = ("viewport-y" === s2 || "auto" === s2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n2.get("symbol-placement") && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.ah[e3])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e2.sourceID;
          }
          createArrays() {
            this.text = new pc(new Ea2(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new pc(new Ea2(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Os2(), this.lineVertexArray = new js2(), this.symbolInstances = new Ds2(), this.textAnchorOffsets = new Us2();
          }
          calculateGlyphDependencies(t2, e2, r2, n2, i2) {
            for (let s2 = 0; s2 < t2.length; s2++) if (e2[t2.charCodeAt(s2)] = true, (r2 || n2) && i2) {
              const r3 = nu[t2.charAt(s2)];
              r3 && (e2[r3.charCodeAt(0)] = true);
            }
          }
          populate(e2, r2, n2) {
            const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l3 = s2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof Yt2 && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), c2 = "constant" !== l3.value.kind || !!l3.value.value || Object.keys(l3.parameters).length > 0, h2 = s2.get("symbol-sort-key");
            if (this.features = [], !u2 && !c2) return;
            const p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y3 = new Ui2(this.zoom);
            for (const { feature: r3, id: o3, index: l4, sourceLayerIndex: m2 } of e2) {
              const e3 = i2._featureFilter.needGeometry, g2 = ja2(r3, e3);
              if (!i2._featureFilter.filter(y3, g2, n2)) continue;
              let x2, v2;
              if (e3 || (g2.geometry = Oa2(r3)), u2) {
                const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = Yt2.factory(t2), r4 = this.hasRTLText = this.hasRTLText || hc(e4);
                (!r4 || "unavailable" === Ri2.getRTLTextPluginStatus() || r4 && Ri2.isParsed()) && (x2 = ru(e4, i2, g2));
              }
              if (c2) {
                const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
                v2 = t2 instanceof te ? t2 : te.fromString(t2);
              }
              if (!x2 && !v2) continue;
              const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
              if (this.features.push({ id: o3, text: x2, icon: v2, index: l4, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: oc[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x2) {
                const e4 = a2.evaluate(g2, {}, n2).join(","), r4 = "viewport" !== s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.ah.vertical) >= 0;
                for (const t2 of x2.sections) if (t2.image) p2[t2.image.name] = true;
                else {
                  const n3 = Pi2(x2.toString()), i3 = t2.fontStack || e4, s3 = f2[i3] = f2[i3] || {};
                  this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                }
              }
            }
            "line" === s2.get("symbol-placement") && (this.features = function(t2) {
              const e3 = {}, r3 = {}, n3 = [];
              let i3 = 0;
              function s3(e4) {
                n3.push(t2[e4]), i3++;
              }
              function a3(t3, e4, i4) {
                const s4 = r3[t3];
                return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
              }
              function o3(t3, r4, i4) {
                const s4 = e3[r4];
                return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
              }
              function l4(t3, e4, r4) {
                const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return "".concat(t3, ":").concat(n4.x, ":").concat(n4.y);
              }
              for (let u3 = 0; u3 < t2.length; u3++) {
                const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  s3(u3);
                  continue;
                }
                const f3 = l4(p3, h3), d3 = l4(p3, h3, true);
                if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                  const t3 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t3].geometry);
                  delete e3[f3], delete r3[d3], r3[l4(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
                } else f3 in r3 ? a3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
              }
              return n3.filter((t3) => t3.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t2, e2) {
            const r2 = this.lineVertexArray.length;
            if (void 0 !== t2.segment) {
              let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
              const i2 = {};
              for (let n3 = t2.segment + 1; n3 < e2.length; n3++) i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
              for (let r4 = t2.segment || 0; r4 >= 0; r4--) i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
              for (let t3 = 0; t3 < e2.length; t3++) {
                const e3 = i2[t3];
                this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }
          addSymbols(e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2, p2) {
            const f2 = e2.indexArray, d2 = e2.layoutVertexArray, y3 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? a2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y3.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.ah.vertical ? Math.PI / 2 : 0, v2 = a2.text && a2.text.sections;
            for (let t2 = 0; t2 < r2.length; t2++) {
              const { tl: i3, tr: s3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A3 } = r2[t2], S2 = y3.vertexLength, k2 = w2[1];
              uc(d2, l3.x, l3.y, i3.x, k2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), uc(d2, l3.x, l3.y, s3.x, k2 + s3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), uc(d2, l3.x, l3.y, o3.x, k2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), uc(d2, l3.x, l3.y, u3.x, k2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), cc(e2.dynamicLayoutVertexArray, l3, x2), f2.emplaceBack(S2, S2 + 1, S2 + 2), f2.emplaceBack(S2 + 1, S2 + 2, S2 + 3), y3.vertexLength += 4, y3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A3 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, {}, p2, v2 && v2[A3]);
            }
            e2.placedSymbolArray.emplaceBack(l3.x, l3.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l3.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
          }
          _addCollisionDebugVertex(t2, e2, r2, n2, i2, s2) {
            return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
          }
          addCollisionDebugVertices(t2, e2, r2, n2, i2, a2, o2) {
            const l3 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), u2 = l3.vertexLength, c2 = i2.layoutVertexArray, h2 = i2.collisionVertexArray, p2 = o2.anchorX, f2 = o2.anchorY;
            this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(t2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(r2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(r2, n2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(t2, n2)), l3.vertexLength += 4;
            const d2 = i2.indexArray;
            d2.emplaceBack(u2, u2 + 1), d2.emplaceBack(u2 + 1, u2 + 2), d2.emplaceBack(u2 + 2, u2 + 3), d2.emplaceBack(u2 + 3, u2), l3.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t2, e2, r2, n2) {
            for (let i2 = t2; i2 < e2; i2++) {
              const t3 = this.collisionBoxArray.get(i2);
              this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new fc(ea2, tu.members, ia2), this.iconCollisionBox = new fc(ea2, tu.members, ia2);
            for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
              const e2 = this.symbolInstances.get(t2);
              this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
            const u2 = {};
            for (let n3 = e2; n3 < r2; n3++) {
              const e3 = t2.get(n3);
              u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
              break;
            }
            for (let e3 = n2; e3 < i2; e3++) {
              const r3 = t2.get(e3);
              u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = s2; e3 < a2; e3++) {
              const r3 = t2.get(e3);
              u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = o2; e3 < l3; e3++) {
              const r3 = t2.get(e3);
              u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
              break;
            }
            return u2;
          }
          deserializeCollisionBoxes(t2) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              const r2 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t2, e2) {
            const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
            for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4) t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t2) {
            if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
            const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
            for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
              s2.push(t3);
              const a2 = this.symbolInstances.get(t3);
              n2.push(0 | Math.round(e2 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
            }
            return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
          }
          addToSortKeyRanges(t2, e2) {
            const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }
          sortFeatures(t2) {
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t3 of this.symbolInstanceIndexes) {
                const e2 = this.symbolInstances.get(t3);
                this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r2) => {
                  t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
                }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let yc, mc;
        wi2("SymbolBucket", dc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), dc.MAX_GLYPHS = 65535, dc.addDynamicAttributes = cc;
        var gc = { get paint() {
          return mc = mc || new rs2({ "icon-opacity": new Wi2(G.paint_symbol["icon-opacity"]), "icon-color": new Wi2(G.paint_symbol["icon-color"]), "icon-halo-color": new Wi2(G.paint_symbol["icon-halo-color"]), "icon-halo-width": new Wi2(G.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Wi2(G.paint_symbol["icon-halo-blur"]), "icon-translate": new Ji2(G.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ji2(G.paint_symbol["icon-translate-anchor"]), "text-opacity": new Wi2(G.paint_symbol["text-opacity"]), "text-color": new Wi2(G.paint_symbol["text-color"], { runtimeType: pt2, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Wi2(G.paint_symbol["text-halo-color"]), "text-halo-width": new Wi2(G.paint_symbol["text-halo-width"]), "text-halo-blur": new Wi2(G.paint_symbol["text-halo-blur"]), "text-translate": new Ji2(G.paint_symbol["text-translate"]), "text-translate-anchor": new Ji2(G.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return yc = yc || new rs2({ "symbol-placement": new Ji2(G.layout_symbol["symbol-placement"]), "symbol-spacing": new Ji2(G.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ji2(G.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Wi2(G.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ji2(G.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ji2(G.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Ji2(G.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Ji2(G.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ji2(G.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ji2(G.layout_symbol["icon-rotation-alignment"]), "icon-size": new Wi2(G.layout_symbol["icon-size"]), "icon-text-fit": new Ji2(G.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ji2(G.layout_symbol["icon-text-fit-padding"]), "icon-image": new Wi2(G.layout_symbol["icon-image"]), "icon-rotate": new Wi2(G.layout_symbol["icon-rotate"]), "icon-padding": new Wi2(G.layout_symbol["icon-padding"]), "icon-keep-upright": new Ji2(G.layout_symbol["icon-keep-upright"]), "icon-offset": new Wi2(G.layout_symbol["icon-offset"]), "icon-anchor": new Wi2(G.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ji2(G.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ji2(G.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ji2(G.layout_symbol["text-rotation-alignment"]), "text-field": new Wi2(G.layout_symbol["text-field"]), "text-font": new Wi2(G.layout_symbol["text-font"]), "text-size": new Wi2(G.layout_symbol["text-size"]), "text-max-width": new Wi2(G.layout_symbol["text-max-width"]), "text-line-height": new Ji2(G.layout_symbol["text-line-height"]), "text-letter-spacing": new Wi2(G.layout_symbol["text-letter-spacing"]), "text-justify": new Wi2(G.layout_symbol["text-justify"]), "text-radial-offset": new Wi2(G.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ji2(G.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Wi2(G.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Wi2(G.layout_symbol["text-anchor"]), "text-max-angle": new Ji2(G.layout_symbol["text-max-angle"]), "text-writing-mode": new Ji2(G.layout_symbol["text-writing-mode"]), "text-rotate": new Wi2(G.layout_symbol["text-rotate"]), "text-padding": new Ji2(G.layout_symbol["text-padding"]), "text-keep-upright": new Ji2(G.layout_symbol["text-keep-upright"]), "text-transform": new Wi2(G.layout_symbol["text-transform"]), "text-offset": new Wi2(G.layout_symbol["text-offset"]), "text-allow-overlap": new Ji2(G.layout_symbol["text-allow-overlap"]), "text-overlap": new Ji2(G.layout_symbol["text-overlap"]), "text-ignore-placement": new Ji2(G.layout_symbol["text-ignore-placement"]), "text-optional": new Ji2(G.layout_symbol["text-optional"]) });
        } };
        class xc {
          constructor(t2) {
            if (void 0 === t2.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : lt2, this.defaultValue = t2;
          }
          evaluate(t2) {
            if (t2.formattedSection) {
              const e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t2.formattedSection)) return e2.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        wi2("FormatSectionOverride", xc, { omit: ["defaultValue"] });
        class vc extends is2 {
          constructor(t2) {
            super(t2, gc);
          }
          recalculate(t2, e2) {
            if (super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              const t3 = this.layout.get("text-writing-mode");
              if (t3) {
                const e3 = [];
                for (const r2 of t3) e3.indexOf(r2) < 0 && e3.push(r2);
                this.layout._values["text-writing-mode"] = e3;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t2, e2, r2, n2) {
            const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
            return s2.isDataDriven() || vn2(s2.value) || !i2 ? i2 : function(t3, e3) {
              return e3.replace(/{([^{}]+)}/g, (e4, r3) => t3 && r3 in t3 ? String(t3[r3]) : "");
            }(e2.properties, i2);
          }
          createBucket(t2) {
            return new dc(t2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t2 of gc.paint.overridableProperties) {
              if (!vc.hasPaintOverride(this.layout, t2)) continue;
              const e2 = this.paint.get(t2), r2 = new xc(e2), n2 = new xn2(r2, e2.property.specification);
              let i2 = null;
              i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new wn2("source", n2) : new _n2("composite", n2, e2.value.zoomStops), this.paint._values[t2] = new Hi2(e2.property, i2, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && vc.hasPaintOverride(this.layout, t2);
          }
          static hasPaintOverride(t2, e2) {
            const r2 = t2.get("text-field"), n2 = gc.paint.properties[e2];
            let i2 = false;
            const s2 = (t3) => {
              for (const e3 of t3) if (n2.overrides && n2.overrides.hasOverride(e3)) return void (i2 = true);
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof Yt2) s2(r2.value.value.sections);
            else if ("source" === r2.value.kind) {
              const t3 = (e4) => {
                i2 || (e4 instanceof se2 && ne2(e4.value) === mt2 ? s2(e4.value.sections) : e4 instanceof Ze2 ? s2(e4.sections) : e4.eachChild(t3));
              }, e3 = r2.value;
              e3._styleExpression && t3(e3._styleExpression.expression);
            }
            return i2;
          }
        }
        let bc;
        var wc = { get paint() {
          return bc = bc || new rs2({ "background-color": new Ji2(G.paint_background["background-color"]), "background-pattern": new ts2(G.paint_background["background-pattern"]), "background-opacity": new Ji2(G.paint_background["background-opacity"]) });
        } };
        class _c extends is2 {
          constructor(t2) {
            super(t2, wc);
          }
        }
        let Ac;
        var Sc = { get paint() {
          return Ac = Ac || new rs2({ "raster-opacity": new Ji2(G.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ji2(G.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ji2(G.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ji2(G.paint_raster["raster-brightness-max"]), "raster-saturation": new Ji2(G.paint_raster["raster-saturation"]), "raster-contrast": new Ji2(G.paint_raster["raster-contrast"]), "raster-resampling": new Ji2(G.paint_raster["raster-resampling"]), "raster-fade-duration": new Ji2(G.paint_raster["raster-fade-duration"]) });
        } };
        class kc extends is2 {
          constructor(t2) {
            super(t2, Sc);
          }
        }
        class Mc extends is2 {
          constructor(t2) {
            super(t2, {}), this.onAdd = (t3) => {
              this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
            }, this.onRemove = (t3) => {
              this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
            }, this.implementation = t2;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Ic {
          constructor(t2) {
            this._methodToThrottle = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const zc = 63710088e-1;
        class Pc {
          constructor(t2, e2) {
            if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid LngLat object: (".concat(t2, ", ").concat(e2, ")"));
            if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Pc(m(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return "LngLat(".concat(this.lng, ", ").concat(this.lat, ")");
          }
          distanceTo(t2) {
            const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
            return zc * Math.acos(Math.min(i2, 1));
          }
          static convert(t2) {
            if (t2 instanceof Pc) return t2;
            if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length)) return new Pc(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2) return new Pc(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Cc = 2 * Math.PI * zc;
        function Bc(t2) {
          return Cc * Math.cos(t2 * Math.PI / 180);
        }
        function Vc(t2) {
          return (180 + t2) / 360;
        }
        function Ec(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function Fc(t2, e2) {
          return t2 / Bc(e2);
        }
        function Tc(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        class $c {
          constructor(t2, e2, r2 = 0) {
            this.x = +t2, this.y = +e2, this.z = +r2;
          }
          static fromLngLat(t2, e2 = 0) {
            const r2 = Pc.convert(t2);
            return new $c(Vc(r2.lng), Ec(r2.lat), Fc(e2, r2.lat));
          }
          toLngLat() {
            return new Pc(360 * this.x - 180, Tc(this.y));
          }
          toAltitude() {
            return this.z * Bc(Tc(this.y));
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Cc * (t2 = Tc(this.y), 1 / Math.cos(t2 * Math.PI / 180));
            var t2;
          }
        }
        function Lc(t2, e2, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        class Dc {
          constructor(t2, e2, r2) {
            if (!function(t3, e3, r3) {
              return !(t3 < 0 || t3 > 25 || r3 < 0 || r3 >= Math.pow(2, t3) || e3 < 0 || e3 >= Math.pow(2, t3));
            }(t2, e2, r2)) throw new Error("x=".concat(e2, ", y=").concat(r2, ", z=").concat(t2, " outside of bounds. 0<=x<").concat(Math.pow(2, t2), ", 0<=y<").concat(Math.pow(2, t2), " 0<=z<=25 "));
            this.z = t2, this.x = e2, this.y = r2, this.key = Rc(0, t2, t2, e2, r2);
          }
          equals(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }
          url(t2, e2, r2) {
            const n2 = (s2 = this.y, a2 = this.z, o2 = Lc(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, a2) - s2 - 1), a2), l3 = Lc(256 * (i2 + 1), 256 * (s2 + 1), a2), o2[0] + "," + o2[1] + "," + l3[0] + "," + l3[1]);
            var i2, s2, a2, o2, l3;
            const u2 = function(t3, e3, r3) {
              let n3, i3 = "";
              for (let s3 = t3; s3 > 0; s3--) n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
              return i3;
            }(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
          }
          isChildOf(t2) {
            const e2 = this.z - t2.z;
            return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
          }
          getTilePoint(t2) {
            const e2 = Math.pow(2, this.z);
            return new s((t2.x * e2 - this.x) * $a2, (t2.y * e2 - this.y) * $a2);
          }
          toString() {
            return "".concat(this.z, "/").concat(this.x, "/").concat(this.y);
          }
        }
        class Oc {
          constructor(t2, e2) {
            this.wrap = t2, this.canonical = e2, this.key = Rc(t2, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class jc {
          constructor(t2, e2, r2, n2, i2) {
            if (t2 < r2) throw new Error("overscaledZ should be >= z; overscaledZ = ".concat(t2, "; z = ").concat(r2));
            this.overscaledZ = t2, this.wrap = e2, this.canonical = new Dc(r2, +n2, +i2), this.key = Rc(e2, t2, r2, n2, i2);
          }
          clone() {
            return new jc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }
          scaledTo(t2) {
            if (t2 > this.overscaledZ) throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(t2, "; overscaledZ = ").concat(this.overscaledZ));
            const e2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new jc(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new jc(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          calculateScaledKey(t2, e2) {
            if (t2 > this.overscaledZ) throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(t2, "; overscaledZ = ").concat(this.overscaledZ));
            const r2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? Rc(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : Rc(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }
          isChildOf(t2) {
            if (t2.wrap !== this.wrap) return false;
            const e2 = this.canonical.z - t2.canonical.z;
            return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
          }
          children(t2) {
            if (this.overscaledZ >= t2) return [new jc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new jc(e2, this.wrap, e2, r2, n2), new jc(e2, this.wrap, e2, r2 + 1, n2), new jc(e2, this.wrap, e2, r2, n2 + 1), new jc(e2, this.wrap, e2, r2 + 1, n2 + 1)];
          }
          isLessThan(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }
          wrapped() {
            return new jc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t2) {
            return new jc(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Oc(this.wrap, this.canonical);
          }
          toString() {
            return "".concat(this.overscaledZ, "/").concat(this.canonical.x, "/").concat(this.canonical.y);
          }
          getTilePoint(t2) {
            return this.canonical.getTilePoint(new $c(t2.x - this.wrap, t2.y));
          }
        }
        function Rc(t2, e2, r2, n2, i2) {
          (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
          const s2 = 1 << r2;
          return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
        }
        wi2("CanonicalTileID", Dc), wi2("OverscaledTileID", jc, { omit: ["posMatrix"] });
        class Uc {
          constructor(t2, e2, r2, n2 = 1, i2 = 1, s2 = 1, a2 = 0) {
            if (this.uid = t2, e2.height !== e2.width) throw new RangeError("DEM tiles must be square");
            if (r2 && !["mapbox", "terrarium", "custom"].includes(r2)) return void A2('"'.concat(r2, '" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".'));
            this.stride = e2.height;
            const o2 = this.dim = e2.height - 2;
            switch (this.data = new Uint32Array(e2.data.buffer), r2) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = n2, this.greenFactor = i2, this.blueFactor = s2, this.baseShift = a2;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let t3 = 0; t3 < o2; t3++) this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(o2, t3)] = this.data[this._idx(o2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, o2)] = this.data[this._idx(t3, o2 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o2, -1)] = this.data[this._idx(o2 - 1, 0)], this.data[this._idx(-1, o2)] = this.data[this._idx(0, o2 - 1)], this.data[this._idx(o2, o2)] = this.data[this._idx(o2 - 1, o2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let t3 = 0; t3 < o2; t3++) for (let e3 = 0; e3 < o2; e3++) {
              const r3 = this.get(t3, e3);
              r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
            }
          }
          get(t2, e2) {
            const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
            return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t2, e2) {
            if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t2 + 1);
          }
          unpack(t2, e2, r2) {
            return t2 * this.redFactor + e2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new Ao2({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t2, e2, r2) {
            if (this.dim !== t2.dim) throw new Error("dem dimension mismatch");
            let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n2 = i2 - 1;
                break;
              case 1:
                i2 = n2 + 1;
            }
            switch (r2) {
              case -1:
                s2 = a2 - 1;
                break;
              case 1:
                a2 = s2 + 1;
            }
            const o2 = -e2 * this.dim, l3 = -r2 * this.dim;
            for (let e3 = s2; e3 < a2; e3++) for (let r3 = n2; r3 < i2; r3++) this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l3)];
          }
        }
        wi2("DEMData", Uc);
        class qc {
          constructor(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t2.length; e2++) {
              const r2 = t2[e2];
              this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
            }
          }
          encode(t2) {
            return this._stringToNumber[t2];
          }
          decode(t2) {
            if (t2 >= this._numberToString.length) throw new Error("Out of bounds. Index requested n=".concat(t2, " can't be >= this._numberToString.length ").concat(this._numberToString.length));
            return this._numberToString[t2];
          }
        }
        class Nc {
          constructor(t2, e2, r2, n2, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t2) {
            this._geometry = t2;
          }
          toJSON() {
            const t2 = { geometry: this.geometry };
            for (const e2 in this) "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t2[e2] = this[e2]);
            return t2;
          }
        }
        class Zc {
          constructor(t2, e2) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new vi2($a2, 16, 0), this.grid3D = new vi2($a2, 16, 0), this.featureIndexArray = new Ns2(), this.promoteId = e2;
          }
          insert(t2, e2, r2, n2, i2, s2) {
            const a2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n2, i2);
            const o2 = s2 ? this.grid3D : this.grid;
            for (let t3 = 0; t3 < e2.length; t3++) {
              const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t4 = 0; t4 < r3.length; t4++) {
                const e3 = r3[t4];
                n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
              }
              n3[0] < $a2 && n3[1] < $a2 && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new fl2.VectorTile(new Iu(this.rawTileData)).layers, this.sourceLayerCoder = new qc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t2, e2, r2, n2) {
            this.loadVTLayers();
            const i2 = t2.params || {}, a2 = $a2 / t2.tileSize / t2.scale, o2 = zn2(i2.filter), l3 = t2.queryGeometry, u2 = t2.queryPadding * a2, c2 = Kc(l3), h2 = this.grid.query(c2.minX - u2, c2.minY - u2, c2.maxX + u2, c2.maxY + u2), p2 = Kc(t2.cameraQueryGeometry), f2 = this.grid3D.query(p2.minX - u2, p2.minY - u2, p2.maxX + u2, p2.maxY + u2, (e3, r3, n3, i3) => function(t3, e4, r4, n4, i4) {
              for (const s2 of t3) if (e4 <= s2.x && r4 <= s2.y && n4 >= s2.x && i4 >= s2.y) return true;
              const a3 = [new s(e4, r4), new s(e4, i4), new s(n4, i4), new s(n4, r4)];
              if (t3.length > 2) {
                for (const e5 of a3) if (Wa2(t3, e5)) return true;
              }
              for (let e5 = 0; e5 < t3.length - 1; e5++) if (Qa2(t3[e5], t3[e5 + 1], a3)) return true;
              return false;
            }(t2.cameraQueryGeometry, e3 - u2, r3 - u2, n3 + u2, i3 + u2));
            for (const t3 of f2) h2.push(t3);
            h2.sort(Xc);
            const d2 = {};
            let y3;
            for (let s2 = 0; s2 < h2.length; s2++) {
              const u3 = h2[s2];
              if (u3 === y3) continue;
              y3 = u3;
              const c3 = this.featureIndexArray.get(u3);
              let p3 = null;
              this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, o2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = Oa2(e3)), r3.queryIntersectsFeature(l3, e3, n3, p3, this.z, t2.transform, a2, t2.pixelPosMatrix)));
            }
            return d2;
          }
          loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l3, u2, c2) {
            const h2 = this.bucketLayerIDs[e2];
            if (s2 && !function(t3, e3) {
              for (let r3 = 0; r3 < t3.length; r3++) if (e3.indexOf(t3[r3]) >= 0) return true;
              return false;
            }(s2, h2)) return;
            const p2 = this.sourceLayerCoder.decode(r2), f2 = this.vtLayers[p2].feature(n2);
            if (i2.needGeometry) {
              const t3 = ja2(f2, true);
              if (!i2.filter(new Ui2(this.tileID.overscaledZ), t3, this.tileID.canonical)) return;
            } else if (!i2.filter(new Ui2(this.tileID.overscaledZ), f2)) return;
            const d2 = this.getId(f2, p2);
            for (let e3 = 0; e3 < h2.length; e3++) {
              const r3 = h2[e3];
              if (s2 && s2.indexOf(r3) < 0) continue;
              const i3 = o2[r3];
              if (!i3) continue;
              let p3 = {};
              d2 && u2 && (p3 = u2.getState(i3.sourceLayer || "_geojsonTileLayer", d2));
              const y3 = g({}, l3[r3]);
              y3.paint = Gc(y3.paint, i3.paint, f2, p3, a2), y3.layout = Gc(y3.layout, i3.layout, f2, p3, a2);
              const m2 = !c2 || c2(f2, i3, p3);
              if (!m2) continue;
              const x2 = new Nc(f2, this.z, this.x, this.y, d2);
              x2.layer = y3;
              let v2 = t2[r3];
              void 0 === v2 && (v2 = t2[r3] = []), v2.push({ featureIndex: n2, feature: x2, intersectionZ: m2 });
            }
          }
          lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l3 = {};
            this.loadVTLayers();
            const u2 = zn2(i2);
            for (const i3 of t2) this.loadMatchingFeature(l3, r2, n2, i3, u2, s2, a2, o2, e2);
            return l3;
          }
          hasLayer(t2) {
            for (const e2 of this.bucketLayerIDs) for (const r2 of e2) if (t2 === r2) return true;
            return false;
          }
          getId(t2, e2) {
            let r2 = t2.id;
            return this.promoteId && (r2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]], "boolean" == typeof r2 && (r2 = Number(r2))), r2;
          }
        }
        function Gc(t2, e2, r2, n2, i2) {
          return v(t2, (t3, s2) => {
            const a2 = e2 instanceof Yi2 ? e2.get(s2) : null;
            return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
          });
        }
        function Kc(t2) {
          let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
          for (const s2 of t2) e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
          return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
        }
        function Xc(t2, e2) {
          return e2 - t2;
        }
        function Hc(t2, e2, r2, n2, i2) {
          const a2 = [];
          for (let o2 = 0; o2 < t2.length; o2++) {
            const l3 = t2[o2];
            let u2;
            for (let t3 = 0; t3 < l3.length - 1; t3++) {
              let o3 = l3[t3], c2 = l3[t3 + 1];
              o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new s(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new s(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r2 && c2.y < r2 || (o3.y < r2 ? o3 = new s(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round() : c2.y < r2 && (c2 = new s(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round()), o3.x >= n2 && c2.x >= n2 || (o3.x >= n2 ? o3 = new s(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n2 && (c2 = new s(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= i2 && c2.y >= i2 || (o3.y >= i2 ? o3 = new s(o3.x + (i2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i2)._round() : c2.y >= i2 && (c2 = new s(o3.x + (i2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i2)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], a2.push(u2)), u2.push(c2)))));
            }
          }
          return a2;
        }
        wi2("FeatureIndex", Zc, { omit: ["rawTileData", "sourceLayerCoder"] });
        class Yc extends s {
          constructor(t2, e2, r2, n2) {
            super(t2, e2), this.angle = r2, void 0 !== n2 && (this.segment = n2);
          }
          clone() {
            return new Yc(this.x, this.y, this.angle, this.segment);
          }
        }
        function Jc(t2, e2, r2, n2, i2) {
          if (void 0 === e2.segment || 0 === r2) return true;
          let s2 = e2, a2 = e2.segment + 1, o2 = 0;
          for (; o2 > -r2 / 2; ) {
            if (a2--, a2 < 0) return false;
            o2 -= t2[a2].dist(s2), s2 = t2[a2];
          }
          o2 += t2[a2].dist(t2[a2 + 1]), a2++;
          const l3 = [];
          let u2 = 0;
          for (; o2 < r2 / 2; ) {
            const e3 = t2[a2], r3 = t2[a2 + 1];
            if (!r3) return false;
            let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
            for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l3.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l3[0].distance > n2; ) u2 -= l3.shift().angleDelta;
            if (u2 > i2) return false;
            a2++, o2 += e3.dist(r3);
          }
          return true;
        }
        function Wc(t2) {
          let e2 = 0;
          for (let r2 = 0; r2 < t2.length - 1; r2++) e2 += t2[r2].dist(t2[r2 + 1]);
          return e2;
        }
        function Qc(t2, e2, r2) {
          return t2 ? 0.6 * e2 * r2 : 0;
        }
        function th(t2, e2) {
          return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function eh(t2, e2, r2, n2, i2, s2) {
          const a2 = Qc(r2, i2, s2), o2 = th(r2, n2) * s2;
          let l3 = 0;
          const u2 = Wc(t2) / 2;
          for (let r3 = 0; r3 < t2.length - 1; r3++) {
            const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
            if (l3 + s3 > u2) {
              const c2 = (u2 - l3) / s3, h2 = Ce2.number(n3.x, i3.x, c2), p2 = Ce2.number(n3.y, i3.y, c2), f2 = new Yc(h2, p2, i3.angleTo(n3), r3);
              return f2._round(), !a2 || Jc(t2, f2, o2, a2, e2) ? f2 : void 0;
            }
            l3 += s3;
          }
        }
        function rh(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
          const u2 = Qc(n2, s2, a2), c2 = th(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l3 || 0 === t2[0].y || t2[0].y === l3;
          return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), nh(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l3);
        }
        function nh(t2, e2, r2, n2, i2, s2, a2, o2, l3) {
          const u2 = s2 / 2, c2 = Wc(t2);
          let h2 = 0, p2 = e2 - r2, f2 = [];
          for (let e3 = 0; e3 < t2.length - 1; e3++) {
            const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y3 = o3.angleTo(a3);
            for (; p2 + r2 < h2 + d2; ) {
              p2 += r2;
              const m2 = (p2 - h2) / d2, g2 = Ce2.number(a3.x, o3.x, m2), x2 = Ce2.number(a3.y, o3.y, m2);
              if (g2 >= 0 && g2 < l3 && x2 >= 0 && x2 < l3 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                const r3 = new Yc(g2, x2, y3, e3);
                r3._round(), n2 && !Jc(t2, r3, s2, n2, i2) || f2.push(r3);
              }
            }
            h2 += d2;
          }
          return o2 || f2.length || a2 || (f2 = nh(t2, h2 / 2, r2, n2, i2, s2, a2, true, l3)), f2;
        }
        wi2("Anchor", Yc);
        const ih = Fu;
        function sh(t2, e2, r2, n2) {
          const i2 = [], a2 = t2.image, o2 = a2.pixelRatio, l3 = a2.paddedRect.w - 2 * ih, u2 = a2.paddedRect.h - 2 * ih;
          let c2 = { x1: t2.left, y1: t2.top, x2: t2.right, y2: t2.bottom };
          const h2 = a2.stretchX || [[0, l3]], p2 = a2.stretchY || [[0, u2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h2.reduce(f2, 0), y3 = p2.reduce(f2, 0), m2 = l3 - d2, g2 = u2 - y3;
          let x2 = 0, v2 = d2, b2 = 0, w2 = y3, _2 = 0, A3 = m2, S2 = 0, k2 = g2;
          if (a2.content && n2) {
            const e3 = a2.content, r3 = e3[2] - e3[0], n3 = e3[3] - e3[1];
            (a2.textFitWidth || a2.textFitHeight) && (c2 = tc(t2)), x2 = ah(h2, 0, e3[0]), b2 = ah(p2, 0, e3[1]), v2 = ah(h2, e3[0], e3[2]), w2 = ah(p2, e3[1], e3[3]), _2 = e3[0] - x2, S2 = e3[1] - b2, A3 = r3 - v2, k2 = n3 - w2;
          }
          const M3 = c2.x1, I2 = c2.y1, z3 = c2.x2 - M3, P2 = c2.y2 - I2, C3 = (t3, n3, i3, l4) => {
            const u3 = lh(t3.stretch - x2, v2, z3, M3), c3 = uh(t3.fixed - _2, A3, t3.stretch, d2), h3 = lh(n3.stretch - b2, w2, P2, I2), p3 = uh(n3.fixed - S2, k2, n3.stretch, y3), f3 = lh(i3.stretch - x2, v2, z3, M3), m3 = uh(i3.fixed - _2, A3, i3.stretch, d2), g3 = lh(l4.stretch - b2, w2, P2, I2), C4 = uh(l4.fixed - S2, k2, l4.stretch, y3), B2 = new s(u3, h3), V3 = new s(f3, h3), E2 = new s(f3, g3), F2 = new s(u3, g3), T2 = new s(c3 / o2, p3 / o2), $2 = new s(m3 / o2, C4 / o2), L3 = e2 * Math.PI / 180;
            if (L3) {
              const t4 = Math.sin(L3), e3 = Math.cos(L3), r3 = [e3, -t4, t4, e3];
              B2._matMult(r3), V3._matMult(r3), F2._matMult(r3), E2._matMult(r3);
            }
            const D2 = t3.stretch + t3.fixed, O2 = n3.stretch + n3.fixed;
            return { tl: B2, tr: V3, bl: F2, br: E2, tex: { x: a2.paddedRect.x + ih + D2, y: a2.paddedRect.y + ih + O2, w: i3.stretch + i3.fixed - D2, h: l4.stretch + l4.fixed - O2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: T2, pixelOffsetBR: $2, minFontScaleX: A3 / o2 / z3, minFontScaleY: k2 / o2 / P2, isSDF: r2 };
          };
          if (n2 && (a2.stretchX || a2.stretchY)) {
            const t3 = oh(h2, m2, d2), e3 = oh(p2, g2, y3);
            for (let r3 = 0; r3 < t3.length - 1; r3++) {
              const n3 = t3[r3], s2 = t3[r3 + 1];
              for (let t4 = 0; t4 < e3.length - 1; t4++) i2.push(C3(n3, e3[t4], s2, e3[t4 + 1]));
            }
          } else i2.push(C3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l3 + 1 }, { fixed: 0, stretch: u2 + 1 }));
          return i2;
        }
        function ah(t2, e2, r2) {
          let n2 = 0;
          for (const i2 of t2) n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
          return n2;
        }
        function oh(t2, e2, r2) {
          const n2 = [{ fixed: -ih, stretch: 0 }];
          for (const [e3, r3] of t2) {
            const t3 = n2[n2.length - 1];
            n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
          }
          return n2.push({ fixed: e2 + ih, stretch: r2 }), n2;
        }
        function lh(t2, e2, r2, n2) {
          return t2 / e2 * r2 + n2;
        }
        function uh(t2, e2, r2, n2) {
          return t2 - e2 * r2 / n2;
        }
        class ch {
          constructor(t2, e2, r2, n2, i2, a2, o2, l3, u2, c2) {
            var h2;
            if (this.boxStartIndex = t2.length, u2) {
              let t3 = a2.top, e3 = a2.bottom;
              const r3 = a2.collisionPadding;
              r3 && (t3 -= r3[1], e3 += r3[3]);
              let n3 = e3 - t3;
              n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
            } else {
              const u3 = (null === (h2 = a2.image) || void 0 === h2 ? void 0 : h2.content) && (a2.image.textFitWidth || a2.image.textFitHeight) ? tc(a2) : { x1: a2.left, y1: a2.top, x2: a2.right, y2: a2.bottom };
              u3.y1 = u3.y1 * o2 - l3[0], u3.y2 = u3.y2 * o2 + l3[2], u3.x1 = u3.x1 * o2 - l3[3], u3.x2 = u3.x2 * o2 + l3[1];
              const p2 = a2.collisionPadding;
              if (p2 && (u3.x1 -= p2[0] * o2, u3.y1 -= p2[1] * o2, u3.x2 += p2[2] * o2, u3.y2 += p2[3] * o2), c2) {
                const t3 = new s(u3.x1, u3.y1), e3 = new s(u3.x2, u3.y1), r3 = new s(u3.x1, u3.y2), n3 = new s(u3.x2, u3.y2), i3 = c2 * Math.PI / 180;
                t3._rotate(i3), e3._rotate(i3), r3._rotate(i3), n3._rotate(i3), u3.x1 = Math.min(t3.x, e3.x, r3.x, n3.x), u3.x2 = Math.max(t3.x, e3.x, r3.x, n3.x), u3.y1 = Math.min(t3.y, e3.y, r3.y, n3.y), u3.y2 = Math.max(t3.y, e3.y, r3.y, n3.y);
              }
              t2.emplaceBack(e2.x, e2.y, u3.x1, u3.y1, u3.x2, u3.y2, r2, n2, i2);
            }
            this.boxEndIndex = t2.length;
          }
        }
        class hh {
          constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this._up(this.length++);
          }
          pop() {
            if (0 === this.length) return;
            const t2 = this.data[0], e2 = this.data.pop();
            return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e2, compare: r2 } = this, n2 = e2[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s2 = e2[i2];
              if (r2(n2, s2) >= 0) break;
              e2[t2] = s2, t2 = i2;
            }
            e2[t2] = n2;
          }
          _down(t2) {
            const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1);
              const s2 = n3 + 1;
              if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0) break;
              e2[t2] = e2[n3], t2 = n3;
            }
            e2[t2] = i2;
          }
        }
        function ph(t2, e2 = 1, r2 = false) {
          let n2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
          const l3 = t2[0];
          for (let t3 = 0; t3 < l3.length; t3++) {
            const e3 = l3[t3];
            (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > a2) && (a2 = e3.x), (!t3 || e3.y > o2) && (o2 = e3.y);
          }
          const u2 = Math.min(a2 - n2, o2 - i2);
          let c2 = u2 / 2;
          const h2 = new hh([], fh);
          if (0 === u2) return new s(n2, i2);
          for (let e3 = n2; e3 < a2; e3 += u2) for (let r3 = i2; r3 < o2; r3 += u2) h2.push(new dh(e3 + c2, r3 + c2, c2, t2));
          let p2 = function(t3) {
            let e3 = 0, r3 = 0, n3 = 0;
            const i3 = t3[0];
            for (let t4 = 0, s2 = i3.length, a3 = s2 - 1; t4 < s2; a3 = t4++) {
              const s3 = i3[t4], o3 = i3[a3], l4 = s3.x * o3.y - o3.x * s3.y;
              r3 += (s3.x + o3.x) * l4, n3 += (s3.y + o3.y) * l4, e3 += 3 * l4;
            }
            return new dh(r3 / e3, n3 / e3, 0, t3);
          }(t2), f2 = h2.length;
          for (; h2.length; ) {
            const n3 = h2.pop();
            (n3.d > p2.d || !p2.d) && (p2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, f2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h2.push(new dh(n3.p.x - c2, n3.p.y - c2, c2, t2)), h2.push(new dh(n3.p.x + c2, n3.p.y - c2, c2, t2)), h2.push(new dh(n3.p.x - c2, n3.p.y + c2, c2, t2)), h2.push(new dh(n3.p.x + c2, n3.p.y + c2, c2, t2)), f2 += 4);
          }
          return r2 && (console.log("num probes: ".concat(f2)), console.log("best distance: ".concat(p2.d))), p2.p;
        }
        function fh(t2, e2) {
          return e2.max - t2.max;
        }
        function dh(t2, e2, r2, n2) {
          this.p = new s(t2, e2), this.h = r2, this.d = function(t3, e3) {
            let r3 = false, n3 = 1 / 0;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const s2 = e3[i2];
              for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                const i4 = s2[e4], o2 = s2[a2];
                i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Ya2(t3, i4, o2));
              }
            }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
        var yh;
        t.aq = void 0, (yh = t.aq || (t.aq = {}))[yh.center = 1] = "center", yh[yh.left = 2] = "left", yh[yh.right = 3] = "right", yh[yh.top = 4] = "top", yh[yh.bottom = 5] = "bottom", yh[yh["top-left"] = 6] = "top-left", yh[yh["top-right"] = 7] = "top-right", yh[yh["bottom-left"] = 8] = "bottom-left", yh[yh["bottom-right"] = 9] = "bottom-right";
        const mh = 7, gh = Number.POSITIVE_INFINITY;
        function xh(t2, e2) {
          return e2[1] !== gh ? function(t3, e3, r2) {
            let n2 = 0, i2 = 0;
            switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r2 - mh;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = -r2 + mh;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e3;
            }
            return [n2, i2];
          }(t2, e2[0], e2[1]) : function(t3, e3) {
            let r2 = 0, n2 = 0;
            e3 < 0 && (e3 = 0);
            const i2 = e3 / Math.SQRT2;
            switch (t3) {
              case "top-right":
              case "top-left":
                n2 = i2 - mh;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = -i2 + mh;
                break;
              case "bottom":
                n2 = -e3 + mh;
                break;
              case "top":
                n2 = e3 - mh;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
                r2 = -i2;
                break;
              case "top-left":
              case "bottom-left":
                r2 = i2;
                break;
              case "left":
                r2 = e3;
                break;
              case "right":
                r2 = -e3;
            }
            return [r2, n2];
          }(t2, e2[0]);
        }
        function vh(t2, e2, r2) {
          var n2;
          const i2 = t2.layout, s2 = null === (n2 = i2.get("text-variable-anchor-offset")) || void 0 === n2 ? void 0 : n2.evaluate(e2, {}, r2);
          if (s2) {
            const t3 = s2.values, e3 = [];
            for (let r3 = 0; r3 < t3.length; r3 += 2) {
              const n3 = e3[r3] = t3[r3], i3 = t3[r3 + 1].map((t4) => t4 * iu);
              n3.startsWith("top") ? i3[1] -= mh : n3.startsWith("bottom") && (i3[1] += mh), e3[r3 + 1] = i3;
            }
            return new Qt2(e3);
          }
          const a2 = i2.get("text-variable-anchor");
          if (a2) {
            let n3;
            n3 = void 0 !== t2._unevaluatedLayout.getValue("text-radial-offset") ? [i2.get("text-radial-offset").evaluate(e2, {}, r2) * iu, gh] : i2.get("text-offset").evaluate(e2, {}, r2).map((t3) => t3 * iu);
            const s3 = [];
            for (const t3 of a2) s3.push(t3, xh(t3, n3));
            return new Qt2(s3);
          }
          return null;
        }
        function bh(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function wh(e2, r2, n2, i2, s2, a2, o2, l3, u2, c2, h2) {
          let p2 = a2.textMaxSize.evaluate(r2, {});
          void 0 === p2 && (p2 = o2);
          const f2 = e2.layers[0].layout, d2 = f2.get("icon-offset").evaluate(r2, {}, h2), y3 = Ah(n2.horizontal), m2 = o2 / 24, g2 = e2.tilePixelRatio * m2, x2 = e2.tilePixelRatio * p2 / 24, v2 = e2.tilePixelRatio * l3, b2 = e2.tilePixelRatio * f2.get("symbol-spacing"), w2 = f2.get("text-padding") * e2.tilePixelRatio, _2 = function(t2, e3, r3, n3 = 1) {
            const i3 = t2.get("icon-padding").evaluate(e3, {}, r3), s3 = i3 && i3.values;
            return [s3[0] * n3, s3[1] * n3, s3[2] * n3, s3[3] * n3];
          }(f2, r2, h2, e2.tilePixelRatio), S2 = f2.get("text-max-angle") / 180 * Math.PI, k2 = "viewport" !== f2.get("text-rotation-alignment") && "point" !== f2.get("symbol-placement"), M3 = "map" === f2.get("icon-rotation-alignment") && "point" !== f2.get("symbol-placement"), I2 = f2.get("symbol-placement"), z3 = b2 / 2, P2 = f2.get("icon-text-fit");
          let C3;
          i2 && "none" !== P2 && (e2.allowVerticalPlacement && n2.vertical && (C3 = ec(i2, n2.vertical, P2, f2.get("icon-text-fit-padding"), d2, m2)), y3 && (i2 = ec(i2, y3, P2, f2.get("icon-text-fit-padding"), d2, m2)));
          const B2 = (l4, p3) => {
            p3.x < 0 || p3.x >= $a2 || p3.y < 0 || p3.y >= $a2 || function(e3, r3, n3, i3, s3, a3, o3, l5, u3, c3, h3, p4, f3, d3, y4, m3, g3, x3, v3, b3, w3, _3, S3, k3, M4) {
              const I3 = e3.addToLineVertexArray(r3, n3);
              let z4, P3, C4, B3, V3 = 0, E2 = 0, F2 = 0, T2 = 0, $2 = -1, L3 = -1;
              const D2 = {};
              let O2 = ma2("");
              if (e3.allowVerticalPlacement && i3.vertical) {
                const t2 = l5.layout.get("text-rotate").evaluate(w3, {}, k3) + 90;
                C4 = new ch(u3, r3, c3, h3, p4, i3.vertical, f3, d3, y4, t2), o3 && (B3 = new ch(u3, r3, c3, h3, p4, o3, g3, x3, y4, t2));
              }
              if (s3) {
                const n4 = l5.layout.get("icon-rotate").evaluate(w3, {}), i4 = "none" !== l5.layout.get("icon-text-fit"), a4 = sh(s3, n4, S3, i4), f4 = o3 ? sh(o3, n4, S3, i4) : void 0;
                P3 = new ch(u3, r3, c3, h3, p4, s3, g3, x3, false, n4), V3 = 4 * a4.length;
                const d4 = e3.iconSizeData;
                let y5 = null;
                "source" === d4.kind ? (y5 = [nc * l5.layout.get("icon-size").evaluate(w3, {})], y5[0] > ic && A2("".concat(e3.layerIds[0], ': Value for "icon-size" is >= ').concat(rc, '. Reduce your "icon-size".'))) : "composite" === d4.kind && (y5 = [nc * _3.compositeIconSizes[0].evaluate(w3, {}, k3), nc * _3.compositeIconSizes[1].evaluate(w3, {}, k3)], (y5[0] > ic || y5[1] > ic) && A2("".concat(e3.layerIds[0], ': Value for "icon-size" is >= ').concat(rc, '. Reduce your "icon-size".'))), e3.addSymbols(e3.icon, a4, y5, b3, v3, w3, t.ah.none, r3, I3.lineStartIndex, I3.lineLength, -1, k3), $2 = e3.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e3.addSymbols(e3.icon, f4, y5, b3, v3, w3, t.ah.vertical, r3, I3.lineStartIndex, I3.lineLength, -1, k3), L3 = e3.icon.placedSymbolArray.length - 1);
              }
              const j2 = Object.keys(i3.horizontal);
              for (const n4 of j2) {
                const s4 = i3.horizontal[n4];
                if (!z4) {
                  O2 = ma2(s4.text);
                  const t2 = l5.layout.get("text-rotate").evaluate(w3, {}, k3);
                  z4 = new ch(u3, r3, c3, h3, p4, s4, f3, d3, y4, t2);
                }
                const o4 = 1 === s4.positionedLines.length;
                if (F2 += _h(e3, r3, s4, a3, l5, y4, w3, m3, I3, i3.vertical ? t.ah.horizontal : t.ah.horizontalOnly, o4 ? j2 : [n4], D2, $2, _3, k3), o4) break;
              }
              i3.vertical && (T2 += _h(e3, r3, i3.vertical, a3, l5, y4, w3, m3, I3, t.ah.vertical, ["vertical"], D2, L3, _3, k3));
              const R2 = z4 ? z4.boxStartIndex : e3.collisionBoxArray.length, U3 = z4 ? z4.boxEndIndex : e3.collisionBoxArray.length, q2 = C4 ? C4.boxStartIndex : e3.collisionBoxArray.length, N2 = C4 ? C4.boxEndIndex : e3.collisionBoxArray.length, Z2 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, G2 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length, K2 = B3 ? B3.boxStartIndex : e3.collisionBoxArray.length, X2 = B3 ? B3.boxEndIndex : e3.collisionBoxArray.length;
              let H2 = -1;
              const Y2 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
              H2 = Y2(z4, H2), H2 = Y2(C4, H2), H2 = Y2(P3, H2), H2 = Y2(B3, H2);
              const J3 = H2 > -1 ? 1 : 0;
              J3 && (H2 *= M4 / iu), e3.glyphOffsetArray.length >= dc.MAX_GLYPHS && A2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w3.sortKey && e3.addToSortKeyRanges(e3.symbolInstances.length, w3.sortKey);
              const W3 = vh(l5, w3, k3), [Q3, tt3] = function(e4, r4) {
                const n4 = e4.length, i4 = null == r4 ? void 0 : r4.values;
                if ((null == i4 ? void 0 : i4.length) > 0) for (let r5 = 0; r5 < i4.length; r5 += 2) {
                  const n5 = i4[r5 + 1];
                  e4.emplaceBack(t.aq[i4[r5]], n5[0], n5[1]);
                }
                return [n4, e4.length];
              }(e3.textAnchorOffsets, W3);
              e3.symbolInstances.emplaceBack(r3.x, r3.y, D2.right >= 0 ? D2.right : -1, D2.center >= 0 ? D2.center : -1, D2.left >= 0 ? D2.left : -1, D2.vertical || -1, $2, L3, O2, R2, U3, q2, N2, Z2, G2, K2, X2, c3, F2, T2, V3, E2, J3, 0, f3, H2, Q3, tt3);
            }(e2, p3, l4, n2, i2, s2, C3, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, g2, [w2, w2, w2, w2], k2, u2, v2, _2, M3, d2, r2, a2, c2, h2, o2);
          };
          if ("line" === I2) for (const t2 of Hc(r2.geometry, 0, 0, $a2, $a2)) {
            const r3 = rh(t2, b2, S2, n2.vertical || y3, i2, 24, x2, e2.overscaling, $a2);
            for (const n3 of r3) y3 && Sh(e2, y3.text, z3, n3) || B2(t2, n3);
          }
          else if ("line-center" === I2) {
            for (const t2 of r2.geometry) if (t2.length > 1) {
              const e3 = eh(t2, S2, n2.vertical || y3, i2, 24, x2);
              e3 && B2(t2, e3);
            }
          } else if ("Polygon" === r2.type) for (const t2 of xr2(r2.geometry, 0)) {
            const e3 = ph(t2, 16);
            B2(t2[0], new Yc(e3.x, e3.y, 0));
          }
          else if ("LineString" === r2.type) for (const t2 of r2.geometry) B2(t2, new Yc(t2[0].x, t2[0].y, 0));
          else if ("Point" === r2.type) for (const t2 of r2.geometry) for (const e3 of t2) B2([e3], new Yc(e3.x, e3.y, 0));
        }
        function _h(t2, e2, r2, n2, i2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3) {
          const m2 = function(t3, e3, r3, n3, i3, a3, o3, l4) {
            const u3 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, c3 = [];
            for (const t4 of e3.positionedLines) for (const n4 of t4.positionedGlyphs) {
              if (!n4.rect) continue;
              const a4 = n4.rect || {};
              let h3 = Vu + 1, p3 = true, f3 = 1, d3 = 0;
              const y4 = (i3 || l4) && n4.vertical, m3 = n4.metrics.advance * n4.scale / 2;
              if (l4 && e3.verticalizable && (d3 = t4.lineOffset / 2 - (n4.imageName ? -(iu - n4.metrics.width * n4.scale) / 2 : (n4.scale - 1) * iu)), n4.imageName) {
                const t5 = o3[n4.imageName];
                p3 = t5.sdf, f3 = t5.pixelRatio, h3 = Fu / f3;
              }
              const g3 = i3 ? [n4.x + m3, n4.y] : [0, 0];
              let x3 = i3 ? [0, 0] : [n4.x + m3 + r3[0], n4.y + r3[1] - d3], v2 = [0, 0];
              y4 && (v2 = x3, x3 = [0, 0]);
              const b2 = n4.metrics.isDoubleResolution ? 2 : 1, w2 = (n4.metrics.left - h3) * n4.scale - m3 + x3[0], _2 = (-n4.metrics.top - h3) * n4.scale + x3[1], A3 = w2 + a4.w / b2 * n4.scale / f3, S2 = _2 + a4.h / b2 * n4.scale / f3, k2 = new s(w2, _2), M3 = new s(A3, _2), I2 = new s(w2, S2), z3 = new s(A3, S2);
              if (y4) {
                const t5 = new s(-m3, m3 - Du), e4 = -Math.PI / 2, r4 = iu / 2 - m3, i4 = new s(5 - Du - r4, -(n4.imageName ? r4 : 0)), a5 = new s(...v2);
                k2._rotateAround(e4, t5)._add(i4)._add(a5), M3._rotateAround(e4, t5)._add(i4)._add(a5), I2._rotateAround(e4, t5)._add(i4)._add(a5), z3._rotateAround(e4, t5)._add(i4)._add(a5);
              }
              if (u3) {
                const t5 = Math.sin(u3), e4 = Math.cos(u3), r4 = [e4, -t5, t5, e4];
                k2._matMult(r4), M3._matMult(r4), I2._matMult(r4), z3._matMult(r4);
              }
              const P2 = new s(0, 0), C3 = new s(0, 0);
              c3.push({ tl: k2, tr: M3, bl: I2, br: z3, tex: a4, writingMode: e3.writingMode, glyphOffset: g3, sectionIndex: n4.sectionIndex, isSDF: p3, pixelOffsetTL: P2, pixelOffsetBR: C3, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return c3;
          }(0, r2, l3, i2, a2, o2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
          let x2 = null;
          "source" === g2.kind ? (x2 = [nc * i2.layout.get("text-size").evaluate(o2, {})], x2[0] > ic && A2("".concat(t2.layerIds[0], ': Value for "text-size" is >= ').concat(rc, '. Reduce your "text-size".'))) : "composite" === g2.kind && (x2 = [nc * d2.compositeTextSizes[0].evaluate(o2, {}, y3), nc * d2.compositeTextSizes[1].evaluate(o2, {}, y3)], (x2[0] > ic || x2[1] > ic) && A2("".concat(t2.layerIds[0], ': Value for "text-size" is >= ').concat(rc, '. Reduce your "text-size".'))), t2.addSymbols(t2.text, m2, x2, l3, a2, o2, c2, e2, u2.lineStartIndex, u2.lineLength, f2, y3);
          for (const e3 of h2) p2[e3] = t2.text.placedSymbolArray.length - 1;
          return 4 * m2.length;
        }
        function Ah(t2) {
          for (const e2 in t2) return t2[e2];
          return null;
        }
        function Sh(t2, e2, r2, n2) {
          const i2 = t2.compareText;
          if (e2 in i2) {
            const t3 = i2[e2];
            for (let e3 = t3.length - 1; e3 >= 0; e3--) if (n2.dist(t3[e3]) < r2) return true;
          } else i2[e2] = [];
          return i2[e2].push(n2), false;
        }
        const kh = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Mh {
          static from(t2) {
            if (!(t2 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [e2, r2] = new Uint8Array(t2, 0, 2);
            if (219 !== e2) throw new Error("Data does not appear to be in a KDBush format.");
            const n2 = r2 >> 4;
            if (1 !== n2) throw new Error("Got v".concat(n2, " data when expected v1."));
            const i2 = kh[15 & r2];
            if (!i2) throw new Error("Unrecognized array type.");
            const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
            return new Mh(a2, s2, i2, t2);
          }
          constructor(t2, e2 = 64, r2 = Float64Array, n2) {
            if (isNaN(t2) || t2 < 0) throw new Error("Unpexpected numItems value: ".concat(t2, "."));
            this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
            const i2 = kh.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
            if (i2 < 0) throw new Error("Unexpected typed array class: ".concat(r2, "."));
            n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
          }
          add(t2, e2) {
            const r2 = this._pos >> 1;
            return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
          }
          finish() {
            const t2 = this._pos >> 1;
            if (t2 !== this.numItems) throw new Error("Added ".concat(t2, " items when expected ").concat(this.numItems, "."));
            return Ih(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t2, e2, r2, n2) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l3 = [];
            for (; o2.length; ) {
              const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
              if (c2 - h2 <= a2) {
                for (let a3 = h2; a3 <= c2; a3++) {
                  const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                  o3 >= t2 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l3.push(i2[a3]);
                }
                continue;
              }
              const p2 = h2 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
              f2 >= t2 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l3.push(i2[p2]), (0 === u2 ? t2 <= f2 : e2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
            }
            return l3;
          }
          within(t2, e2, r2) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l3 = r2 * r2;
            for (; a2.length; ) {
              const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
              if (c2 - h2 <= s2) {
                for (let r3 = h2; r3 <= c2; r3++) Bh(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l3 && o2.push(n2[r3]);
                continue;
              }
              const p2 = h2 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
              Bh(f2, d2, t2, e2) <= l3 && o2.push(n2[p2]), (0 === u2 ? t2 - r2 <= f2 : e2 - r2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u2)), (0 === u2 ? t2 + r2 >= f2 : e2 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
            }
            return o2;
          }
        }
        function Ih(t2, e2, r2, n2, i2, s2) {
          if (i2 - n2 <= r2) return;
          const a2 = n2 + i2 >> 1;
          zh(t2, e2, a2, n2, i2, s2), Ih(t2, e2, r2, n2, a2 - 1, 1 - s2), Ih(t2, e2, r2, a2 + 1, i2, 1 - s2);
        }
        function zh(t2, e2, r2, n2, i2, s2) {
          for (; i2 > n2; ) {
            if (i2 - n2 > 600) {
              const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l4 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l4 / 3), c2 = 0.5 * Math.sqrt(l4 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
              zh(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
            }
            const a2 = e2[2 * r2 + s2];
            let o2 = n2, l3 = i2;
            for (Ph(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && Ph(t2, e2, n2, i2); o2 < l3; ) {
              for (Ph(t2, e2, o2, l3), o2++, l3--; e2[2 * o2 + s2] < a2; ) o2++;
              for (; e2[2 * l3 + s2] > a2; ) l3--;
            }
            e2[2 * n2 + s2] === a2 ? Ph(t2, e2, n2, l3) : (l3++, Ph(t2, e2, l3, i2)), l3 <= r2 && (n2 = l3 + 1), r2 <= l3 && (i2 = l3 - 1);
          }
        }
        function Ph(t2, e2, r2, n2) {
          Ch(t2, r2, n2), Ch(e2, 2 * r2, 2 * n2), Ch(e2, 2 * r2 + 1, 2 * n2 + 1);
        }
        function Ch(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function Bh(t2, e2, r2, n2) {
          const i2 = t2 - r2, s2 = e2 - n2;
          return i2 * i2 + s2 * s2;
        }
        var Vh;
        t.bg = void 0, (Vh = t.bg || (t.bg = {})).create = "create", Vh.load = "load", Vh.fullLoad = "fullLoad";
        let Eh = null, Fh = [];
        const Th = 1e3 / 60, $h = "loadTime", Lh = "fullLoadTime", Dh = { mark(t2) {
          performance.mark(t2);
        }, frame(t2) {
          const e2 = t2;
          null != Eh && Fh.push(e2 - Eh), Eh = e2;
        }, clearMetrics() {
          Eh = null, Fh = [], performance.clearMeasures($h), performance.clearMeasures(Lh);
          for (const e2 in t.bg) performance.clearMarks(t.bg[e2]);
        }, getPerformanceMetrics() {
          performance.measure($h, t.bg.create, t.bg.load), performance.measure(Lh, t.bg.create, t.bg.fullLoad);
          const e2 = performance.getEntriesByName($h)[0].duration, r2 = performance.getEntriesByName(Lh)[0].duration, n2 = Fh.length, i2 = 1 / (Fh.reduce((t2, e3) => t2 + e3, 0) / n2 / 1e3), s2 = Fh.filter((t2) => t2 > Th).reduce((t2, e3) => t2 + (e3 - Th) / Th, 0);
          return { loadTime: e2, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100, totalFrames: n2 };
        } };
        t.$ = class extends ps2 {
        }, t.A = oo2, t.B = yi2, t.C = function(t2) {
          if (null == M2) {
            const e2 = t2.navigator ? t2.navigator.userAgent : null;
            M2 = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return M2;
        }, t.D = Ji2, t.E = Z, t.F = class {
          constructor(t2, e2) {
            this.target = t2, this.mapId = e2, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Ic(() => this.process()), this.subscription = function(t3, e3, r2, n2) {
              return t3.addEventListener(e3, r2, false), { unsubscribe: () => {
                t3.removeEventListener(e3, r2, false);
              } };
            }(this.target, "message", (t3) => this.receive(t3)), this.globalScope = k(self) ? t2 : window;
          }
          registerMessageHandler(t2, e2) {
            this.messageHandlers[t2] = e2;
          }
          sendAsync(t2, e2) {
            return new Promise((r2, n2) => {
              const i2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              this.resolveRejects[i2] = { resolve: r2, reject: n2 }, e2 && e2.signal.addEventListener("abort", () => {
                delete this.resolveRejects[i2];
                const e3 = { id: i2, type: "<cancel>", origin: location.origin, targetMapId: t2.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(e3);
              }, { once: true });
              const s2 = [], a2 = Object.assign(Object.assign({}, t2), { id: i2, sourceMapId: this.mapId, origin: location.origin, data: ki2(t2.data, s2) });
              this.target.postMessage(a2, { transfer: s2 });
            });
          }
          receive(t2) {
            const e2 = t2.data, r2 = e2.id;
            if (!("file://" !== e2.origin && "file://" !== location.origin && "resource://android" !== e2.origin && "resource://android" !== location.origin && e2.origin !== location.origin || e2.targetMapId && this.mapId !== e2.targetMapId)) {
              if ("<cancel>" === e2.type) {
                delete this.tasks[r2];
                const t3 = this.abortControllers[r2];
                return delete this.abortControllers[r2], void (t3 && t3.abort());
              }
              if (k(self) || e2.mustQueue) return this.tasks[r2] = e2, this.taskQueue.push(r2), void this.invoker.trigger();
              this.processTask(r2, e2);
            }
          }
          process() {
            if (0 === this.taskQueue.length) return;
            const t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
            delete this.tasks[t2], this.taskQueue.length > 0 && this.invoker.trigger(), e2 && this.processTask(t2, e2);
          }
          processTask(t2, r2) {
            return e(this, void 0, void 0, function* () {
              if ("<response>" === r2.type) {
                const e3 = this.resolveRejects[t2];
                if (delete this.resolveRejects[t2], !e3) return;
                return void (r2.error ? e3.reject(Mi2(r2.error)) : e3.resolve(Mi2(r2.data)));
              }
              if (!this.messageHandlers[r2.type]) return void this.completeTask(t2, new Error("Could not find a registered handler for ".concat(r2.type, ", map ID: ").concat(this.mapId, ", available handlers: ").concat(Object.keys(this.messageHandlers).join(", "))));
              const e2 = Mi2(r2.data), n2 = new AbortController();
              this.abortControllers[t2] = n2;
              try {
                const i2 = yield this.messageHandlers[r2.type](r2.sourceMapId, e2, n2);
                this.completeTask(t2, null, i2);
              } catch (e3) {
                this.completeTask(t2, e3);
              }
            });
          }
          completeTask(t2, e2, r2) {
            const n2 = [];
            delete this.abortControllers[t2];
            const i2 = { id: t2, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e2 ? ki2(e2) : null, data: ki2(r2, n2) };
            this.target.postMessage(i2, { transfer: n2 });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, t.G = $, t.H = function() {
          var t2 = new oo2(16);
          return oo2 != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, t.I = Tu, t.J = function(t2, e2, r2) {
          var n2, i2, s2, a2, o2, l3, u2, c2, h2, p2, f2, d2, y3 = r2[0], m2 = r2[1], g2 = r2[2];
          return e2 === t2 ? (t2[12] = e2[0] * y3 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y3 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y3 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y3 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l3, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y3 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y3 + l3 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y3 + u2 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y3 + c2 * m2 + d2 * g2 + e2[15]), t2;
        }, t.K = function(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[1], s2 = r2[2];
          return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.L = uo2, t.M = function(t2, e2) {
          const r2 = {};
          for (let n2 = 0; n2 < e2.length; n2++) {
            const i2 = e2[n2];
            i2 in t2 && (r2[i2] = t2[i2]);
          }
          return r2;
        }, t.N = Pc, t.O = Vc, t.P = s, t.Q = Ec, t.R = Ao2, t.S = jc, t.T = Zi2, t.U = h, t.V = p, t.W = P, t.X = $a2, t.Y = ls2, t.Z = $c, t._ = e, t.a = F, t.a$ = function(t2, e2) {
          var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l3 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], y3 = t2[13], m2 = t2[14], g2 = t2[15], x2 = e2[0], v2 = e2[1], b2 = e2[2], w2 = e2[3], _2 = e2[4], A3 = e2[5], S2 = e2[6], k2 = e2[7], M3 = e2[8], I2 = e2[9], z3 = e2[10], P2 = e2[11], C3 = e2[12], B2 = e2[13], V3 = e2[14], E2 = e2[15];
          return Math.abs(r2 - x2) <= ao2 * Math.max(1, Math.abs(r2), Math.abs(x2)) && Math.abs(n2 - v2) <= ao2 * Math.max(1, Math.abs(n2), Math.abs(v2)) && Math.abs(i2 - b2) <= ao2 * Math.max(1, Math.abs(i2), Math.abs(b2)) && Math.abs(s2 - w2) <= ao2 * Math.max(1, Math.abs(s2), Math.abs(w2)) && Math.abs(a2 - _2) <= ao2 * Math.max(1, Math.abs(a2), Math.abs(_2)) && Math.abs(o2 - A3) <= ao2 * Math.max(1, Math.abs(o2), Math.abs(A3)) && Math.abs(l3 - S2) <= ao2 * Math.max(1, Math.abs(l3), Math.abs(S2)) && Math.abs(u2 - k2) <= ao2 * Math.max(1, Math.abs(u2), Math.abs(k2)) && Math.abs(c2 - M3) <= ao2 * Math.max(1, Math.abs(c2), Math.abs(M3)) && Math.abs(h2 - I2) <= ao2 * Math.max(1, Math.abs(h2), Math.abs(I2)) && Math.abs(p2 - z3) <= ao2 * Math.max(1, Math.abs(p2), Math.abs(z3)) && Math.abs(f2 - P2) <= ao2 * Math.max(1, Math.abs(f2), Math.abs(P2)) && Math.abs(d2 - C3) <= ao2 * Math.max(1, Math.abs(d2), Math.abs(C3)) && Math.abs(y3 - B2) <= ao2 * Math.max(1, Math.abs(y3), Math.abs(B2)) && Math.abs(m2 - V3) <= ao2 * Math.max(1, Math.abs(m2), Math.abs(V3)) && Math.abs(g2 - E2) <= ao2 * Math.max(1, Math.abs(g2), Math.abs(E2));
        }, t.a0 = oa2, t.a1 = Dc, t.a2 = it2, t.a3 = (t2) => {
          const e2 = window.document.createElement("video");
          return e2.muted = true, new Promise((r2) => {
            e2.onloadstart = () => {
              r2(e2);
            };
            for (const r3 of t2) {
              const t3 = window.document.createElement("source");
              j(r3) || (e2.crossOrigin = "Anonymous"), t3.src = r3, e2.appendChild(t3);
            }
          });
        }, t.a4 = function() {
          return x++;
        }, t.a5 = Fs2, t.a6 = dc, t.a7 = zn2, t.a8 = ja2, t.a9 = Nc, t.aA = function(t2) {
          if ("custom" === t2.type) return new Mc(t2);
          switch (t2.type) {
            case "background":
              return new _c(t2);
            case "circle":
              return new fo2(t2);
            case "fill":
              return new ul2(t2);
            case "fill-extrusion":
              return new El(t2);
            case "heatmap":
              return new Mo2(t2);
            case "hillshade":
              return new Po2(t2);
            case "line":
              return new Hl(t2);
            case "raster":
              return new kc(t2);
            case "symbol":
              return new vc(t2);
          }
        }, t.aB = w, t.aC = function(t2, e2) {
          if (!t2) return [{ command: "setStyle", args: [e2] }];
          let r2 = [];
          try {
            if (!H(t2.version, e2.version)) return [{ command: "setStyle", args: [e2] }];
            H(t2.center, e2.center) || r2.push({ command: "setCenter", args: [e2.center] }), H(t2.zoom, e2.zoom) || r2.push({ command: "setZoom", args: [e2.zoom] }), H(t2.bearing, e2.bearing) || r2.push({ command: "setBearing", args: [e2.bearing] }), H(t2.pitch, e2.pitch) || r2.push({ command: "setPitch", args: [e2.pitch] }), H(t2.sprite, e2.sprite) || r2.push({ command: "setSprite", args: [e2.sprite] }), H(t2.glyphs, e2.glyphs) || r2.push({ command: "setGlyphs", args: [e2.glyphs] }), H(t2.transition, e2.transition) || r2.push({ command: "setTransition", args: [e2.transition] }), H(t2.light, e2.light) || r2.push({ command: "setLight", args: [e2.light] }), H(t2.terrain, e2.terrain) || r2.push({ command: "setTerrain", args: [e2.terrain] }), H(t2.sky, e2.sky) || r2.push({ command: "setSky", args: [e2.sky] }), H(t2.projection, e2.projection) || r2.push({ command: "setProjection", args: [e2.projection] });
            const n2 = {}, i2 = [];
            !function(t3, e3, r3, n3) {
              let i3;
              for (i3 in e3 = e3 || {}, t3 = t3 || {}) Object.prototype.hasOwnProperty.call(t3, i3) && (Object.prototype.hasOwnProperty.call(e3, i3) || W2(i3, r3, n3));
              for (i3 in e3) Object.prototype.hasOwnProperty.call(e3, i3) && (Object.prototype.hasOwnProperty.call(t3, i3) ? H(t3[i3], e3[i3]) || ("geojson" === t3[i3].type && "geojson" === e3[i3].type && tt2(t3, e3, i3) ? Y(r3, { command: "setGeoJSONSourceData", args: [i3, e3[i3].data] }) : Q2(i3, e3, r3, n3)) : J2(i3, e3, r3));
            }(t2.sources, e2.sources, i2, n2);
            const s2 = [];
            t2.layers && t2.layers.forEach((t3) => {
              "source" in t3 && n2[t3.source] ? r2.push({ command: "removeLayer", args: [t3.id] }) : s2.push(t3);
            }), r2 = r2.concat(i2), function(t3, e3, r3) {
              e3 = e3 || [];
              const n3 = (t3 = t3 || []).map(rt2), i3 = e3.map(rt2), s3 = t3.reduce(nt2, {}), a2 = e3.reduce(nt2, {}), o2 = n3.slice(), l3 = /* @__PURE__ */ Object.create(null);
              let u2, c2, h2, p2, f2;
              for (let t4 = 0, e4 = 0; t4 < n3.length; t4++) u2 = n3[t4], Object.prototype.hasOwnProperty.call(a2, u2) ? e4++ : (Y(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.indexOf(u2, e4), 1));
              for (let t4 = 0, e4 = 0; t4 < i3.length; t4++) u2 = i3[i3.length - 1 - t4], o2[o2.length - 1 - t4] !== u2 && (Object.prototype.hasOwnProperty.call(s3, u2) ? (Y(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.lastIndexOf(u2, o2.length - e4), 1)) : e4++, p2 = o2[o2.length - t4], Y(r3, { command: "addLayer", args: [a2[u2], p2] }), o2.splice(o2.length - t4, 0, u2), l3[u2] = true);
              for (let t4 = 0; t4 < i3.length; t4++) if (u2 = i3[t4], c2 = s3[u2], h2 = a2[u2], !l3[u2] && !H(c2, h2)) if (H(c2.source, h2.source) && H(c2["source-layer"], h2["source-layer"]) && H(c2.type, h2.type)) {
                for (f2 in et2(c2.layout, h2.layout, r3, u2, null, "setLayoutProperty"), et2(c2.paint, h2.paint, r3, u2, null, "setPaintProperty"), H(c2.filter, h2.filter) || Y(r3, { command: "setFilter", args: [u2, h2.filter] }), H(c2.minzoom, h2.minzoom) && H(c2.maxzoom, h2.maxzoom) || Y(r3, { command: "setLayerZoomRange", args: [u2, h2.minzoom, h2.maxzoom] }), c2) Object.prototype.hasOwnProperty.call(c2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? et2(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : H(c2[f2], h2[f2]) || Y(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
                for (f2 in h2) Object.prototype.hasOwnProperty.call(h2, f2) && !Object.prototype.hasOwnProperty.call(c2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? et2(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : H(c2[f2], h2[f2]) || Y(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
              } else Y(r3, { command: "removeLayer", args: [u2] }), p2 = o2[o2.lastIndexOf(u2) + 1], Y(r3, { command: "addLayer", args: [h2, p2] });
            }(s2, e2.layers, r2);
          } catch (t3) {
            console.warn("Unable to compute style diff:", t3), r2 = [{ command: "setStyle", args: [e2] }];
          }
          return r2;
        }, t.aD = function(t2) {
          const e2 = [], r2 = t2.id;
          return void 0 === r2 && e2.push({ message: "layers.".concat(r2, ': missing required property "id"') }), void 0 === t2.render && e2.push({ message: "layers.".concat(r2, ': missing required method "render"') }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: "layers.".concat(r2, ': property "renderingMode" must be either "2d" or "3d"') }), e2;
        }, t.aE = function t2(e2, r2) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(r2) || e2.length !== r2.length) return false;
            for (let n2 = 0; n2 < e2.length; n2++) if (!t2(e2[n2], r2[n2])) return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== r2) {
            if ("object" != typeof r2) return false;
            if (Object.keys(e2).length !== Object.keys(r2).length) return false;
            for (const n2 in e2) if (!t2(e2[n2], r2[n2])) return false;
            return true;
          }
          return e2 === r2;
        }, t.aF = v, t.aG = b, t.aH = class extends wa2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
          }
        }, t.aI = _a2, t.aJ = class extends wa2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = ka2;
          }
          set(t2) {
            if (t2[12] !== this.current[12] || t2[0] !== this.current[0]) return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
            for (let e2 = 1; e2 < 16; e2++) if (t2[e2] !== this.current[e2]) {
              this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
              break;
            }
          }
        }, t.aK = Aa2, t.aL = Sa2, t.aM = Kt2, t.aN = class extends wa2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
          }
        }, t.aO = class extends wa2 {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
          }
        }, t.aP = function(t2, e2, r2, n2, i2, s2, a2) {
          var o2 = 1 / (e2 - r2), l3 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
          return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l3, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l3, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
        }, t.aQ = ho2, t.aR = class extends _s2 {
        }, t.aS = eu, t.aT = class extends Ss2 {
        }, t.aU = ko2, t.aV = function(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
        }, t.aW = So2, t.aX = Zs2, t.aY = na2, t.aZ = class extends Bs2 {
        }, t.a_ = function(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3] && t2[4] === e2[4] && t2[5] === e2[5] && t2[6] === e2[6] && t2[7] === e2[7] && t2[8] === e2[8] && t2[9] === e2[9] && t2[10] === e2[10] && t2[11] === e2[11] && t2[12] === e2[12] && t2[13] === e2[13] && t2[14] === e2[14] && t2[15] === e2[15];
        }, t.aa = function(t2) {
          const e2 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
            const s2 = n2 || i2;
            return e2[r2] = !s2 || s2.toLowerCase(), "";
          }), e2["max-age"]) {
            const t3 = parseInt(e2["max-age"], 10);
            isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
          }
          return e2;
        }, t.ab = function(t2, e2) {
          const r2 = [];
          for (const n2 in t2) n2 in e2 || r2.push(n2);
          return r2;
        }, t.ac = y2, t.ad = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l3 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
          return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l3 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l3 * n2, t2;
        }, t.ae = function(t2) {
          var e2 = new oo2(16);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
        }, t.af = po2, t.ag = function(t2, e2) {
          let r2 = 0, n2 = 0;
          if ("constant" === t2.kind) n2 = t2.layoutSize;
          else if ("source" !== t2.kind) {
            const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? y2(Be2.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
            "camera" === t2.kind ? n2 = Ce2.number(t2.minSize, t2.maxSize, o2) : r2 = o2;
          }
          return { uSizeT: r2, uSize: n2 };
        }, t.ai = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
          return "source" === t2.kind ? n2 / nc : "composite" === t2.kind ? Ce2.number(n2 / nc, i2 / nc, r2) : e2;
        }, t.aj = cc, t.ak = function(t2, e2, r2, n2) {
          const i2 = e2.y - t2.y, a2 = e2.x - t2.x, o2 = n2.y - r2.y, l3 = n2.x - r2.x, u2 = o2 * a2 - l3 * i2;
          if (0 === u2) return null;
          const c2 = (l3 * (t2.y - r2.y) - o2 * (t2.x - r2.x)) / u2;
          return new s(t2.x + c2 * a2, t2.y + c2 * i2);
        }, t.al = Hc, t.am = qa2, t.an = lo2, t.ao = function(t2) {
          let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
          for (const s2 of t2) e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
          return [e2, r2, n2, i2];
        }, t.ap = iu, t.ar = ac, t.as = function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l3 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y3 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l3 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l3 - i2 * o2, _2 = n2 * u2 - s2 * o2, A3 = i2 * u2 - s2 * l3, S2 = c2 * y3 - h2 * d2, k2 = c2 * m2 - p2 * d2, M3 = c2 * g2 - f2 * d2, I2 = h2 * m2 - p2 * y3, z3 = h2 * g2 - f2 * y3, P2 = p2 * g2 - f2 * m2, C3 = x2 * P2 - v2 * z3 + b2 * I2 + w2 * M3 - _2 * k2 + A3 * S2;
          return C3 ? (t2[0] = (o2 * P2 - l3 * z3 + u2 * I2) * (C3 = 1 / C3), t2[1] = (i2 * z3 - n2 * P2 - s2 * I2) * C3, t2[2] = (y3 * A3 - m2 * _2 + g2 * w2) * C3, t2[3] = (p2 * _2 - h2 * A3 - f2 * w2) * C3, t2[4] = (l3 * M3 - a2 * P2 - u2 * k2) * C3, t2[5] = (r2 * P2 - i2 * M3 + s2 * k2) * C3, t2[6] = (m2 * b2 - d2 * A3 - g2 * v2) * C3, t2[7] = (c2 * A3 - p2 * b2 + f2 * v2) * C3, t2[8] = (a2 * z3 - o2 * M3 + u2 * S2) * C3, t2[9] = (n2 * M3 - r2 * z3 - s2 * S2) * C3, t2[10] = (d2 * _2 - y3 * b2 + g2 * x2) * C3, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * C3, t2[12] = (o2 * k2 - a2 * I2 - l3 * S2) * C3, t2[13] = (r2 * I2 - n2 * k2 + i2 * S2) * C3, t2[14] = (y3 * v2 - d2 * w2 - m2 * x2) * C3, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * C3, t2) : null;
        }, t.at = bh, t.au = Ju, t.av = Mh, t.aw = function() {
          const t2 = {}, e2 = G.$version;
          for (const r2 in G.$root) {
            const n2 = G.$root[r2];
            if (n2.required) {
              let i2 = null;
              i2 = "version" === r2 ? e2 : "array" === n2.type ? [] : {}, null != i2 && (t2[r2] = i2);
            }
          }
          return t2;
        }, t.ax = Ii2, t.ay = D, t.az = function(t2) {
          t2 = t2.slice();
          const e2 = /* @__PURE__ */ Object.create(null);
          for (let r2 = 0; r2 < t2.length; r2++) e2[t2[r2].id] = t2[r2];
          for (let r2 = 0; r2 < t2.length; r2++) "ref" in t2[r2] && (t2[r2] = X(t2[r2], e2[t2[r2].ref]));
          return t2;
        }, t.b = I, t.b0 = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.b1 = function(t2, e2, r2) {
          return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
        }, t.b2 = function(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
        }, t.b3 = m, t.b4 = Oc, t.b5 = Fc, t.b6 = function(t2, e2, r2, n2, i2) {
          var s2, a2 = 1 / Math.tan(e2 / 2);
          return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
        }, t.b7 = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l3 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l3 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l3 * n2, t2;
        }, t.b8 = f, t.b9 = d, t.bA = su, t.bB = function(t2) {
          return t2.message === V2;
        }, t.bC = bn2, t.bD = Ri2, t.ba = function(t2) {
          return t2 * Math.PI / 180;
        }, t.bb = function(t2, e2) {
          const { x: r2, y: n2 } = $c.fromLngLat(e2);
          return !(t2 < 0 || t2 > 25 || n2 < 0 || n2 >= 1 || r2 < 0 || r2 >= 1);
        }, t.bc = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, t.bd = class extends hs2 {
        }, t.be = zc, t.bf = Dh, t.bh = L2, t.bi = function(t2, e2) {
          F.REGISTERED_PROTOCOLS[t2] = e2;
        }, t.bj = function(t2) {
          delete F.REGISTERED_PROTOCOLS[t2];
        }, t.bk = function(t2, e2) {
          const r2 = {};
          for (let n3 = 0; n3 < t2.length; n3++) {
            const i2 = e2 && e2[t2[n3].id] || Ln2(t2[n3]);
            e2 && (e2[t2[n3].id] = i2);
            let s2 = r2[i2];
            s2 || (s2 = r2[i2] = []), s2.push(t2[n3]);
          }
          const n2 = [];
          for (const t3 in r2) n2.push(r2[t3]);
          return n2;
        }, t.bl = wi2, t.bm = qc, t.bn = Zc, t.bo = $u, t.bp = function(e2) {
          e2.bucket.createArrays(), e2.bucket.tilePixelRatio = $a2 / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
          const r2 = e2.bucket.layers[0], n2 = r2.layout, i2 = r2._unevaluatedLayout._values, s2 = { layoutIconSize: i2["icon-size"].possiblyEvaluate(new Ui2(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i2["text-size"].possiblyEvaluate(new Ui2(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i2["text-size"].possiblyEvaluate(new Ui2(18)) };
          if ("composite" === e2.bucket.textSizeData.kind) {
            const { minZoom: t2, maxZoom: r3 } = e2.bucket.textSizeData;
            s2.compositeTextSizes = [i2["text-size"].possiblyEvaluate(new Ui2(t2), e2.canonical), i2["text-size"].possiblyEvaluate(new Ui2(r3), e2.canonical)];
          }
          if ("composite" === e2.bucket.iconSizeData.kind) {
            const { minZoom: t2, maxZoom: r3 } = e2.bucket.iconSizeData;
            s2.compositeIconSizes = [i2["icon-size"].possiblyEvaluate(new Ui2(t2), e2.canonical), i2["icon-size"].possiblyEvaluate(new Ui2(r3), e2.canonical)];
          }
          const a2 = n2.get("text-line-height") * iu, o2 = "viewport" !== n2.get("text-rotation-alignment") && "point" !== n2.get("symbol-placement"), l3 = n2.get("text-keep-upright"), u2 = n2.get("text-size");
          for (const i3 of e2.bucket.features) {
            const c2 = n2.get("text-font").evaluate(i3, {}, e2.canonical).join(","), h2 = u2.evaluate(i3, {}, e2.canonical), p2 = s2.layoutTextSize.evaluate(i3, {}, e2.canonical), f2 = s2.layoutIconSize.evaluate(i3, {}, e2.canonical), d2 = { horizontal: {}, vertical: void 0 }, y3 = i3.text;
            let m2, g2 = [0, 0];
            if (y3) {
              const s3 = y3.toString(), u3 = n2.get("text-letter-spacing").evaluate(i3, {}, e2.canonical) * iu, f3 = Ci2(s3) ? u3 : 0, m3 = n2.get("text-anchor").evaluate(i3, {}, e2.canonical), x3 = vh(r2, i3, e2.canonical);
              if (!x3) {
                const t2 = n2.get("text-radial-offset").evaluate(i3, {}, e2.canonical);
                g2 = t2 ? xh(m3, [t2 * iu, gh]) : n2.get("text-offset").evaluate(i3, {}, e2.canonical).map((t3) => t3 * iu);
              }
              let v3 = o2 ? "center" : n2.get("text-justify").evaluate(i3, {}, e2.canonical);
              const b2 = "point" === n2.get("symbol-placement") ? n2.get("text-max-width").evaluate(i3, {}, e2.canonical) * iu : 1 / 0, w2 = () => {
                e2.bucket.allowVerticalPlacement && Pi2(s3) && (d2.vertical = Ru(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, "left", f3, g2, t.ah.vertical, true, p2, h2));
              };
              if (!o2 && x3) {
                const r3 = /* @__PURE__ */ new Set();
                if ("auto" === v3) for (let t2 = 0; t2 < x3.values.length; t2 += 2) r3.add(bh(x3.values[t2]));
                else r3.add(v3);
                let n3 = false;
                for (const i4 of r3) if (!d2.horizontal[i4]) if (n3) d2.horizontal[i4] = d2.horizontal[0];
                else {
                  const r4 = Ru(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, "center", i4, f3, g2, t.ah.horizontal, false, p2, h2);
                  r4 && (d2.horizontal[i4] = r4, n3 = 1 === r4.positionedLines.length);
                }
                w2();
              } else {
                "auto" === v3 && (v3 = bh(m3));
                const r3 = Ru(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v3, f3, g2, t.ah.horizontal, false, p2, h2);
                r3 && (d2.horizontal[v3] = r3), w2(), Pi2(s3) && o2 && l3 && (d2.vertical = Ru(y3, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v3, f3, g2, t.ah.vertical, false, p2, h2));
              }
            }
            let x2 = false;
            if (i3.icon && i3.icon.name) {
              const t2 = e2.imageMap[i3.icon.name];
              t2 && (m2 = Qu(e2.imagePositions[i3.icon.name], n2.get("icon-offset").evaluate(i3, {}, e2.canonical), n2.get("icon-anchor").evaluate(i3, {}, e2.canonical)), x2 = !!t2.sdf, void 0 === e2.bucket.sdfIcons ? e2.bucket.sdfIcons = x2 : e2.bucket.sdfIcons !== x2 && A2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.bucket.pixelRatio || 0 !== n2.get("icon-rotate").constantOr(1)) && (e2.bucket.iconsNeedLinear = true));
            }
            const v2 = Ah(d2.horizontal) || d2.vertical;
            e2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && wh(e2.bucket, i3, d2, m2, e2.imageMap, s2, p2, f2, g2, x2, e2.canonical);
          }
          e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
        }, t.bq = ql, t.br = sl2, t.bs = zl, t.bt = fl2, t.bu = Iu, t.bv = class {
          constructor(t2) {
            this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t2 = performance.getEntriesByName(this._marks.measure);
            return 0 === t2.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
          }
        }, t.bw = function(t2, r2, n2, i2, s2) {
          return e(this, void 0, void 0, function* () {
            if (p()) try {
              return yield P(t2, r2, n2, i2, s2);
            } catch (t3) {
            }
            return function(t3, e2, r3, n3, i3) {
              const s3 = t3.width, a2 = t3.height;
              C2 && B || (C2 = new OffscreenCanvas(s3, a2), B = C2.getContext("2d", { willReadFrequently: true })), C2.width = s3, C2.height = a2, B.drawImage(t3, 0, 0, s3, a2);
              const o2 = B.getImageData(e2, r3, n3, i3);
              return B.clearRect(0, 0, s3, a2), o2.data;
            }(t2, r2, n2, i2, s2);
          });
        }, t.bx = Uc, t.by = r, t.bz = n, t.c = E, t.d = (t2) => e(void 0, void 0, void 0, function* () {
          if (0 === t2.byteLength) return createImageBitmap(new ImageData(1, 1));
          const e2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
          try {
            return createImageBitmap(e2);
          } catch (t3) {
            throw new Error("Could not load image because of ".concat(t3.message, ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }
        }), t.e = g, t.f = (t2) => new Promise((e2, r2) => {
          const n2 = new Image();
          n2.onload = () => {
            e2(n2), URL.revokeObjectURL(n2.src), n2.onload = null, window.requestAnimationFrame(() => {
              n2.src = z2;
            });
          }, n2.onerror = () => r2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const i2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
          n2.src = t2.byteLength ? URL.createObjectURL(i2) : z2;
        }), t.g = T, t.h = (t2, e2) => O(g(t2, { type: "json" }), e2), t.i = k, t.j = N, t.k = q, t.l = (t2, e2) => O(g(t2, { type: "arrayBuffer" }), e2), t.m = O, t.n = function(t2) {
          return new Iu(t2).readFields(Pu, []);
        }, t.o = _o2, t.p = Eu, t.q = rs2, t.r = di2, t.s = j, t.t = xi2, t.u = fi2, t.v = G, t.w = A2, t.x = function([t2, e2, r2]) {
          return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e2) * Math.sin(r2), y: t2 * Math.sin(e2) * Math.sin(r2), z: t2 * Math.cos(r2) };
        }, t.y = Ce2, t.z = Ui2;
      });
      define2("worker", ["./shared"], function(e) {
        "use strict";
        class t {
          constructor(e2) {
            this.keyCache = {}, e2 && this.replace(e2);
          }
          replace(e2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
          }
          update(t2, o2) {
            for (const o3 of t2) {
              this._layerConfigs[o3.id] = o3;
              const t3 = this._layers[o3.id] = e.aA(o3);
              t3._featureFilter = e.a7(t3.filter), this.keyCache[o3.id] && delete this.keyCache[o3.id];
            }
            for (const e2 of o2) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            const i2 = e.bk(Object.values(this._layerConfigs), this.keyCache);
            for (const e2 of i2) {
              const t3 = e2.map((e3) => this._layers[e3.id]), o3 = t3[0];
              if ("none" === o3.visibility) continue;
              const i3 = o3.source || "";
              let s2 = this.familiesBySource[i3];
              s2 || (s2 = this.familiesBySource[i3] = {});
              const r2 = o3.sourceLayer || "_geojsonTileLayer";
              let n2 = s2[r2];
              n2 || (n2 = s2[r2] = []), n2.push(t3);
            }
          }
        }
        class o {
          constructor(t2) {
            const o2 = {}, i2 = [];
            for (const e2 in t2) {
              const s3 = t2[e2], r3 = o2[e2] = {};
              for (const e3 in s3) {
                const t3 = s3[+e3];
                if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height) continue;
                const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
                i2.push(o3), r3[e3] = { rect: o3, metrics: t3.metrics };
              }
            }
            const { w: s2, h: r2 } = e.p(i2), n2 = new e.o({ width: s2 || 1, height: r2 || 1 });
            for (const i3 in t2) {
              const s3 = t2[i3];
              for (const t3 in s3) {
                const r3 = s3[+t3];
                if (!r3 || 0 === r3.bitmap.width || 0 === r3.bitmap.height) continue;
                const a2 = o2[i3][t3].rect;
                e.o.copy(r3.bitmap, n2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, r3.bitmap);
              }
            }
            this.image = n2, this.positions = o2;
          }
        }
        e.bl("GlyphAtlas", o);
        class i {
          constructor(t2) {
            this.tileID = new e.S(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.inFlightDependencies = [];
          }
          parse(t2, i2, r2, n2) {
            return e._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.a5();
              const a2 = new e.bm(Object.keys(t2.layers).sort()), l3 = new e.bn(this.tileID, this.promoteId);
              l3.bucketLayerIDs = [];
              const c2 = {}, u2 = { featureIndex: l3, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: r2 }, h2 = i2.familiesBySource[this.source];
              for (const o2 in h2) {
                const i3 = t2.layers[o2];
                if (!i3) continue;
                1 === i3.version && e.w('Vector tile source "'.concat(this.source, '" layer "').concat(o2, '" does not use vector tile spec v2 and therefore may have some rendering errors.'));
                const n3 = a2.encode(o2), d3 = [];
                for (let e2 = 0; e2 < i3.length; e2++) {
                  const t3 = i3.feature(e2), s2 = l3.getId(t3, o2);
                  d3.push({ feature: t3, id: s2, index: e2, sourceLayerIndex: n3 });
                }
                for (const t3 of h2[o2]) {
                  const o3 = t3[0];
                  o3.source !== this.source && e.w("layer.source = ".concat(o3.source, " does not equal this.source = ").concat(this.source)), o3.minzoom && this.zoom < Math.floor(o3.minzoom) || o3.maxzoom && this.zoom >= o3.maxzoom || "none" !== o3.visibility && (s(t3, this.zoom, r2), (c2[o3.id] = o3.createBucket({ index: l3.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(d3, u2, this.tileID.canonical), l3.bucketLayerIDs.push(t3.map((e2) => e2.id)));
                }
              }
              const d2 = e.aF(u2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
              this.inFlightDependencies.forEach((e2) => null == e2 ? void 0 : e2.abort()), this.inFlightDependencies = [];
              let f2 = Promise.resolve({});
              if (Object.keys(d2).length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), f2 = n2.sendAsync({ type: "GG", data: { stacks: d2, source: this.source, tileID: this.tileID, type: "glyphs" } }, e2);
              }
              const g2 = Object.keys(u2.iconDependencies);
              let p2 = Promise.resolve({});
              if (g2.length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), p2 = n2.sendAsync({ type: "GI", data: { icons: g2, source: this.source, tileID: this.tileID, type: "icons" } }, e2);
              }
              const m2 = Object.keys(u2.patternDependencies);
              let y3 = Promise.resolve({});
              if (m2.length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), y3 = n2.sendAsync({ type: "GI", data: { icons: m2, source: this.source, tileID: this.tileID, type: "patterns" } }, e2);
              }
              const [v2, w2, x2] = yield Promise.all([f2, p2, y3]), b2 = new o(v2), S2 = new e.bo(w2, x2);
              for (const t3 in c2) {
                const o2 = c2[t3];
                o2 instanceof e.a6 ? (s(o2.layers, this.zoom, r2), e.bp({ bucket: o2, glyphMap: v2, glyphPositions: b2.positions, imageMap: w2, imagePositions: S2.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : o2.hasPattern && (o2 instanceof e.bq || o2 instanceof e.br || o2 instanceof e.bs) && (s(o2.layers, this.zoom, r2), o2.addFeatures(u2, this.tileID.canonical, S2.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(c2).filter((e2) => !e2.isEmpty()), featureIndex: l3, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b2.image, imageAtlas: S2, glyphMap: this.returnDependencies ? v2 : null, iconMap: this.returnDependencies ? w2 : null, glyphPositions: this.returnDependencies ? b2.positions : null };
            });
          }
        }
        function s(t2, o2, i2) {
          const s2 = new e.z(o2);
          for (const e2 of t2) e2.recalculate(s2, i2);
        }
        class r {
          constructor(e2, t2, o2) {
            this.actor = e2, this.layerIndex = t2, this.availableImages = o2, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(t2, o2) {
            return e._(this, void 0, void 0, function* () {
              const i2 = yield e.l(t2.request, o2);
              try {
                return { vectorTile: new e.bt.VectorTile(new e.bu(i2.data)), rawData: i2.data, cacheControl: i2.cacheControl, expires: i2.expires };
              } catch (e2) {
                const o3 = new Uint8Array(i2.data);
                let s2 = "Unable to parse the tile at ".concat(t2.request.url, ", ");
                throw s2 += 31 === o3[0] && 139 === o3[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : "got error: ".concat(e2.message), new Error(s2);
              }
            });
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const o2 = t2.uid, s2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.bv(t2.request), r2 = new i(t2);
              this.loading[o2] = r2;
              const n2 = new AbortController();
              r2.abort = n2;
              try {
                const i2 = yield this.loadVectorTile(t2, n2);
                if (delete this.loading[o2], !i2) return null;
                const a2 = i2.rawData, l3 = {};
                i2.expires && (l3.expires = i2.expires), i2.cacheControl && (l3.cacheControl = i2.cacheControl);
                const c2 = {};
                if (s2) {
                  const e2 = s2.finish();
                  e2 && (c2.resourceTiming = JSON.parse(JSON.stringify(e2)));
                }
                r2.vectorTile = i2.vectorTile;
                const u2 = r2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
                this.loaded[o2] = r2, this.fetching[o2] = { rawTileData: a2, cacheControl: l3, resourceTiming: c2 };
                try {
                  const t3 = yield u2;
                  return e.e({ rawTileData: a2.slice(0) }, t3, l3, c2);
                } finally {
                  delete this.fetching[o2];
                }
              } catch (e2) {
                throw delete this.loading[o2], r2.status = "done", this.loaded[o2] = r2, e2;
              }
            });
          }
          reloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const o2 = t2.uid;
              if (!this.loaded || !this.loaded[o2]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const i2 = this.loaded[o2];
              if (i2.showCollisionBoxes = t2.showCollisionBoxes, "parsing" === i2.status) {
                const t3 = yield i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
                let s2;
                if (this.fetching[o2]) {
                  const { rawTileData: i3, cacheControl: r2, resourceTiming: n2 } = this.fetching[o2];
                  delete this.fetching[o2], s2 = e.e({ rawTileData: i3.slice(0) }, t3, r2, n2);
                } else s2 = t3;
                return s2;
              }
              if ("done" === i2.status && i2.vectorTile) return i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
            });
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = this.loading, o2 = t2.uid;
              e2 && e2[o2] && e2[o2].abort && (e2[o2].abort.abort(), delete e2[o2]);
            });
          }
          removeTile(t2) {
            return e._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[t2.uid] && delete this.loaded[t2.uid];
            });
          }
        }
        class n {
          constructor() {
            this.loaded = {};
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const { uid: o2, encoding: i2, rawImageData: s2, redFactor: r2, greenFactor: n2, blueFactor: a2, baseShift: l3 } = t2, c2 = s2.width + 2, u2 = s2.height + 2, h2 = e.b(s2) ? new e.R({ width: c2, height: u2 }, yield e.bw(s2, -1, -1, c2, u2)) : s2, d2 = new e.bx(o2, h2, i2, r2, n2, a2, l3);
              return this.loaded = this.loaded || {}, this.loaded[o2] = d2, d2;
            });
          }
          removeTile(e2) {
            const t2 = this.loaded, o2 = e2.uid;
            t2 && t2[o2] && delete t2[o2];
          }
        }
        function a(e2, t2) {
          if (0 !== e2.length) {
            l2(e2[0], t2);
            for (var o2 = 1; o2 < e2.length; o2++) l2(e2[o2], !t2);
          }
        }
        function l2(e2, t2) {
          for (var o2 = 0, i2 = 0, s2 = 0, r2 = e2.length, n2 = r2 - 1; s2 < r2; n2 = s2++) {
            var a2 = (e2[s2][0] - e2[n2][0]) * (e2[n2][1] + e2[s2][1]), l3 = o2 + a2;
            i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l3 + a2 : a2 - l3 + o2, o2 = l3;
          }
          o2 + i2 >= 0 != !!t2 && e2.reverse();
        }
        var c = e.by(function e2(t2, o2) {
          var i2, s2 = t2 && t2.type;
          if ("FeatureCollection" === s2) for (i2 = 0; i2 < t2.features.length; i2++) e2(t2.features[i2], o2);
          else if ("GeometryCollection" === s2) for (i2 = 0; i2 < t2.geometries.length; i2++) e2(t2.geometries[i2], o2);
          else if ("Feature" === s2) e2(t2.geometry, o2);
          else if ("Polygon" === s2) a(t2.coordinates, o2);
          else if ("MultiPolygon" === s2) for (i2 = 0; i2 < t2.coordinates.length; i2++) a(t2.coordinates[i2], o2);
          return t2;
        });
        const u = e.bt.VectorTileFeature.prototype.toGeoJSON;
        var h = { exports: {} }, d = e.bz, f = e.bt.VectorTileFeature, g = p;
        function p(e2, t2) {
          this.options = t2 || {}, this.features = e2, this.length = e2.length;
        }
        function m(e2, t2) {
          this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
        }
        p.prototype.feature = function(e2) {
          return new m(this.features[e2], this.options.extent);
        }, m.prototype.loadGeometry = function() {
          var e2 = this.rawGeometry;
          this.geometry = [];
          for (var t2 = 0; t2 < e2.length; t2++) {
            for (var o2 = e2[t2], i2 = [], s2 = 0; s2 < o2.length; s2++) i2.push(new d(o2[s2][0], o2[s2][1]));
            this.geometry.push(i2);
          }
          return this.geometry;
        }, m.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t2 = 1 / 0, o2 = -1 / 0, i2 = 1 / 0, s2 = -1 / 0, r2 = 0; r2 < e2.length; r2++) for (var n2 = e2[r2], a2 = 0; a2 < n2.length; a2++) {
            var l3 = n2[a2];
            t2 = Math.min(t2, l3.x), o2 = Math.max(o2, l3.x), i2 = Math.min(i2, l3.y), s2 = Math.max(s2, l3.y);
          }
          return [t2, i2, o2, s2];
        }, m.prototype.toGeoJSON = f.prototype.toGeoJSON;
        var y2 = e.bA, v = g;
        function w(e2) {
          var t2 = new y2();
          return function(e3, t3) {
            for (var o2 in e3.layers) t3.writeMessage(3, x, e3.layers[o2]);
          }(e2, t2), t2.finish();
        }
        function x(e2, t2) {
          var o2;
          t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
          var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (o2 = 0; o2 < e2.length; o2++) i2.feature = e2.feature(o2), t2.writeMessage(2, b, i2);
          var s2 = i2.keys;
          for (o2 = 0; o2 < s2.length; o2++) t2.writeStringField(3, s2[o2]);
          var r2 = i2.values;
          for (o2 = 0; o2 < r2.length; o2++) t2.writeMessage(4, P, r2[o2]);
        }
        function b(e2, t2) {
          var o2 = e2.feature;
          void 0 !== o2.id && t2.writeVarintField(1, o2.id), t2.writeMessage(2, S, e2), t2.writeVarintField(3, o2.type), t2.writeMessage(4, I, o2);
        }
        function S(e2, t2) {
          var o2 = e2.feature, i2 = e2.keys, s2 = e2.values, r2 = e2.keycache, n2 = e2.valuecache;
          for (var a2 in o2.properties) {
            var l3 = o2.properties[a2], c2 = r2[a2];
            if (null !== l3) {
              void 0 === c2 && (i2.push(a2), r2[a2] = c2 = i2.length - 1), t2.writeVarint(c2);
              var u2 = typeof l3;
              "string" !== u2 && "boolean" !== u2 && "number" !== u2 && (l3 = JSON.stringify(l3));
              var h2 = u2 + ":" + l3, d2 = n2[h2];
              void 0 === d2 && (s2.push(l3), n2[h2] = d2 = s2.length - 1), t2.writeVarint(d2);
            }
          }
        }
        function _(e2, t2) {
          return (t2 << 3) + (7 & e2);
        }
        function M2(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function I(e2, t2) {
          for (var o2 = e2.loadGeometry(), i2 = e2.type, s2 = 0, r2 = 0, n2 = o2.length, a2 = 0; a2 < n2; a2++) {
            var l3 = o2[a2], c2 = 1;
            1 === i2 && (c2 = l3.length), t2.writeVarint(_(1, c2));
            for (var u2 = 3 === i2 ? l3.length - 1 : l3.length, h2 = 0; h2 < u2; h2++) {
              1 === h2 && 1 !== i2 && t2.writeVarint(_(2, u2 - 1));
              var d2 = l3[h2].x - s2, f2 = l3[h2].y - r2;
              t2.writeVarint(M2(d2)), t2.writeVarint(M2(f2)), s2 += d2, r2 += f2;
            }
            3 === i2 && t2.writeVarint(_(7, 1));
          }
        }
        function P(e2, t2) {
          var o2 = typeof e2;
          "string" === o2 ? t2.writeStringField(1, e2) : "boolean" === o2 ? t2.writeBooleanField(7, e2) : "number" === o2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
        }
        h.exports = w, h.exports.fromVectorTileJs = w, h.exports.fromGeojsonVt = function(e2, t2) {
          t2 = t2 || {};
          var o2 = {};
          for (var i2 in e2) o2[i2] = new v(e2[i2].features, t2), o2[i2].name = i2, o2[i2].version = t2.version, o2[i2].extent = t2.extent;
          return w({ layers: o2 });
        }, h.exports.GeoJSONWrapper = v;
        var k = e.by(h.exports);
        const T = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, D = Math.fround || (C2 = new Float32Array(1), (e2) => (C2[0] = +e2, C2[0]));
        var C2;
        const L2 = 3, O = 5, F = 6;
        class z2 {
          constructor(e2) {
            this.options = Object.assign(Object.create(T), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e2) {
            const { log: t2, minZoom: o2, maxZoom: i2 } = this.options;
            t2 && console.time("total time");
            const s2 = "prepare ".concat(e2.length, " points");
            t2 && console.time(s2), this.points = e2;
            const r2 = [];
            for (let t3 = 0; t3 < e2.length; t3++) {
              const o3 = e2[t3];
              if (!o3.geometry) continue;
              const [i3, s3] = o3.geometry.coordinates, n3 = D(G(i3)), a2 = D(j(s3));
              r2.push(n3, a2, 1 / 0, t3, -1, 1), this.options.reduce && r2.push(0);
            }
            let n2 = this.trees[i2 + 1] = this._createTree(r2);
            t2 && console.timeEnd(s2);
            for (let e3 = i2; e3 >= o2; e3--) {
              const o3 = +Date.now();
              n2 = this.trees[e3] = this._createTree(this._cluster(n2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, n2.numItems, +Date.now() - o3);
            }
            return t2 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t2) {
            let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
            const i2 = Math.max(-90, Math.min(90, e2[1]));
            let s2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
            const r2 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360) o2 = -180, s2 = 180;
            else if (o2 > s2) {
              const e3 = this.getClusters([o2, i2, 180, r2], t2), n3 = this.getClusters([-180, i2, s2, r2], t2);
              return e3.concat(n3);
            }
            const n2 = this.trees[this._limitZoom(t2)], a2 = n2.range(G(o2), j(r2), G(s2), j(i2)), l3 = n2.data, c2 = [];
            for (const e3 of a2) {
              const t3 = this.stride * e3;
              c2.push(l3[t3 + O] > 1 ? A2(l3, t3, this.clusterProps) : this.points[l3[t3 + L2]]);
            }
            return c2;
          }
          getChildren(e2) {
            const t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", s2 = this.trees[o2];
            if (!s2) throw new Error(i2);
            const r2 = s2.data;
            if (t2 * this.stride >= r2.length) throw new Error(i2);
            const n2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = s2.within(r2[t2 * this.stride], r2[t2 * this.stride + 1], n2), l3 = [];
            for (const t3 of a2) {
              const o3 = t3 * this.stride;
              r2[o3 + 4] === e2 && l3.push(r2[o3 + O] > 1 ? A2(r2, o3, this.clusterProps) : this.points[r2[o3 + L2]]);
            }
            if (0 === l3.length) throw new Error(i2);
            return l3;
          }
          getLeaves(e2, t2, o2) {
            const i2 = [];
            return this._appendLeaves(i2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
          }
          getTile(e2, t2, o2) {
            const i2 = this.trees[this._limitZoom(e2)], s2 = Math.pow(2, e2), { extent: r2, radius: n2 } = this.options, a2 = n2 / r2, l3 = (o2 - a2) / s2, c2 = (o2 + 1 + a2) / s2, u2 = { features: [] };
            return this._addTileFeatures(i2.range((t2 - a2) / s2, l3, (t2 + 1 + a2) / s2, c2), i2.data, t2, o2, s2, u2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / s2, l3, 1, c2), i2.data, s2, o2, s2, u2), t2 === s2 - 1 && this._addTileFeatures(i2.range(0, l3, a2 / s2, c2), i2.data, -1, o2, s2, u2), u2.features.length ? u2 : null;
          }
          getClusterExpansionZoom(e2) {
            let t2 = this._getOriginZoom(e2) - 1;
            for (; t2 <= this.options.maxZoom; ) {
              const o2 = this.getChildren(e2);
              if (t2++, 1 !== o2.length) break;
              e2 = o2[0].properties.cluster_id;
            }
            return t2;
          }
          _appendLeaves(e2, t2, o2, i2, s2) {
            const r2 = this.getChildren(t2);
            for (const t3 of r2) {
              const r3 = t3.properties;
              if (r3 && r3.cluster ? s2 + r3.point_count <= i2 ? s2 += r3.point_count : s2 = this._appendLeaves(e2, r3.cluster_id, o2, i2, s2) : s2 < i2 ? s2++ : e2.push(t3), e2.length === o2) break;
            }
            return s2;
          }
          _createTree(t2) {
            const o2 = new e.av(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e2 = 0; e2 < t2.length; e2 += this.stride) o2.add(t2[e2], t2[e2 + 1]);
            return o2.finish(), o2.data = t2, o2;
          }
          _addTileFeatures(e2, t2, o2, i2, s2, r2) {
            for (const n2 of e2) {
              const e3 = n2 * this.stride, a2 = t2[e3 + O] > 1;
              let l3, c2, u2;
              if (a2) l3 = E(t2, e3, this.clusterProps), c2 = t2[e3], u2 = t2[e3 + 1];
              else {
                const o3 = this.points[t2[e3 + L2]];
                l3 = o3.properties;
                const [i3, s3] = o3.geometry.coordinates;
                c2 = G(i3), u2 = j(s3);
              }
              const h2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * s2 - o2)), Math.round(this.options.extent * (u2 * s2 - i2))]], tags: l3 };
              let d2;
              d2 = a2 || this.options.generateId ? t2[e3 + L2] : this.points[t2[e3 + L2]].id, void 0 !== d2 && (h2.id = d2), r2.features.push(h2);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t2) {
            const { radius: o2, extent: i2, reduce: s2, minPoints: r2 } = this.options, n2 = o2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l3 = [], c2 = this.stride;
            for (let o3 = 0; o3 < a2.length; o3 += c2) {
              if (a2[o3 + 2] <= t2) continue;
              a2[o3 + 2] = t2;
              const i3 = a2[o3], u2 = a2[o3 + 1], h2 = e2.within(a2[o3], a2[o3 + 1], n2), d2 = a2[o3 + O];
              let f2 = d2;
              for (const e3 of h2) {
                const o4 = e3 * c2;
                a2[o4 + 2] > t2 && (f2 += a2[o4 + O]);
              }
              if (f2 > d2 && f2 >= r2) {
                let e3, r3 = i3 * d2, n3 = u2 * d2, g2 = -1;
                const p2 = ((o3 / c2 | 0) << 5) + (t2 + 1) + this.points.length;
                for (const i4 of h2) {
                  const l4 = i4 * c2;
                  if (a2[l4 + 2] <= t2) continue;
                  a2[l4 + 2] = t2;
                  const u3 = a2[l4 + O];
                  r3 += a2[l4] * u3, n3 += a2[l4 + 1] * u3, a2[l4 + 4] = p2, s2 && (e3 || (e3 = this._map(a2, o3, true), g2 = this.clusterProps.length, this.clusterProps.push(e3)), s2(e3, this._map(a2, l4)));
                }
                a2[o3 + 4] = p2, l3.push(r3 / f2, n3 / f2, 1 / 0, p2, -1, f2), s2 && l3.push(g2);
              } else {
                for (let e3 = 0; e3 < c2; e3++) l3.push(a2[o3 + e3]);
                if (f2 > 1) for (const e3 of h2) {
                  const o4 = e3 * c2;
                  if (!(a2[o4 + 2] <= t2)) {
                    a2[o4 + 2] = t2;
                    for (let e4 = 0; e4 < c2; e4++) l3.push(a2[o4 + e4]);
                  }
                }
              }
            }
            return l3;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t2, o2) {
            if (e2[t2 + O] > 1) {
              const i3 = this.clusterProps[e2[t2 + F]];
              return o2 ? Object.assign({}, i3) : i3;
            }
            const i2 = this.points[e2[t2 + L2]].properties, s2 = this.options.map(i2);
            return o2 && s2 === i2 ? Object.assign({}, s2) : s2;
          }
        }
        function A2(e2, t2, o2) {
          return { type: "Feature", id: e2[t2 + L2], properties: E(e2, t2, o2), geometry: { type: "Point", coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), R(e2[t2 + 1])] } };
          var i2;
        }
        function E(e2, t2, o2) {
          const i2 = e2[t2 + O], s2 = i2 >= 1e4 ? "".concat(Math.round(i2 / 1e3), "k") : i2 >= 1e3 ? Math.round(i2 / 100) / 10 + "k" : i2, r2 = e2[t2 + F], n2 = -1 === r2 ? {} : Object.assign({}, o2[r2]);
          return Object.assign(n2, { cluster: true, cluster_id: e2[t2 + L2], point_count: i2, point_count_abbreviated: s2 });
        }
        function G(e2) {
          return e2 / 360 + 0.5;
        }
        function j(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
        }
        function R(e2) {
          const t2 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
        }
        function Z(e2, t2, o2, i2) {
          let s2 = i2;
          const r2 = t2 + (o2 - t2 >> 1);
          let n2, a2 = o2 - t2;
          const l3 = e2[t2], c2 = e2[t2 + 1], u2 = e2[o2], h2 = e2[o2 + 1];
          for (let i3 = t2 + 3; i3 < o2; i3 += 3) {
            const t3 = N(e2[i3], e2[i3 + 1], l3, c2, u2, h2);
            if (t3 > s2) n2 = i3, s2 = t3;
            else if (t3 === s2) {
              const e3 = Math.abs(i3 - r2);
              e3 < a2 && (n2 = i3, a2 = e3);
            }
          }
          s2 > i2 && (n2 - t2 > 3 && Z(e2, t2, n2, i2), e2[n2 + 2] = s2, o2 - n2 > 3 && Z(e2, n2, o2, i2));
        }
        function N(e2, t2, o2, i2, s2, r2) {
          let n2 = s2 - o2, a2 = r2 - i2;
          if (0 !== n2 || 0 !== a2) {
            const l3 = ((e2 - o2) * n2 + (t2 - i2) * a2) / (n2 * n2 + a2 * a2);
            l3 > 1 ? (o2 = s2, i2 = r2) : l3 > 0 && (o2 += n2 * l3, i2 += a2 * l3);
          }
          return n2 = e2 - o2, a2 = t2 - i2, n2 * n2 + a2 * a2;
        }
        function J2(e2, t2, o2, i2) {
          const s2 = { id: null == e2 ? null : e2, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if ("Point" === t2 || "MultiPoint" === t2 || "LineString" === t2) W2(s2, o2);
          else if ("Polygon" === t2) W2(s2, o2[0]);
          else if ("MultiLineString" === t2) for (const e3 of o2) W2(s2, e3);
          else if ("MultiPolygon" === t2) for (const e3 of o2) W2(s2, e3[0]);
          return s2;
        }
        function W2(e2, t2) {
          for (let o2 = 0; o2 < t2.length; o2 += 3) e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
        }
        function Y(e2, t2, o2, i2) {
          if (!t2.geometry) return;
          const s2 = t2.geometry.coordinates;
          if (s2 && 0 === s2.length) return;
          const r2 = t2.geometry.type, n2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2);
          let a2 = [], l3 = t2.id;
          if (o2.promoteId ? l3 = t2.properties[o2.promoteId] : o2.generateId && (l3 = i2 || 0), "Point" === r2) V2(s2, a2);
          else if ("MultiPoint" === r2) for (const e3 of s2) V2(e3, a2);
          else if ("LineString" === r2) X(s2, a2, n2, false);
          else if ("MultiLineString" === r2) {
            if (o2.lineMetrics) {
              for (const o3 of s2) a2 = [], X(o3, a2, n2, false), e2.push(J2(l3, "LineString", a2, t2.properties));
              return;
            }
            q(s2, a2, n2, false);
          } else if ("Polygon" === r2) q(s2, a2, n2, true);
          else {
            if ("MultiPolygon" !== r2) {
              if ("GeometryCollection" === r2) {
                for (const s3 of t2.geometry.geometries) Y(e2, { id: l3, geometry: s3, properties: t2.properties }, o2, i2);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const e3 of s2) {
              const t3 = [];
              q(e3, t3, n2, true), a2.push(t3);
            }
          }
          e2.push(J2(l3, r2, a2, t2.properties));
        }
        function V2(e2, t2) {
          t2.push(H(e2[0]), B(e2[1]), 0);
        }
        function X(e2, t2, o2, i2) {
          let s2, r2, n2 = 0;
          for (let o3 = 0; o3 < e2.length; o3++) {
            const a3 = H(e2[o3][0]), l3 = B(e2[o3][1]);
            t2.push(a3, l3, 0), o3 > 0 && (n2 += i2 ? (s2 * l3 - a3 * r2) / 2 : Math.sqrt(Math.pow(a3 - s2, 2) + Math.pow(l3 - r2, 2))), s2 = a3, r2 = l3;
          }
          const a2 = t2.length - 3;
          t2[2] = 1, Z(t2, 0, a2, o2), t2[a2 + 2] = 1, t2.size = Math.abs(n2), t2.start = 0, t2.end = t2.size;
        }
        function q(e2, t2, o2, i2) {
          for (let s2 = 0; s2 < e2.length; s2++) {
            const r2 = [];
            X(e2[s2], r2, o2, i2), t2.push(r2);
          }
        }
        function H(e2) {
          return e2 / 360 + 0.5;
        }
        function B(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
        }
        function U2(e2, t2, o2, i2, s2, r2, n2, a2) {
          if (i2 /= t2, r2 >= (o2 /= t2) && n2 < i2) return e2;
          if (n2 < o2 || r2 >= i2) return null;
          const l3 = [];
          for (const t3 of e2) {
            const e3 = t3.geometry;
            let r3 = t3.type;
            const n3 = 0 === s2 ? t3.minX : t3.minY, c2 = 0 === s2 ? t3.maxX : t3.maxY;
            if (n3 >= o2 && c2 < i2) {
              l3.push(t3);
              continue;
            }
            if (c2 < o2 || n3 >= i2) continue;
            let u2 = [];
            if ("Point" === r3 || "MultiPoint" === r3) $(e3, u2, o2, i2, s2);
            else if ("LineString" === r3) K(e3, u2, o2, i2, s2, false, a2.lineMetrics);
            else if ("MultiLineString" === r3) ee2(e3, u2, o2, i2, s2, false);
            else if ("Polygon" === r3) ee2(e3, u2, o2, i2, s2, true);
            else if ("MultiPolygon" === r3) for (const t4 of e3) {
              const e4 = [];
              ee2(t4, e4, o2, i2, s2, true), e4.length && u2.push(e4);
            }
            if (u2.length) {
              if (a2.lineMetrics && "LineString" === r3) {
                for (const e4 of u2) l3.push(J2(t3.id, r3, e4, t3.tags));
                continue;
              }
              "LineString" !== r3 && "MultiLineString" !== r3 || (1 === u2.length ? (r3 = "LineString", u2 = u2[0]) : r3 = "MultiLineString"), "Point" !== r3 && "MultiPoint" !== r3 || (r3 = 3 === u2.length ? "Point" : "MultiPoint"), l3.push(J2(t3.id, r3, u2, t3.tags));
            }
          }
          return l3.length ? l3 : null;
        }
        function $(e2, t2, o2, i2, s2) {
          for (let r2 = 0; r2 < e2.length; r2 += 3) {
            const n2 = e2[r2 + s2];
            n2 >= o2 && n2 <= i2 && te(t2, e2[r2], e2[r2 + 1], e2[r2 + 2]);
          }
        }
        function K(e2, t2, o2, i2, s2, r2, n2) {
          let a2 = Q2(e2);
          const l3 = 0 === s2 ? oe : ie;
          let c2, u2, h2 = e2.start;
          for (let d3 = 0; d3 < e2.length - 3; d3 += 3) {
            const f3 = e2[d3], g3 = e2[d3 + 1], p3 = e2[d3 + 2], m2 = e2[d3 + 3], y3 = e2[d3 + 4], v2 = 0 === s2 ? f3 : g3, w2 = 0 === s2 ? m2 : y3;
            let x2 = false;
            n2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(g3 - y3, 2))), v2 < o2 ? w2 > o2 && (u2 = l3(a2, f3, g3, m2, y3, o2), n2 && (a2.start = h2 + c2 * u2)) : v2 > i2 ? w2 < i2 && (u2 = l3(a2, f3, g3, m2, y3, i2), n2 && (a2.start = h2 + c2 * u2)) : te(a2, f3, g3, p3), w2 < o2 && v2 >= o2 && (u2 = l3(a2, f3, g3, m2, y3, o2), x2 = true), w2 > i2 && v2 <= i2 && (u2 = l3(a2, f3, g3, m2, y3, i2), x2 = true), !r2 && x2 && (n2 && (a2.end = h2 + c2 * u2), t2.push(a2), a2 = Q2(e2)), n2 && (h2 += c2);
          }
          let d2 = e2.length - 3;
          const f2 = e2[d2], g2 = e2[d2 + 1], p2 = 0 === s2 ? f2 : g2;
          p2 >= o2 && p2 <= i2 && te(a2, f2, g2, e2[d2 + 2]), d2 = a2.length - 3, r2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && te(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
        }
        function Q2(e2) {
          const t2 = [];
          return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
        }
        function ee2(e2, t2, o2, i2, s2, r2) {
          for (const n2 of e2) K(n2, t2, o2, i2, s2, r2, false);
        }
        function te(e2, t2, o2, i2) {
          e2.push(t2, o2, i2);
        }
        function oe(e2, t2, o2, i2, s2, r2) {
          const n2 = (r2 - t2) / (i2 - t2);
          return te(e2, r2, o2 + (s2 - o2) * n2, 1), n2;
        }
        function ie(e2, t2, o2, i2, s2, r2) {
          const n2 = (r2 - o2) / (s2 - o2);
          return te(e2, t2 + (i2 - t2) * n2, r2, 1), n2;
        }
        function se2(e2, t2) {
          const o2 = [];
          for (let i2 = 0; i2 < e2.length; i2++) {
            const s2 = e2[i2], r2 = s2.type;
            let n2;
            if ("Point" === r2 || "MultiPoint" === r2 || "LineString" === r2) n2 = re2(s2.geometry, t2);
            else if ("MultiLineString" === r2 || "Polygon" === r2) {
              n2 = [];
              for (const e3 of s2.geometry) n2.push(re2(e3, t2));
            } else if ("MultiPolygon" === r2) {
              n2 = [];
              for (const e3 of s2.geometry) {
                const o3 = [];
                for (const i3 of e3) o3.push(re2(i3, t2));
                n2.push(o3);
              }
            }
            o2.push(J2(s2.id, r2, n2, s2.tags));
          }
          return o2;
        }
        function re2(e2, t2) {
          const o2 = [];
          o2.size = e2.size, void 0 !== e2.start && (o2.start = e2.start, o2.end = e2.end);
          for (let i2 = 0; i2 < e2.length; i2 += 3) o2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
          return o2;
        }
        function ne2(e2, t2) {
          if (e2.transformed) return e2;
          const o2 = 1 << e2.z, i2 = e2.x, s2 = e2.y;
          for (const r2 of e2.features) {
            const e3 = r2.geometry, n2 = r2.type;
            if (r2.geometry = [], 1 === n2) for (let n3 = 0; n3 < e3.length; n3 += 2) r2.geometry.push(ae2(e3[n3], e3[n3 + 1], t2, o2, i2, s2));
            else for (let n3 = 0; n3 < e3.length; n3++) {
              const a2 = [];
              for (let r3 = 0; r3 < e3[n3].length; r3 += 2) a2.push(ae2(e3[n3][r3], e3[n3][r3 + 1], t2, o2, i2, s2));
              r2.geometry.push(a2);
            }
          }
          return e2.transformed = true, e2;
        }
        function ae2(e2, t2, o2, i2, s2, r2) {
          return [Math.round(o2 * (e2 * i2 - s2)), Math.round(o2 * (t2 * i2 - r2))];
        }
        function le(e2, t2, o2, i2, s2) {
          const r2 = t2 === s2.maxZoom ? 0 : s2.tolerance / ((1 << t2) * s2.extent), n2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: o2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const t3 of e2) ce2(n2, t3, r2, s2);
          return n2;
        }
        function ce2(e2, t2, o2, i2) {
          const s2 = t2.geometry, r2 = t2.type, n2 = [];
          if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), "Point" === r2 || "MultiPoint" === r2) for (let t3 = 0; t3 < s2.length; t3 += 3) n2.push(s2[t3], s2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === r2) ue2(n2, s2, e2, o2, false, false);
          else if ("MultiLineString" === r2 || "Polygon" === r2) for (let t3 = 0; t3 < s2.length; t3++) ue2(n2, s2[t3], e2, o2, "Polygon" === r2, 0 === t3);
          else if ("MultiPolygon" === r2) for (let t3 = 0; t3 < s2.length; t3++) {
            const i3 = s2[t3];
            for (let t4 = 0; t4 < i3.length; t4++) ue2(n2, i3[t4], e2, o2, true, 0 === t4);
          }
          if (n2.length) {
            let o3 = t2.tags || null;
            if ("LineString" === r2 && i2.lineMetrics) {
              o3 = {};
              for (const e3 in t2.tags) o3[e3] = t2.tags[e3];
              o3.mapbox_clip_start = s2.start / s2.size, o3.mapbox_clip_end = s2.end / s2.size;
            }
            const a2 = { geometry: n2, type: "Polygon" === r2 || "MultiPolygon" === r2 ? 3 : "LineString" === r2 || "MultiLineString" === r2 ? 2 : 1, tags: o3 };
            null !== t2.id && (a2.id = t2.id), e2.features.push(a2);
          }
        }
        function ue2(e2, t2, o2, i2, s2, r2) {
          const n2 = i2 * i2;
          if (i2 > 0 && t2.size < (s2 ? n2 : i2)) return void (o2.numPoints += t2.length / 3);
          const a2 = [];
          for (let e3 = 0; e3 < t2.length; e3 += 3) (0 === i2 || t2[e3 + 2] > n2) && (o2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), o2.numPoints++;
          s2 && function(e3, t3) {
            let o3 = 0;
            for (let t4 = 0, i3 = e3.length, s3 = i3 - 2; t4 < i3; s3 = t4, t4 += 2) o3 += (e3[t4] - e3[s3]) * (e3[t4 + 1] + e3[s3 + 1]);
            if (o3 > 0 === t3) for (let t4 = 0, o4 = e3.length; t4 < o4 / 2; t4 += 2) {
              const i3 = e3[t4], s3 = e3[t4 + 1];
              e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = i3, e3[o4 - 1 - t4] = s3;
            }
          }(a2, r2), e2.push(a2);
        }
        const he2 = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class de2 {
          constructor(e2, t2) {
            const o2 = (t2 = this.options = function(e3, t3) {
              for (const o3 in t3) e3[o3] = t3[o3];
              return e3;
            }(Object.create(he2), t2)).debug;
            if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t2.promoteId && t2.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let i2 = function(e3, t3) {
              const o3 = [];
              if ("FeatureCollection" === e3.type) for (let i3 = 0; i3 < e3.features.length; i3++) Y(o3, e3.features[i3], t3, i3);
              else Y(o3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
              return o3;
            }(e2, t2);
            this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
              const o3 = t3.buffer / t3.extent;
              let i3 = e3;
              const s2 = U2(e3, 1, -1 - o3, o3, 0, -1, 2, t3), r2 = U2(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
              return (s2 || r2) && (i3 = U2(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], s2 && (i3 = se2(s2, 1).concat(i3)), r2 && (i3 = i3.concat(se2(r2, -1)))), i3;
            }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(e2, t2, o2, i2, s2, r2, n2) {
            const a2 = [e2, t2, o2, i2], l3 = this.options, c2 = l3.debug;
            for (; a2.length; ) {
              i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
              const u2 = 1 << t2, h2 = fe2(t2, o2, i2);
              let d2 = this.tiles[h2];
              if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[h2] = le(e2, t2, o2, i2, l3), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
                c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
                const e3 = "z".concat(t2);
                this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
              }
              if (d2.source = e2, null == s2) {
                if (t2 === l3.indexMaxZoom || d2.numPoints <= l3.indexMaxPoints) continue;
              } else {
                if (t2 === l3.maxZoom || t2 === s2) continue;
                if (null != s2) {
                  const e3 = s2 - t2;
                  if (o2 !== r2 >> e3 || i2 !== n2 >> e3) continue;
                }
              }
              if (d2.source = null, 0 === e2.length) continue;
              c2 > 1 && console.time("clipping");
              const f2 = 0.5 * l3.buffer / l3.extent, g2 = 0.5 - f2, p2 = 0.5 + f2, m2 = 1 + f2;
              let y3 = null, v2 = null, w2 = null, x2 = null, b2 = U2(e2, u2, o2 - f2, o2 + p2, 0, d2.minX, d2.maxX, l3), S2 = U2(e2, u2, o2 + g2, o2 + m2, 0, d2.minX, d2.maxX, l3);
              e2 = null, b2 && (y3 = U2(b2, u2, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l3), v2 = U2(b2, u2, i2 + g2, i2 + m2, 1, d2.minY, d2.maxY, l3), b2 = null), S2 && (w2 = U2(S2, u2, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l3), x2 = U2(S2, u2, i2 + g2, i2 + m2, 1, d2.minY, d2.maxY, l3), S2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y3 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(w2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(x2 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
            }
          }
          getTile(e2, t2, o2) {
            e2 = +e2, t2 = +t2, o2 = +o2;
            const i2 = this.options, { extent: s2, debug: r2 } = i2;
            if (e2 < 0 || e2 > 24) return null;
            const n2 = 1 << e2, a2 = fe2(e2, t2 = t2 + n2 & n2 - 1, o2);
            if (this.tiles[a2]) return ne2(this.tiles[a2], s2);
            r2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
            let l3, c2 = e2, u2 = t2, h2 = o2;
            for (; !l3 && c2 > 0; ) c2--, u2 >>= 1, h2 >>= 1, l3 = this.tiles[fe2(c2, u2, h2)];
            return l3 && l3.source ? (r2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, u2, h2), console.time("drilling down")), this.splitTile(l3.source, c2, u2, h2, e2, t2, o2), r2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ne2(this.tiles[a2], s2) : null) : null;
          }
        }
        function fe2(e2, t2, o2) {
          return 32 * ((1 << e2) * o2 + t2) + e2;
        }
        function ge2(e2, t2) {
          return t2 ? e2.properties[t2] : e2.id;
        }
        function pe(e2, t2) {
          if (null == e2) return true;
          if ("Feature" === e2.type) return null != ge2(e2, t2);
          if ("FeatureCollection" === e2.type) {
            const o2 = /* @__PURE__ */ new Set();
            for (const i2 of e2.features) {
              const e3 = ge2(i2, t2);
              if (null == e3) return false;
              if (o2.has(e3)) return false;
              o2.add(e3);
            }
            return true;
          }
          return false;
        }
        function me2(e2, t2) {
          const o2 = /* @__PURE__ */ new Map();
          if (null == e2) ;
          else if ("Feature" === e2.type) o2.set(ge2(e2, t2), e2);
          else for (const i2 of e2.features) o2.set(ge2(i2, t2), i2);
          return o2;
        }
        class ye2 extends r {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(t2, o2) {
            return e._(this, void 0, void 0, function* () {
              const o3 = t2.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const i2 = this._geoJSONIndex.getTile(o3.z, o3.x, o3.y);
              if (!i2) return null;
              const s2 = new class {
                constructor(t3) {
                  this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.X, this.length = t3.length, this._features = t3;
                }
                feature(t3) {
                  return new class {
                    constructor(t4) {
                      this._feature = t4, this.extent = e.X, this.type = t4.type, this.properties = t4.tags, "id" in t4 && !isNaN(t4.id) && (this.id = parseInt(t4.id, 10));
                    }
                    loadGeometry() {
                      if (1 === this._feature.type) {
                        const t4 = [];
                        for (const o4 of this._feature.geometry) t4.push([new e.P(o4[0], o4[1])]);
                        return t4;
                      }
                      {
                        const t4 = [];
                        for (const o4 of this._feature.geometry) {
                          const i3 = [];
                          for (const t5 of o4) i3.push(new e.P(t5[0], t5[1]));
                          t4.push(i3);
                        }
                        return t4;
                      }
                    }
                    toGeoJSON(e2, t4, o4) {
                      return u.call(this, e2, t4, o4);
                    }
                  }(this._features[t3]);
                }
              }(i2.features);
              let r2 = k(s2);
              return 0 === r2.byteOffset && r2.byteLength === r2.buffer.byteLength || (r2 = new Uint8Array(r2)), { vectorTile: s2, rawData: r2.buffer };
            });
          }
          loadData(t2) {
            return e._(this, void 0, void 0, function* () {
              var o2;
              null === (o2 = this._pendingRequest) || void 0 === o2 || o2.abort();
              const i2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.bv(t2.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(t2, this._pendingRequest), this._geoJSONIndex = t2.cluster ? new z2(function({ superclusterOptions: t3, clusterProperties: o4 }) {
                  if (!o4 || !t3) return t3;
                  const i3 = {}, s3 = {}, r2 = { accumulated: null, zoom: 0 }, n2 = { properties: null }, a2 = Object.keys(o4);
                  for (const t4 of a2) {
                    const [r3, n3] = o4[t4], a3 = e.bC(n3), l3 = e.bC("string" == typeof r3 ? [r3, ["accumulated"], ["get", t4]] : r3);
                    i3[t4] = a3.value, s3[t4] = l3.value;
                  }
                  return t3.map = (e2) => {
                    n2.properties = e2;
                    const t4 = {};
                    for (const e3 of a2) t4[e3] = i3[e3].evaluate(r2, n2);
                    return t4;
                  }, t3.reduce = (e2, t4) => {
                    n2.properties = t4;
                    for (const t5 of a2) r2.accumulated = e2[t5], e2[t5] = s3[t5].evaluate(r2, n2);
                  }, t3;
                }(t2)).load((yield this._pendingData).features) : (s2 = yield this._pendingData, new de2(s2, t2.geojsonVtOptions)), this.loaded = {};
                const o3 = {};
                if (i2) {
                  const e2 = i2.finish();
                  e2 && (o3.resourceTiming = {}, o3.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e2)));
                }
                return o3;
              } catch (t3) {
                if (delete this._pendingRequest, e.bB(t3)) return { abandoned: true };
                throw t3;
              }
              var s2;
            });
          }
          getData() {
            return e._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(e2) {
            const t2 = this.loaded;
            return t2 && t2[e2.uid] ? super.reloadTile(e2) : this.loadTile(e2);
          }
          loadAndProcessGeoJSON(t2, o2) {
            return e._(this, void 0, void 0, function* () {
              let i2 = yield this.loadGeoJSON(t2, o2);
              if (delete this._pendingRequest, "object" != typeof i2) throw new Error("Input data given to '".concat(t2.source, "' is not a valid GeoJSON object."));
              if (c(i2, true), t2.filter) {
                const o3 = e.bC(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if ("error" === o3.result) throw new Error(o3.value.map((e2) => "".concat(e2.key, ": ").concat(e2.message)).join(", "));
                const s2 = i2.features.filter((e2) => o3.value.evaluate({ zoom: 0 }, e2));
                i2 = { type: "FeatureCollection", features: s2 };
              }
              return i2;
            });
          }
          loadGeoJSON(t2, o2) {
            return e._(this, void 0, void 0, function* () {
              const { promoteId: i2 } = t2;
              if (t2.request) {
                const s2 = yield e.h(t2.request, o2);
                return this._dataUpdateable = pe(s2.data, i2) ? me2(s2.data, i2) : void 0, s2.data;
              }
              if ("string" == typeof t2.data) try {
                const e2 = JSON.parse(t2.data);
                return this._dataUpdateable = pe(e2, i2) ? me2(e2, i2) : void 0, e2;
              } catch (e2) {
                throw new Error("Input data given to '".concat(t2.source, "' is not a valid GeoJSON object."));
              }
              if (!t2.dataDiff) throw new Error("Input data given to '".concat(t2.source, "' is not a valid GeoJSON object."));
              if (!this._dataUpdateable) throw new Error("Cannot update existing geojson data in ".concat(t2.source));
              return function(e2, t3, o3) {
                var i3, s2, r2, n2;
                if (t3.removeAll && e2.clear(), t3.remove) for (const o4 of t3.remove) e2.delete(o4);
                if (t3.add) for (const i4 of t3.add) {
                  const t4 = ge2(i4, o3);
                  null != t4 && e2.set(t4, i4);
                }
                if (t3.update) for (const o4 of t3.update) {
                  let t4 = e2.get(o4.id);
                  if (null == t4) continue;
                  const a2 = !o4.removeAllProperties && ((null === (i3 = o4.removeProperties) || void 0 === i3 ? void 0 : i3.length) > 0 || (null === (s2 = o4.addOrUpdateProperties) || void 0 === s2 ? void 0 : s2.length) > 0);
                  if ((o4.newGeometry || o4.removeAllProperties || a2) && (t4 = Object.assign({}, t4), e2.set(o4.id, t4), a2 && (t4.properties = Object.assign({}, t4.properties))), o4.newGeometry && (t4.geometry = o4.newGeometry), o4.removeAllProperties) t4.properties = {};
                  else if ((null === (r2 = o4.removeProperties) || void 0 === r2 ? void 0 : r2.length) > 0) for (const e3 of o4.removeProperties) Object.prototype.hasOwnProperty.call(t4.properties, e3) && delete t4.properties[e3];
                  if ((null === (n2 = o4.addOrUpdateProperties) || void 0 === n2 ? void 0 : n2.length) > 0) for (const { key: e3, value: i4 } of o4.addOrUpdateProperties) t4.properties[e3] = i4;
                }
              }(this._dataUpdateable, t2.dataDiff, i2), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(t2) {
            return e._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(e2) {
            return this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId);
          }
          getClusterChildren(e2) {
            return this._geoJSONIndex.getChildren(e2.clusterId);
          }
          getClusterLeaves(e2) {
            return this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset);
          }
        }
        class ve {
          constructor(t2) {
            this.self = t2, this.actor = new e.F(t2), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e2, t3) => {
              if (this.externalWorkerSourceTypes[e2]) throw new Error('Worker source with name "'.concat(e2, '" already registered.'));
              this.externalWorkerSourceTypes[e2] = t3;
            }, this.self.addProtocol = e.bi, this.self.removeProtocol = e.bj, this.self.registerRTLTextPlugin = (t3) => {
              if (e.bD.isParsed()) throw new Error("RTL text plugin already registered.");
              e.bD.setMethods(t3);
            }, this.actor.registerMessageHandler("LDT", (e2, t3) => this._getDEMWorkerSource(e2, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RDT", (t3, o2) => e._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(t3, o2.source).removeTile(o2);
            })), this.actor.registerMessageHandler("GCEZ", (t3, o2) => e._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t3, o2.type, o2.source).getClusterExpansionZoom(o2);
            })), this.actor.registerMessageHandler("GCC", (t3, o2) => e._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t3, o2.type, o2.source).getClusterChildren(o2);
            })), this.actor.registerMessageHandler("GCL", (t3, o2) => e._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t3, o2.type, o2.source).getClusterLeaves(o2);
            })), this.actor.registerMessageHandler("LD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadData(t3)), this.actor.registerMessageHandler("GD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).getData()), this.actor.registerMessageHandler("LT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).reloadTile(t3)), this.actor.registerMessageHandler("AT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).abortTile(t3)), this.actor.registerMessageHandler("RMT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).removeTile(t3)), this.actor.registerMessageHandler("RS", (t3, o2) => e._(this, void 0, void 0, function* () {
              if (!this.workerSources[t3] || !this.workerSources[t3][o2.type] || !this.workerSources[t3][o2.type][o2.source]) return;
              const e2 = this.workerSources[t3][o2.type][o2.source];
              delete this.workerSources[t3][o2.type][o2.source], void 0 !== e2.removeSource && e2.removeSource(o2);
            })), this.actor.registerMessageHandler("RM", (t3) => e._(this, void 0, void 0, function* () {
              delete this.layerIndexes[t3], delete this.availableImages[t3], delete this.workerSources[t3], delete this.demWorkerSources[t3];
            })), this.actor.registerMessageHandler("SR", (t3, o2) => e._(this, void 0, void 0, function* () {
              this.referrer = o2;
            })), this.actor.registerMessageHandler("SRPS", (e2, t3) => this._syncRTLPluginState(e2, t3)), this.actor.registerMessageHandler("IS", (t3, o2) => e._(this, void 0, void 0, function* () {
              this.self.importScripts(o2);
            })), this.actor.registerMessageHandler("SI", (e2, t3) => this._setImages(e2, t3)), this.actor.registerMessageHandler("UL", (t3, o2) => e._(this, void 0, void 0, function* () {
              this._getLayerIndex(t3).update(o2.layers, o2.removedIds);
            })), this.actor.registerMessageHandler("SL", (t3, o2) => e._(this, void 0, void 0, function* () {
              this._getLayerIndex(t3).replace(o2);
            }));
          }
          _setImages(t2, o2) {
            return e._(this, void 0, void 0, function* () {
              this.availableImages[t2] = o2;
              for (const e2 in this.workerSources[t2]) {
                const i2 = this.workerSources[t2][e2];
                for (const e3 in i2) i2[e3].availableImages = o2;
              }
            });
          }
          _syncRTLPluginState(t2, o2) {
            return e._(this, void 0, void 0, function* () {
              if (e.bD.isParsed()) return e.bD.getState();
              if ("loading" !== o2.pluginStatus) return e.bD.setState(o2), o2;
              const t3 = o2.pluginURL;
              if (this.self.importScripts(t3), e.bD.isParsed()) {
                const o3 = { pluginStatus: "loaded", pluginURL: t3 };
                return e.bD.setState(o3), o3;
              }
              throw e.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error("RTL Text Plugin failed to import scripts from ".concat(t3));
            });
          }
          _getAvailableImages(e2) {
            let t2 = this.availableImages[e2];
            return t2 || (t2 = []), t2;
          }
          _getLayerIndex(e2) {
            let o2 = this.layerIndexes[e2];
            return o2 || (o2 = this.layerIndexes[e2] = new t()), o2;
          }
          _getWorkerSource(e2, t2, o2) {
            if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][o2]) {
              const i2 = { sendAsync: (t3, o3) => (t3.targetMapId = e2, this.actor.sendAsync(t3, o3)) };
              switch (t2) {
                case "vector":
                  this.workerSources[e2][t2][o2] = new r(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                  break;
                case "geojson":
                  this.workerSources[e2][t2][o2] = new ye2(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                  break;
                default:
                  this.workerSources[e2][t2][o2] = new this.externalWorkerSourceTypes[t2](i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
              }
            }
            return this.workerSources[e2][t2][o2];
          }
          _getDEMWorkerSource(e2, t2) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n()), this.demWorkerSources[e2][t2];
          }
        }
        return e.i(self) && (self.worker = new ve(self)), ve;
      });
      define2("index", ["exports", "./shared"], function(t, e) {
        "use strict";
        var i = "4.7.1";
        let a, s;
        const o = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (t2) => new Promise((i2, a2) => {
          const s2 = requestAnimationFrame(i2);
          t2.signal.addEventListener("abort", () => {
            cancelAnimationFrame(s2), a2(e.c());
          });
        }), getImageData(t2, e2 = 0) {
          return this.getImageCanvasContext(t2).getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
        }, getImageCanvasContext(t2) {
          const e2 = window.document.createElement("canvas"), i2 = e2.getContext("2d", { willReadFrequently: true });
          if (!i2) throw new Error("failed to create canvas 2d context");
          return e2.width = t2.width, e2.height = t2.height, i2.drawImage(t2, 0, 0, t2.width, t2.height), i2;
        }, resolveURL: (t2) => (a || (a = document.createElement("a")), a.href = t2, a.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (null == s && (s = matchMedia("(prefers-reduced-motion: reduce)")), s.matches);
        } };
        class r {
          static testProp(t2) {
            if (!r.docStyle) return t2[0];
            for (let e2 = 0; e2 < t2.length; e2++) if (t2[e2] in r.docStyle) return t2[e2];
            return t2[0];
          }
          static create(t2, e2, i2) {
            const a2 = window.document.createElement(t2);
            return void 0 !== e2 && (a2.className = e2), i2 && i2.appendChild(a2), a2;
          }
          static createNS(t2, e2) {
            return window.document.createElementNS(t2, e2);
          }
          static disableDrag() {
            r.docStyle && r.selectProp && (r.userSelect = r.docStyle[r.selectProp], r.docStyle[r.selectProp] = "none");
          }
          static enableDrag() {
            r.docStyle && r.selectProp && (r.docStyle[r.selectProp] = r.userSelect);
          }
          static setTransform(t2, e2) {
            t2.style[r.transformProp] = e2;
          }
          static addEventListener(t2, e2, i2, a2 = {}) {
            t2.addEventListener(e2, i2, "passive" in a2 ? a2 : a2.capture);
          }
          static removeEventListener(t2, e2, i2, a2 = {}) {
            t2.removeEventListener(e2, i2, "passive" in a2 ? a2 : a2.capture);
          }
          static suppressClickInternal(t2) {
            t2.preventDefault(), t2.stopPropagation(), window.removeEventListener("click", r.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", r.suppressClickInternal, true), window.setTimeout(() => {
              window.removeEventListener("click", r.suppressClickInternal, true);
            }, 0);
          }
          static getScale(t2) {
            const e2 = t2.getBoundingClientRect();
            return { x: e2.width / t2.offsetWidth || 1, y: e2.height / t2.offsetHeight || 1, boundingClientRect: e2 };
          }
          static getPoint(t2, i2, a2) {
            const s2 = i2.boundingClientRect;
            return new e.P((a2.clientX - s2.left) / i2.x - t2.clientLeft, (a2.clientY - s2.top) / i2.y - t2.clientTop);
          }
          static mousePos(t2, e2) {
            const i2 = r.getScale(t2);
            return r.getPoint(t2, i2, e2);
          }
          static touchPos(t2, e2) {
            const i2 = [], a2 = r.getScale(t2);
            for (let s2 = 0; s2 < e2.length; s2++) i2.push(r.getPoint(t2, a2, e2[s2]));
            return i2;
          }
          static mouseButton(t2) {
            return t2.button;
          }
          static remove(t2) {
            t2.parentNode && t2.parentNode.removeChild(t2);
          }
        }
        r.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, r.selectProp = r.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), r.transformProp = r.testProp(["transform", "WebkitTransform"]);
        const n = { supported: false, testSupport: function(t2) {
          !c && h && (u ? d(t2) : l2 = t2);
        } };
        let l2, h, c = false, u = false;
        function d(t2) {
          const e2 = t2.createTexture();
          t2.bindTexture(t2.TEXTURE_2D, e2);
          try {
            if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, h), t2.isContextLost()) return;
            n.supported = true;
          } catch (t3) {
          }
          t2.deleteTexture(e2), c = true;
        }
        var _;
        "undefined" != typeof document && (h = document.createElement("img"), h.onload = () => {
          l2 && d(l2), l2 = null, u = true;
        }, h.onerror = () => {
          c = true, l2 = null;
        }, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(t2) {
          let i2, a2, s2, o2;
          t2.resetRequestQueue = () => {
            i2 = [], a2 = 0, s2 = 0, o2 = {};
          }, t2.addThrottleControl = (t3) => {
            const e2 = s2++;
            return o2[e2] = t3, e2;
          }, t2.removeThrottleControl = (t3) => {
            delete o2[t3], l3();
          }, t2.getImage = (t3, a3, s3 = true) => new Promise((o3, r3) => {
            n.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*"), e.e(t3, { type: "image" }), i2.push({ abortController: a3, requestParameters: t3, supportImageRefresh: s3, state: "queued", onError: (t4) => {
              r3(t4);
            }, onSuccess: (t4) => {
              o3(t4);
            } }), l3();
          });
          const r2 = (t3) => e._(this, void 0, void 0, function* () {
            t3.state = "running";
            const { requestParameters: i3, supportImageRefresh: s3, onError: o3, onSuccess: r3, abortController: n2 } = t3, c2 = false === s3 && !e.i(self) && !e.g(i3.url) && (!i3.headers || Object.keys(i3.headers).reduce((t4, e2) => t4 && "accept" === e2, true));
            a2++;
            const u2 = c2 ? h2(i3, n2) : e.m(i3, n2);
            try {
              const i4 = yield u2;
              delete t3.abortController, t3.state = "completed", i4.data instanceof HTMLImageElement || e.b(i4.data) ? r3(i4) : i4.data && r3({ data: yield (d2 = i4.data, "function" == typeof createImageBitmap ? e.d(d2) : e.f(d2)), cacheControl: i4.cacheControl, expires: i4.expires });
            } catch (e2) {
              delete t3.abortController, o3(e2);
            } finally {
              a2--, l3();
            }
            var d2;
          }), l3 = () => {
            const t3 = (() => {
              for (const t4 of Object.keys(o2)) if (o2[t4]()) return true;
              return false;
            })() ? e.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : e.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let e2 = a2; e2 < t3 && i2.length > 0; e2++) {
              const t4 = i2.shift();
              t4.abortController.signal.aborted ? e2-- : r2(t4);
            }
          }, h2 = (t3, i3) => new Promise((a3, s3) => {
            const o3 = new Image(), r3 = t3.url, n2 = t3.credentials;
            n2 && "include" === n2 ? o3.crossOrigin = "use-credentials" : (n2 && "same-origin" === n2 || !e.s(r3)) && (o3.crossOrigin = "anonymous"), i3.signal.addEventListener("abort", () => {
              o3.src = "", s3(e.c());
            }), o3.fetchPriority = "high", o3.onload = () => {
              o3.onerror = o3.onload = null, a3({ data: o3 });
            }, o3.onerror = () => {
              o3.onerror = o3.onload = null, i3.signal.aborted || s3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, o3.src = r3;
          });
        }(_ || (_ = {})), _.resetRequestQueue();
        class p {
          constructor(t2) {
            this._transformRequestFn = t2;
          }
          transformRequest(t2, e2) {
            return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
          }
          setTransformRequest(t2) {
            this._transformRequestFn = t2;
          }
        }
        function m(t2) {
          var i2 = new e.A(3);
          return i2[0] = t2[0], i2[1] = t2[1], i2[2] = t2[2], i2;
        }
        var f, g = function(t2, e2, i2) {
          return t2[0] = e2[0] - i2[0], t2[1] = e2[1] - i2[1], t2[2] = e2[2] - i2[2], t2;
        };
        f = new e.A(3), e.A != Float32Array && (f[0] = 0, f[1] = 0, f[2] = 0);
        var v = function(t2) {
          var e2 = t2[0], i2 = t2[1];
          return e2 * e2 + i2 * i2;
        };
        function x(t2) {
          const e2 = [];
          if ("string" == typeof t2) e2.push({ id: "default", url: t2 });
          else if (t2 && t2.length > 0) {
            const i2 = [];
            for (const { id: a2, url: s2 } of t2) {
              const t3 = "".concat(a2).concat(s2);
              -1 === i2.indexOf(t3) && (i2.push(t3), e2.push({ id: a2, url: s2 }));
            }
          }
          return e2;
        }
        function y2(t2, e2, i2) {
          const a2 = t2.split("?");
          return a2[0] += "".concat(e2).concat(i2), a2.join("?");
        }
        !function() {
          var t2 = new e.A(2);
          e.A != Float32Array && (t2[0] = 0, t2[1] = 0);
        }();
        class b {
          constructor(t2, e2, i2, a2) {
            this.context = t2, this.format = i2, this.texture = t2.gl.createTexture(), this.update(e2, a2);
          }
          update(t2, i2, a2) {
            const { width: s2, height: o2 } = t2, r2 = !(this.size && this.size[0] === s2 && this.size[1] === o2 || a2), { context: n2 } = this, { gl: l3 } = n2;
            if (this.useMipmap = Boolean(i2 && i2.useMipmap), l3.bindTexture(l3.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l3.RGBA && (!i2 || false !== i2.premultiply)), r2) this.size = [s2, o2], t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || e.b(t2) ? l3.texImage2D(l3.TEXTURE_2D, 0, this.format, this.format, l3.UNSIGNED_BYTE, t2) : l3.texImage2D(l3.TEXTURE_2D, 0, this.format, s2, o2, 0, this.format, l3.UNSIGNED_BYTE, t2.data);
            else {
              const { x: i3, y: r3 } = a2 || { x: 0, y: 0 };
              t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || e.b(t2) ? l3.texSubImage2D(l3.TEXTURE_2D, 0, i3, r3, l3.RGBA, l3.UNSIGNED_BYTE, t2) : l3.texSubImage2D(l3.TEXTURE_2D, 0, i3, r3, s2, o2, l3.RGBA, l3.UNSIGNED_BYTE, t2.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && l3.generateMipmap(l3.TEXTURE_2D);
          }
          bind(t2, e2, i2) {
            const { context: a2 } = this, { gl: s2 } = a2;
            s2.bindTexture(s2.TEXTURE_2D, this.texture), i2 !== s2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = s2.LINEAR), t2 !== this.filter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, t2), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, i2 || t2), this.filter = t2), e2 !== this.wrap && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, e2), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }
        function w(t2) {
          const { userImage: e2 } = t2;
          return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), true);
        }
        class T extends e.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t2) {
            if (this.loaded !== t2 && (this.loaded = t2, t2)) {
              for (const { ids: t3, promiseResolve: e2 } of this.requestors) e2(this._getImagesForIds(t3));
              this.requestors = [];
            }
          }
          getImage(t2) {
            const i2 = this.images[t2];
            if (i2 && !i2.data && i2.spriteData) {
              const t3 = i2.spriteData;
              i2.data = new e.R({ width: t3.width, height: t3.height }, t3.context.getImageData(t3.x, t3.y, t3.width, t3.height).data), i2.spriteData = null;
            }
            return i2;
          }
          addImage(t2, e2) {
            if (this.images[t2]) throw new Error("Image id ".concat(t2, " already exist, use updateImage instead"));
            this._validate(t2, e2) && (this.images[t2] = e2);
          }
          _validate(t2, i2) {
            let a2 = true;
            const s2 = i2.data || i2.spriteData;
            return this._validateStretch(i2.stretchX, s2 && s2.width) || (this.fire(new e.j(new Error('Image "'.concat(t2, '" has invalid "stretchX" value')))), a2 = false), this._validateStretch(i2.stretchY, s2 && s2.height) || (this.fire(new e.j(new Error('Image "'.concat(t2, '" has invalid "stretchY" value')))), a2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.j(new Error('Image "'.concat(t2, '" has invalid "content" value')))), a2 = false), a2;
          }
          _validateStretch(t2, e2) {
            if (!t2) return true;
            let i2 = 0;
            for (const a2 of t2) {
              if (a2[0] < i2 || a2[1] < a2[0] || e2 < a2[1]) return false;
              i2 = a2[1];
            }
            return true;
          }
          _validateContent(t2, e2) {
            if (!t2) return true;
            if (4 !== t2.length) return false;
            const i2 = e2.spriteData, a2 = i2 && i2.width || e2.data.width, s2 = i2 && i2.height || e2.data.height;
            return !(t2[0] < 0 || a2 < t2[0] || t2[1] < 0 || s2 < t2[1] || t2[2] < 0 || a2 < t2[2] || t2[3] < 0 || s2 < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]);
          }
          updateImage(t2, e2, i2 = true) {
            const a2 = this.getImage(t2);
            if (i2 && (a2.data.width !== e2.data.width || a2.data.height !== e2.data.height)) throw new Error("size mismatch between old image (".concat(a2.data.width, "x").concat(a2.data.height, ") and new image (").concat(e2.data.width, "x").concat(e2.data.height, ")."));
            e2.version = a2.version + 1, this.images[t2] = e2, this.updatedImages[t2] = true;
          }
          removeImage(t2) {
            const e2 = this.images[t2];
            delete this.images[t2], delete this.patterns[t2], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t2) {
            return new Promise((e2, i2) => {
              let a2 = true;
              if (!this.isLoaded()) for (const e3 of t2) this.images[e3] || (a2 = false);
              this.isLoaded() || a2 ? e2(this._getImagesForIds(t2)) : this.requestors.push({ ids: t2, promiseResolve: e2 });
            });
          }
          _getImagesForIds(t2) {
            const i2 = {};
            for (const a2 of t2) {
              let t3 = this.getImage(a2);
              t3 || (this.fire(new e.k("styleimagemissing", { id: a2 })), t3 = this.getImage(a2)), t3 ? i2[a2] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, textFitWidth: t3.textFitWidth, textFitHeight: t3.textFitHeight, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.w('Image "'.concat(a2, '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.'));
            }
            return i2;
          }
          getPixelSize() {
            const { width: t2, height: e2 } = this.atlasImage;
            return { width: t2, height: e2 };
          }
          getPattern(t2) {
            const i2 = this.patterns[t2], a2 = this.getImage(t2);
            if (!a2) return null;
            if (i2 && i2.position.version === a2.version) return i2.position;
            if (i2) i2.position.version = a2.version;
            else {
              const i3 = { w: a2.data.width + 2, h: a2.data.height + 2, x: 0, y: 0 }, s2 = new e.I(i3, a2);
              this.patterns[t2] = { bin: i3, position: s2 };
            }
            return this._updatePatternAtlas(), this.patterns[t2].position;
          }
          bind(t2) {
            const e2 = t2.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new b(t2, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t2 = [];
            for (const e2 in this.patterns) t2.push(this.patterns[e2].bin);
            const { w: i2, h: a2 } = e.p(t2), s2 = this.atlasImage;
            s2.resize({ width: i2 || 1, height: a2 || 1 });
            for (const t3 in this.patterns) {
              const { bin: i3 } = this.patterns[t3], a3 = i3.x + 1, o2 = i3.y + 1, r2 = this.getImage(t3).data, n2 = r2.width, l3 = r2.height;
              e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3, y: o2 }, { width: n2, height: l3 }), e.R.copy(r2, s2, { x: 0, y: l3 - 1 }, { x: a3, y: o2 - 1 }, { width: n2, height: 1 }), e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3, y: o2 + l3 }, { width: n2, height: 1 }), e.R.copy(r2, s2, { x: n2 - 1, y: 0 }, { x: a3 - 1, y: o2 }, { width: 1, height: l3 }), e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3 + n2, y: o2 }, { width: 1, height: l3 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(t2) {
            for (const i2 of t2) {
              if (this.callbackDispatchedThisFrame[i2]) continue;
              this.callbackDispatchedThisFrame[i2] = true;
              const t3 = this.getImage(i2);
              t3 || e.w('Image with ID: "'.concat(i2, '" was not found')), w(t3) && this.updateImage(i2, t3);
            }
          }
        }
        const I = 1e20;
        function E(t2, e2, i2, a2, s2, o2, r2, n2, l3) {
          for (let h2 = e2; h2 < e2 + a2; h2++) P(t2, i2 * o2 + h2, o2, s2, r2, n2, l3);
          for (let h2 = i2; h2 < i2 + s2; h2++) P(t2, h2 * o2 + e2, 1, a2, r2, n2, l3);
        }
        function P(t2, e2, i2, a2, s2, o2, r2) {
          o2[0] = 0, r2[0] = -I, r2[1] = I, s2[0] = t2[e2];
          for (let n2 = 1, l3 = 0, h2 = 0; n2 < a2; n2++) {
            s2[n2] = t2[e2 + n2 * i2];
            const a3 = n2 * n2;
            do {
              const t3 = o2[l3];
              h2 = (s2[n2] - s2[t3] + a3 - t3 * t3) / (n2 - t3) / 2;
            } while (h2 <= r2[l3] && --l3 > -1);
            l3++, o2[l3] = n2, r2[l3] = h2, r2[l3 + 1] = I;
          }
          for (let n2 = 0, l3 = 0; n2 < a2; n2++) {
            for (; r2[l3 + 1] < n2; ) l3++;
            const a3 = o2[l3], h2 = n2 - a3;
            t2[e2 + n2 * i2] = s2[a3] + h2 * h2;
          }
        }
        class C2 {
          constructor(t2, e2) {
            this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
          }
          setURL(t2) {
            this.url = t2;
          }
          getGlyphs(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = [];
              for (const i3 in t2) for (const a3 of t2[i3]) e2.push(this._getAndCacheGlyphsPromise(i3, a3));
              const i2 = yield Promise.all(e2), a2 = {};
              for (const { stack: t3, id: e3, glyph: s2 } of i2) a2[t3] || (a2[t3] = {}), a2[t3][e3] = s2 && { id: s2.id, bitmap: s2.bitmap.clone(), metrics: s2.metrics };
              return a2;
            });
          }
          _getAndCacheGlyphsPromise(t2, i2) {
            return e._(this, void 0, void 0, function* () {
              let e2 = this.entries[t2];
              e2 || (e2 = this.entries[t2] = { glyphs: {}, requests: {}, ranges: {} });
              let a2 = e2.glyphs[i2];
              if (void 0 !== a2) return { stack: t2, id: i2, glyph: a2 };
              if (a2 = this._tinySDF(e2, t2, i2), a2) return e2.glyphs[i2] = a2, { stack: t2, id: i2, glyph: a2 };
              const s2 = Math.floor(i2 / 256);
              if (256 * s2 > 65535) throw new Error("glyphs > 65535 not supported");
              if (e2.ranges[s2]) return { stack: t2, id: i2, glyph: a2 };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!e2.requests[s2]) {
                const i3 = C2.loadGlyphRange(t2, s2, this.url, this.requestManager);
                e2.requests[s2] = i3;
              }
              const o2 = yield e2.requests[s2];
              for (const t3 in o2) this._doesCharSupportLocalGlyph(+t3) || (e2.glyphs[+t3] = o2[+t3]);
              return e2.ranges[s2] = true, { stack: t2, id: i2, glyph: o2[i2] || null };
            });
          }
          _doesCharSupportLocalGlyph(t2) {
            return !!this.localIdeographFontFamily && new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(t2));
          }
          _tinySDF(t2, i2, a2) {
            const s2 = this.localIdeographFontFamily;
            if (!s2) return;
            if (!this._doesCharSupportLocalGlyph(a2)) return;
            let o2 = t2.tinySDF;
            if (!o2) {
              let e2 = "400";
              /bold/i.test(i2) ? e2 = "900" : /medium/i.test(i2) ? e2 = "500" : /light/i.test(i2) && (e2 = "200"), o2 = t2.tinySDF = new C2.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: s2, fontWeight: e2 });
            }
            const r2 = o2.draw(String.fromCharCode(a2));
            return { id: a2, bitmap: new e.o({ width: r2.width || 60, height: r2.height || 60 }, r2.data), metrics: { width: r2.glyphWidth / 2 || 24, height: r2.glyphHeight / 2 || 24, left: r2.glyphLeft / 2 + 0.5 || 0, top: r2.glyphTop / 2 - 27.5 || -8, advance: r2.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        C2.loadGlyphRange = function(t2, i2, a2, s2) {
          return e._(this, void 0, void 0, function* () {
            const o2 = 256 * i2, r2 = o2 + 255, n2 = s2.transformRequest(a2.replace("{fontstack}", t2).replace("{range}", "".concat(o2, "-").concat(r2)), "Glyphs"), l3 = yield e.l(n2, new AbortController());
            if (!l3 || !l3.data) throw new Error("Could not load glyph range. range: ".concat(i2, ", ").concat(o2, "-").concat(r2));
            const h2 = {};
            for (const t3 of e.n(l3.data)) h2[t3.id] = t3;
            return h2;
          });
        }, C2.TinySDF = class {
          constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: i2 = 8, cutoff: a2 = 0.25, fontFamily: s2 = "sans-serif", fontWeight: o2 = "normal", fontStyle: r2 = "normal" } = {}) {
            this.buffer = e2, this.cutoff = a2, this.radius = i2;
            const n2 = this.size = t2 + 4 * e2, l3 = this._createCanvas(n2), h2 = this.ctx = l3.getContext("2d", { willReadFrequently: true });
            h2.font = "".concat(r2, " ").concat(o2, " ").concat(t2, "px ").concat(s2), h2.textBaseline = "alphabetic", h2.textAlign = "left", h2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
          }
          _createCanvas(t2) {
            const e2 = document.createElement("canvas");
            return e2.width = e2.height = t2, e2;
          }
          draw(t2) {
            const { width: e2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: a2, actualBoundingBoxLeft: s2, actualBoundingBoxRight: o2 } = this.ctx.measureText(t2), r2 = Math.ceil(i2), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - s2))), l3 = Math.min(this.size - this.buffer, r2 + Math.ceil(a2)), h2 = n2 + 2 * this.buffer, c2 = l3 + 2 * this.buffer, u2 = Math.max(h2 * c2, 0), d2 = new Uint8ClampedArray(u2), _2 = { data: d2, width: h2, height: c2, glyphWidth: n2, glyphHeight: l3, glyphTop: r2, glyphLeft: 0, glyphAdvance: e2 };
            if (0 === n2 || 0 === l3) return _2;
            const { ctx: p2, buffer: m2, gridInner: f2, gridOuter: g2 } = this;
            p2.clearRect(m2, m2, n2, l3), p2.fillText(t2, m2, m2 + r2);
            const v2 = p2.getImageData(m2, m2, n2, l3);
            g2.fill(I, 0, u2), f2.fill(0, 0, u2);
            for (let t3 = 0; t3 < l3; t3++) for (let e3 = 0; e3 < n2; e3++) {
              const i3 = v2.data[4 * (t3 * n2 + e3) + 3] / 255;
              if (0 === i3) continue;
              const a3 = (t3 + m2) * h2 + e3 + m2;
              if (1 === i3) g2[a3] = 0, f2[a3] = I;
              else {
                const t4 = 0.5 - i3;
                g2[a3] = t4 > 0 ? t4 * t4 : 0, f2[a3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
            E(g2, 0, 0, h2, c2, h2, this.f, this.v, this.z), E(f2, m2, m2, n2, l3, h2, this.f, this.v, this.z);
            for (let t3 = 0; t3 < u2; t3++) {
              const e3 = Math.sqrt(g2[t3]) - Math.sqrt(f2[t3]);
              d2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
            }
            return _2;
          }
        };
        class S {
          constructor() {
            this.specification = e.v.light.position;
          }
          possiblyEvaluate(t2, i2) {
            return e.x(t2.expression.evaluate(i2));
          }
          interpolate(t2, i2, a2) {
            return { x: e.y.number(t2.x, i2.x, a2), y: e.y.number(t2.y, i2.y, a2), z: e.y.number(t2.z, i2.z, a2) };
          }
        }
        let z2;
        class D extends e.E {
          constructor(t2) {
            super(), z2 = z2 || new e.q({ anchor: new e.D(e.v.light.anchor), position: new S(), color: new e.D(e.v.light.color), intensity: new e.D(e.v.light.intensity) }), this._transitionable = new e.T(z2), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t2, i2 = {}) {
            if (!this._validate(e.r, t2, i2)) for (const e2 in t2) {
              const i3 = t2[e2];
              e2.endsWith("-transition") ? this._transitionable.setTransition(e2.slice(0, -11), i3) : this._transitionable.setValue(e2, i3);
            }
          }
          updateTransitions(t2) {
            this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t2) {
            this.properties = this._transitioning.possiblyEvaluate(t2);
          }
          _validate(t2, i2, a2) {
            return (!a2 || false !== a2.validate) && e.t(this, t2.call(e.u, { value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.v }));
          }
        }
        const M2 = new e.q({ "sky-color": new e.D(e.v.sky["sky-color"]), "horizon-color": new e.D(e.v.sky["horizon-color"]), "fog-color": new e.D(e.v.sky["fog-color"]), "fog-ground-blend": new e.D(e.v.sky["fog-ground-blend"]), "horizon-fog-blend": new e.D(e.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new e.D(e.v.sky["sky-horizon-blend"]), "atmosphere-blend": new e.D(e.v.sky["atmosphere-blend"]) });
        class A2 extends e.E {
          constructor(t2) {
            super(), this._transitionable = new e.T(M2), this.setSky(t2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new e.z(0));
          }
          setSky(t2, i2 = {}) {
            if (!this._validate(e.B, t2, i2)) {
              t2 || (t2 = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const e2 in t2) {
                const i3 = t2[e2];
                e2.endsWith("-transition") ? this._transitionable.setTransition(e2.slice(0, -11), i3) : this._transitionable.setValue(e2, i3);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(t2) {
            this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t2) {
            this.properties = this._transitioning.possiblyEvaluate(t2);
          }
          _validate(t2, i2, a2 = {}) {
            return false !== (null == a2 ? void 0 : a2.validate) && e.t(this, t2.call(e.u, e.e({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.v })));
          }
          calculateFogBlendOpacity(t2) {
            return t2 < 60 ? 0 : t2 < 70 ? (t2 - 60) / 10 : 1;
          }
        }
        class R {
          constructor(t2, e2) {
            this.width = t2, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t2, e2) {
            const i2 = t2.join(",") + String(e2);
            return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e2)), this.dashEntry[i2];
          }
          getDashRanges(t2, e2, i2) {
            const a2 = [];
            let s2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, o2 = t2[0] * i2, r2 = true;
            a2.push({ left: s2, right: o2, isDash: r2, zeroLength: 0 === t2[0] });
            let n2 = t2[0];
            for (let e3 = 1; e3 < t2.length; e3++) {
              r2 = !r2;
              const l3 = t2[e3];
              s2 = n2 * i2, n2 += l3, o2 = n2 * i2, a2.push({ left: s2, right: o2, isDash: r2, zeroLength: 0 === l3 });
            }
            return a2;
          }
          addRoundDash(t2, e2, i2) {
            const a2 = e2 / 2;
            for (let e3 = -i2; e3 <= i2; e3++) {
              const s2 = this.width * (this.nextRow + i2 + e3);
              let o2 = 0, r2 = t2[o2];
              for (let n2 = 0; n2 < this.width; n2++) {
                n2 / r2.right > 1 && (r2 = t2[++o2]);
                const l3 = Math.abs(n2 - r2.left), h2 = Math.abs(n2 - r2.right), c2 = Math.min(l3, h2);
                let u2;
                const d2 = e3 / i2 * (a2 + 1);
                if (r2.isDash) {
                  const t3 = a2 - Math.abs(d2);
                  u2 = Math.sqrt(c2 * c2 + t3 * t3);
                } else u2 = a2 - Math.sqrt(c2 * c2 + d2 * d2);
                this.data[s2 + n2] = Math.max(0, Math.min(255, u2 + 128));
              }
            }
          }
          addRegularDash(t2) {
            for (let e3 = t2.length - 1; e3 >= 0; --e3) {
              const i3 = t2[e3], a3 = t2[e3 + 1];
              i3.zeroLength ? t2.splice(e3, 1) : a3 && a3.isDash === i3.isDash && (a3.left = i3.left, t2.splice(e3, 1));
            }
            const e2 = t2[0], i2 = t2[t2.length - 1];
            e2.isDash === i2.isDash && (e2.left = i2.left - this.width, i2.right = e2.right + this.width);
            const a2 = this.width * this.nextRow;
            let s2 = 0, o2 = t2[s2];
            for (let e3 = 0; e3 < this.width; e3++) {
              e3 / o2.right > 1 && (o2 = t2[++s2]);
              const i3 = Math.abs(e3 - o2.left), r2 = Math.abs(e3 - o2.right), n2 = Math.min(i3, r2);
              this.data[a2 + e3] = Math.max(0, Math.min(255, (o2.isDash ? n2 : -n2) + 128));
            }
          }
          addDash(t2, i2) {
            const a2 = i2 ? 7 : 0, s2 = 2 * a2 + 1;
            if (this.nextRow + s2 > this.height) return e.w("LineAtlas out of space"), null;
            let o2 = 0;
            for (let e2 = 0; e2 < t2.length; e2++) o2 += t2[e2];
            if (0 !== o2) {
              const e2 = this.width / o2, s3 = this.getDashRanges(t2, this.width, e2);
              i2 ? this.addRoundDash(s3, e2, a2) : this.addRegularDash(s3);
            }
            const r2 = { y: (this.nextRow + a2 + 0.5) / this.height, height: 2 * a2 / this.height, width: o2 };
            return this.nextRow += s2, this.dirty = true, r2;
          }
          bind(t2) {
            const e2 = t2.gl;
            this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
          }
        }
        const k = "maplibre_preloaded_worker_pool";
        class L2 {
          constructor() {
            this.active = {};
          }
          acquire(t2) {
            if (!this.workers) for (this.workers = []; this.workers.length < L2.workerCount; ) this.workers.push(new Worker(e.a.WORKER_URL));
            return this.active[t2] = true, this.workers.slice();
          }
          release(t2) {
            delete this.active[t2], 0 === this.numActive() && (this.workers.forEach((t3) => {
              t3.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[k];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const F = Math.floor(o.hardwareConcurrency / 2);
        let B, O;
        function N() {
          return B || (B = new L2()), B;
        }
        L2.workerCount = e.C(globalThis) ? Math.max(Math.min(F, 3), 1) : 1;
        class U2 {
          constructor(t2, i2) {
            this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = i2;
            const a2 = this.workerPool.acquire(i2);
            for (let t3 = 0; t3 < a2.length; t3++) {
              const s2 = new e.F(a2[t3], i2);
              s2.name = "Worker ".concat(t3), this.actors.push(s2);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(t2, e2) {
            const i2 = [];
            for (const a2 of this.actors) i2.push(a2.sendAsync({ type: t2, data: e2 }));
            return Promise.all(i2);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(t2 = true) {
            this.actors.forEach((t3) => {
              t3.remove();
            }), this.actors = [], t2 && this.workerPool.release(this.id);
          }
          registerMessageHandler(t2, e2) {
            for (const i2 of this.actors) i2.registerMessageHandler(t2, e2);
          }
        }
        function j() {
          return O || (O = new U2(N(), e.G), O.registerMessageHandler("GR", (t2, i2, a2) => e.m(i2, a2))), O;
        }
        function Z(t2, i2) {
          const a2 = e.H();
          return e.J(a2, a2, [1, 1, 0]), e.K(a2, a2, [0.5 * t2.width, 0.5 * t2.height, 1]), e.L(a2, a2, t2.calculatePosMatrix(i2.toUnwrapped()));
        }
        function q(t2, e2, i2, a2, s2, o2) {
          const r2 = function(t3, e3, i3) {
            if (t3) for (const a3 of t3) {
              const t4 = e3[a3];
              if (t4 && t4.source === i3 && "fill-extrusion" === t4.type) return true;
            }
            else for (const t4 in e3) {
              const a3 = e3[t4];
              if (a3.source === i3 && "fill-extrusion" === a3.type) return true;
            }
            return false;
          }(s2 && s2.layers, e2, t2.id), n2 = o2.maxPitchScaleFactor(), l3 = t2.tilesIn(a2, n2, r2);
          l3.sort(V2);
          const h2 = [];
          for (const a3 of l3) h2.push({ wrappedTileID: a3.tileID.wrapped().key, queryResults: a3.tile.queryRenderedFeatures(e2, i2, t2._state, a3.queryGeometry, a3.cameraQueryGeometry, a3.scale, s2, o2, n2, Z(t2.transform, a3.tileID)) });
          const c2 = function(t3) {
            const e3 = {}, i3 = {};
            for (const a3 of t3) {
              const t4 = a3.queryResults, s3 = a3.wrappedTileID, o3 = i3[s3] = i3[s3] || {};
              for (const i4 in t4) {
                const a4 = t4[i4], s4 = o3[i4] = o3[i4] || {}, r3 = e3[i4] = e3[i4] || [];
                for (const t5 of a4) s4[t5.featureIndex] || (s4[t5.featureIndex] = true, r3.push(t5));
              }
            }
            return e3;
          }(h2);
          for (const e3 in c2) c2[e3].forEach((e4) => {
            const i3 = e4.feature, a3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
            i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = a3;
          });
          return c2;
        }
        function V2(t2, e2) {
          const i2 = t2.tileID, a2 = e2.tileID;
          return i2.overscaledZ - a2.overscaledZ || i2.canonical.y - a2.canonical.y || i2.wrap - a2.wrap || i2.canonical.x - a2.canonical.x;
        }
        function G(t2, i2, a2) {
          return e._(this, void 0, void 0, function* () {
            let s2 = t2;
            if (t2.url ? s2 = (yield e.h(i2.transformRequest(t2.url, "Source"), a2)).data : yield o.frameAsync(a2), !s2) return null;
            const r2 = e.M(e.e(s2, t2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in s2 && s2.vector_layers && (r2.vectorLayerIds = s2.vector_layers.map((t3) => t3.id)), r2;
          });
        }
        class H {
          constructor(t2, e2) {
            t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : Array.isArray(t2) && (4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1])));
          }
          setNorthEast(t2) {
            return this._ne = t2 instanceof e.N ? new e.N(t2.lng, t2.lat) : e.N.convert(t2), this;
          }
          setSouthWest(t2) {
            return this._sw = t2 instanceof e.N ? new e.N(t2.lng, t2.lat) : e.N.convert(t2), this;
          }
          extend(t2) {
            const i2 = this._sw, a2 = this._ne;
            let s2, o2;
            if (t2 instanceof e.N) s2 = t2, o2 = t2;
            else {
              if (!(t2 instanceof H)) return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(H.convert(t2)) : this.extend(e.N.convert(t2)) : t2 && ("lng" in t2 || "lon" in t2) && "lat" in t2 ? this.extend(e.N.convert(t2)) : this;
              if (s2 = t2._sw, o2 = t2._ne, !s2 || !o2) return this;
            }
            return i2 || a2 ? (i2.lng = Math.min(s2.lng, i2.lng), i2.lat = Math.min(s2.lat, i2.lat), a2.lng = Math.max(o2.lng, a2.lng), a2.lat = Math.max(o2.lat, a2.lat)) : (this._sw = new e.N(s2.lng, s2.lat), this._ne = new e.N(o2.lng, o2.lat)), this;
          }
          getCenter() {
            return new e.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new e.N(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new e.N(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return "LngLatBounds(".concat(this._sw.toString(), ", ").concat(this._ne.toString(), ")");
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t2) {
            const { lng: i2, lat: a2 } = e.N.convert(t2);
            let s2 = this._sw.lng <= i2 && i2 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (s2 = this._sw.lng >= i2 && i2 >= this._ne.lng), this._sw.lat <= a2 && a2 <= this._ne.lat && s2;
          }
          static convert(t2) {
            return t2 instanceof H ? t2 : t2 ? new H(t2) : t2;
          }
          static fromLngLat(t2, i2 = 0) {
            const a2 = 360 * i2 / 40075017, s2 = a2 / Math.cos(Math.PI / 180 * t2.lat);
            return new H(new e.N(t2.lng - s2, t2.lat - a2), new e.N(t2.lng + s2, t2.lat + a2));
          }
          adjustAntiMeridian() {
            const t2 = new e.N(this._sw.lng, this._sw.lat), i2 = new e.N(this._ne.lng, this._ne.lat);
            return new H(t2, t2.lng > i2.lng ? new e.N(i2.lng + 360, i2.lat) : i2);
          }
        }
        class W2 {
          constructor(t2, e2, i2) {
            this.bounds = H.convert(this.validateBounds(t2)), this.minzoom = e2 || 0, this.maxzoom = i2 || 24;
          }
          validateBounds(t2) {
            return Array.isArray(t2) && 4 === t2.length ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
          }
          contains(t2) {
            const i2 = Math.pow(2, t2.z), a2 = Math.floor(e.O(this.bounds.getWest()) * i2), s2 = Math.floor(e.Q(this.bounds.getNorth()) * i2), o2 = Math.ceil(e.O(this.bounds.getEast()) * i2), r2 = Math.ceil(e.Q(this.bounds.getSouth()) * i2);
            return t2.x >= a2 && t2.x < o2 && t2.y >= s2 && t2.y < r2;
          }
        }
        class $ extends e.E {
          constructor(t2, i2, a2, s2) {
            if (super(), this.id = t2, this.dispatcher = a2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.e(this, e.M(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.e({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(s2);
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t2 = yield G(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), t2 && (e.e(this, t2), t2.bounds && (this.tileBounds = new W2(t2.bounds, this.minzoom, this.maxzoom)), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t2) {
                this._tileJSONRequest = null, this.fire(new e.j(t2));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setSourceProperty(t2) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), t2(), this.load();
          }
          setTiles(t2) {
            return this.setSourceProperty(() => {
              this._options.tiles = t2;
            }), this;
          }
          setUrl(t2) {
            return this.setSourceProperty(() => {
              this.url = t2, this._options.url = t2;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return e.e({}, this._options);
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i2 = { request: this.map._requestManager.transformRequest(e2, "Tile"), uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              i2.request.collectResourceTiming = this._collectResourceTiming;
              let a2 = "RT";
              if (t2.actor && "expired" !== t2.state) {
                if ("loading" === t2.state) return new Promise((e3, i3) => {
                  t2.reloadPromise = { resolve: e3, reject: i3 };
                });
              } else t2.actor = this.dispatcher.getActor(), a2 = "LT";
              t2.abortController = new AbortController();
              try {
                const e3 = yield t2.actor.sendAsync({ type: a2, data: i2 }, t2.abortController);
                if (delete t2.abortController, t2.aborted) return;
                this._afterTileLoadWorkerResponse(t2, e3);
              } catch (e3) {
                if (delete t2.abortController, t2.aborted) return;
                if (e3 && 404 !== e3.status) throw e3;
                this._afterTileLoadWorkerResponse(t2, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(t2, e2) {
            if (e2 && e2.resourceTiming && (t2.resourceTiming = e2.resourceTiming), e2 && this.map._refreshExpiredTiles && t2.setExpiryData(e2), t2.loadVectorData(e2, this.map.painter), t2.reloadPromise) {
              const e3 = t2.reloadPromise;
              t2.reloadPromise = null, this.loadTile(t2).then(e3.resolve).catch(e3.reject);
            }
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.abortController && (t2.abortController.abort(), delete t2.abortController), t2.actor && (yield t2.actor.sendAsync({ type: "AT", data: { uid: t2.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.unloadVectorData(), t2.actor && (yield t2.actor.sendAsync({ type: "RMT", data: { uid: t2.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return false;
          }
        }
        class X extends e.E {
          constructor(t2, i2, a2, s2) {
            super(), this.id = t2, this.dispatcher = a2, this.setEventedParent(s2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.e({ type: "raster" }, i2), e.e(this, e.M(i2, ["url", "scheme", "tileSize"]));
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t2 = yield G(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, t2 && (e.e(this, t2), t2.bounds && (this.tileBounds = new W2(t2.bounds, this.minzoom, this.maxzoom)), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t2) {
                this._tileJSONRequest = null, this.fire(new e.j(t2));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(t2) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t2(), this.load();
          }
          setTiles(t2) {
            return this.setSourceProperty(() => {
              this._options.tiles = t2;
            }), this;
          }
          setUrl(t2) {
            return this.setSourceProperty(() => {
              this.url = t2, this._options.url = t2;
            }), this;
          }
          serialize() {
            return e.e({}, this._options);
          }
          hasTile(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              t2.abortController = new AbortController();
              try {
                const i2 = yield _.getImage(this.map._requestManager.transformRequest(e2, "Tile"), t2.abortController, this.map._refreshExpiredTiles);
                if (delete t2.abortController, t2.aborted) return void (t2.state = "unloaded");
                if (i2 && i2.data) {
                  this.map._refreshExpiredTiles && i2.cacheControl && i2.expires && t2.setExpiryData({ cacheControl: i2.cacheControl, expires: i2.expires });
                  const e3 = this.map.painter.context, a2 = e3.gl, s2 = i2.data;
                  t2.texture = this.map.painter.getTileTexture(s2.width), t2.texture ? t2.texture.update(s2, { useMipmap: true }) : (t2.texture = new b(e3, s2, a2.RGBA, { useMipmap: true }), t2.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST)), t2.state = "loaded";
                }
              } catch (e3) {
                if (delete t2.abortController, t2.aborted) t2.state = "unloaded";
                else if (e3) throw t2.state = "errored", e3;
              }
            });
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.abortController && (t2.abortController.abort(), delete t2.abortController);
            });
          }
          unloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.texture && this.map.painter.saveTileTexture(t2.texture);
            });
          }
          hasTransition() {
            return false;
          }
        }
        class K extends X {
          constructor(t2, i2, a2, s2) {
            super(t2, i2, a2, s2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.e({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox", this.redFactor = i2.redFactor, this.greenFactor = i2.greenFactor, this.blueFactor = i2.blueFactor, this.baseShift = i2.baseShift;
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const i2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = this.map._requestManager.transformRequest(i2, "Tile");
              t2.neighboringTiles = this._getNeighboringTiles(t2.tileID), t2.abortController = new AbortController();
              try {
                const i3 = yield _.getImage(a2, t2.abortController, this.map._refreshExpiredTiles);
                if (delete t2.abortController, t2.aborted) return void (t2.state = "unloaded");
                if (i3 && i3.data) {
                  const a3 = i3.data;
                  this.map._refreshExpiredTiles && i3.cacheControl && i3.expires && t2.setExpiryData({ cacheControl: i3.cacheControl, expires: i3.expires });
                  const s2 = e.b(a3) && e.U() ? a3 : yield this.readImageNow(a3), o2 = { type: this.type, uid: t2.uid, source: this.id, rawImageData: s2, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!t2.actor || "expired" === t2.state) {
                    t2.actor = this.dispatcher.getActor();
                    const e2 = yield t2.actor.sendAsync({ type: "LDT", data: o2 });
                    t2.dem = e2, t2.needsHillshadePrepare = true, t2.needsTerrainPrepare = true, t2.state = "loaded";
                  }
                }
              } catch (e2) {
                if (delete t2.abortController, t2.aborted) t2.state = "unloaded";
                else if (e2) throw t2.state = "errored", e2;
              }
            });
          }
          readImageNow(t2) {
            return e._(this, void 0, void 0, function* () {
              if ("undefined" != typeof VideoFrame && e.V()) {
                const i2 = t2.width + 2, a2 = t2.height + 2;
                try {
                  return new e.R({ width: i2, height: a2 }, yield e.W(t2, -1, -1, i2, a2));
                } catch (t3) {
                }
              }
              return o.getImageData(t2, 1);
            });
          }
          _getNeighboringTiles(t2) {
            const i2 = t2.canonical, a2 = Math.pow(2, i2.z), s2 = (i2.x - 1 + a2) % a2, o2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, r2 = (i2.x + 1 + a2) % a2, n2 = i2.x + 1 === a2 ? t2.wrap + 1 : t2.wrap, l3 = {};
            return l3[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y).key] = { backfilled: false }, l3[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l3[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y - 1).key] = { backfilled: false }, l3[new e.S(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l3[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < a2 && (l3[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y + 1).key] = { backfilled: false }, l3[new e.S(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l3[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y + 1).key] = { backfilled: false }), l3;
          }
          unloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && (yield t2.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t2.uid, source: this.id } }));
            });
          }
        }
        class J2 extends e.E {
          constructor(t2, i2, a2, s2) {
            super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = a2.getActor(), this.setEventedParent(s2), this._data = i2.data, this._options = e.e({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
            const o2 = e.X / this.tileSize;
            void 0 !== i2.clusterMaxZoom && this.maxzoom <= i2.clusterMaxZoom && e.w('The maxzoom value "'.concat(this.maxzoom, '" is expected to be greater than the clusterMaxZoom value "').concat(i2.clusterMaxZoom, '".')), this.workerOptions = e.e({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * o2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * o2, extent: e.X, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.X, radius: (i2.clusterRadius || 50) * o2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setData(t2) {
            return this._data = t2, this._updateWorkerData(), this;
          }
          updateData(t2) {
            return this._updateWorkerData(t2), this;
          }
          getData() {
            return e._(this, void 0, void 0, function* () {
              const t2 = e.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: t2 });
            });
          }
          setClusterOptions(t2) {
            return this.workerOptions.cluster = t2.cluster, t2 && (void 0 !== t2.clusterRadius && (this.workerOptions.superclusterOptions.radius = t2.clusterRadius), void 0 !== t2.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = t2.clusterMaxZoom)), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(t2) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t2, source: this.id } });
          }
          getClusterChildren(t2) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t2, source: this.id } });
          }
          getClusterLeaves(t2, e2, i2) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t2, limit: e2, offset: i2 } });
          }
          _updateWorkerData(t2) {
            return e._(this, void 0, void 0, function* () {
              const i2 = e.e({ type: this.type }, this.workerOptions);
              t2 ? i2.dataDiff = t2 : "string" == typeof this._data ? (i2.request = this.map._requestManager.transformRequest(o.resolveURL(this._data), "Source"), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new e.k("dataloading", { dataType: "source" }));
              try {
                const t3 = yield this.actor.sendAsync({ type: "LD", data: i2 });
                if (this._pendingLoads--, this._removed || t3.abandoned) return void this.fire(new e.k("dataabort", { dataType: "source" }));
                let a2 = null;
                t3.resourceTiming && t3.resourceTiming[this.id] && (a2 = t3.resourceTiming[this.id].slice(0));
                const s2 = { dataType: "source" };
                this._collectResourceTiming && a2 && a2.length > 0 && e.e(s2, { resourceTiming: a2 }), this.fire(new e.k("data", Object.assign(Object.assign({}, s2), { sourceDataType: "metadata" }))), this.fire(new e.k("data", Object.assign(Object.assign({}, s2), { sourceDataType: "content" })));
              } catch (t3) {
                if (this._pendingLoads--, this._removed) return void this.fire(new e.k("dataabort", { dataType: "source" }));
                this.fire(new e.j(t3));
              }
            });
          }
          loaded() {
            return 0 === this._pendingLoads;
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = t2.actor ? "RT" : "LT";
              t2.actor = this.actor;
              const i2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              t2.abortController = new AbortController();
              const a2 = yield this.actor.sendAsync({ type: e2, data: i2 }, t2.abortController);
              delete t2.abortController, t2.unloadVectorData(), t2.aborted || t2.loadVectorData(a2, this.map.painter, "RT" === e2);
            });
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.abortController && (t2.abortController.abort(), delete t2.abortController), t2.aborted = true;
            });
          }
          unloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t2.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return e.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        var Y = e.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class Q2 extends e.E {
          constructor(t2, e2, i2, a2) {
            super(), this.id = t2, this.dispatcher = i2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a2), this.options = e2;
          }
          load(t2) {
            return e._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const e2 = yield _.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, e2 && e2.data && (this.image = e2.data, t2 && (this.coordinates = t2), this._finishLoading());
              } catch (t3) {
                this._request = null, this._loaded = true, this.fire(new e.j(t3));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t2) {
            return t2.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t2.url, this.load(t2.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(t2) {
            this.coordinates = t2;
            const i2 = t2.map(e.Z.fromLngLat);
            this.tileID = function(t3) {
              let i3 = 1 / 0, a3 = 1 / 0, s2 = -1 / 0, o2 = -1 / 0;
              for (const e2 of t3) i3 = Math.min(i3, e2.x), a3 = Math.min(a3, e2.y), s2 = Math.max(s2, e2.x), o2 = Math.max(o2, e2.y);
              const r2 = Math.max(s2 - i3, o2 - a3), n2 = Math.max(0, Math.floor(-Math.log(r2) / Math.LN2)), l3 = Math.pow(2, n2);
              return new e.a1(n2, Math.floor((i3 + s2) / 2 * l3), Math.floor((a3 + o2) / 2 * l3));
            }(i2), this.minzoom = this.maxzoom = this.tileID.z;
            const a2 = i2.map((t3) => this.tileID.getTilePoint(t3)._round());
            return this._boundsArray = new e.$(), this._boundsArray.emplaceBack(a2[0].x, a2[0].y, 0, 0), this._boundsArray.emplaceBack(a2[1].x, a2[1].y, e.X, 0), this._boundsArray.emplaceBack(a2[3].x, a2[3].y, 0, e.X), this._boundsArray.emplaceBack(a2[2].x, a2[2].y, e.X, e.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image) return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new b(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            let a2 = false;
            for (const t3 in this.tiles) {
              const e2 = this.tiles[t3];
              "loaded" !== e2.state && (e2.state = "loaded", e2.texture = this.texture, a2 = true);
            }
            a2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}) : t2.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
        }
        class tt2 extends Q2 {
          constructor(t2, e2, i2, a2) {
            super(t2, e2, i2, a2), this.roundZoom = true, this.type = "video", this.options = e2;
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = false;
              const t2 = this.options;
              this.urls = [];
              for (const e2 of t2.urls) this.urls.push(this.map._requestManager.transformRequest(e2, "Source").url);
              try {
                const t3 = yield e.a3(this.urls);
                if (this._loaded = true, !t3) return;
                this.video = t3, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (t3) {
                this.fire(new e.j(t3));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t2) {
            if (this.video) {
              const i2 = this.video.seekable;
              t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.j(new e.a2("sources.".concat(this.id), null, "Playback for this video can be set only between the ".concat(i2.start(0), " and ").concat(i2.end(0), "-second mark.")))) : this.video.currentTime = t2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t2) {
            this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new b(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            let a2 = false;
            for (const t3 in this.tiles) {
              const e2 = this.tiles[t3];
              "loaded" !== e2.state && (e2.state = "loaded", e2.texture = this.texture, a2 = true);
            }
            a2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class et2 extends Q2 {
          constructor(t2, i2, a2, s2) {
            super(t2, i2, a2, s2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((t3) => !Array.isArray(t3) || 2 !== t3.length || t3.some((t4) => "number" != typeof t4)) || this.fire(new e.j(new e.a2("sources.".concat(t2), null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.j(new e.a2("sources.".concat(t2), null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.j(new e.a2("sources.".concat(t2), null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new e.j(new e.a2("sources.".concat(t2), null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.j(new e.a2("sources.".concat(t2), null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t2) {
            this.map = t2, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t2 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions()) return;
            if (0 === Object.keys(this.tiles).length) return;
            const i2 = this.map.painter.context, a2 = i2.gl;
            this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new b(i2, this.canvas, a2.RGBA, { premultiply: true });
            let s2 = false;
            for (const t3 in this.tiles) {
              const e2 = this.tiles[t3];
              "loaded" !== e2.state && (e2.state = "loaded", e2.texture = this.texture, s2 = true);
            }
            s2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t2 of [this.canvas.width, this.canvas.height]) if (isNaN(t2) || t2 <= 0) return true;
            return false;
          }
        }
        const it2 = {}, at2 = (t2) => {
          switch (t2) {
            case "geojson":
              return J2;
            case "image":
              return Q2;
            case "raster":
              return X;
            case "raster-dem":
              return K;
            case "vector":
              return $;
            case "video":
              return tt2;
            case "canvas":
              return et2;
          }
          return it2[t2];
        }, st2 = "RTLPluginLoaded";
        class ot2 extends e.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = j();
          }
          _syncState(t2) {
            return this.status = t2, this.dispatcher.broadcast("SRPS", { pluginStatus: t2, pluginURL: this.url }).catch((t3) => {
              throw this.status = "error", t3;
            });
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(t2) {
            return e._(this, arguments, void 0, function* (t3, e2 = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = o.resolveURL(t3), !this.url) throw new Error("requested url ".concat(t3, " is invalid"));
              if ("unavailable" === this.status) {
                if (!e2) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if ("requested" === this.status) return this._requestImport();
            });
          }
          _requestImport() {
            return e._(this, void 0, void 0, function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new e.k(st2));
            });
          }
          lazyLoad() {
            "unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
          }
        }
        let rt2 = null;
        function nt2() {
          return rt2 || (rt2 = new ot2()), rt2;
        }
        class lt2 {
          constructor(t2, i2) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = t2, this.uid = e.a4(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(t2) {
            const e2 = t2 + this.timeAdded;
            e2 < this.fadeEndTime || (this.fadeEndTime = e2);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          clearTextures(t2) {
            this.demTexture && t2.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(t2, i2, a2) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
              t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e2) {
                const i3 = {};
                if (!e2) return i3;
                for (const a3 of t3) {
                  const t4 = a3.layerIds.map((t5) => e2.getLayer(t5)).filter(Boolean);
                  if (0 !== t4.length) {
                    a3.layers = t4, a3.stateDependentLayerIds && (a3.stateDependentLayers = a3.stateDependentLayerIds.map((e3) => t4.filter((t5) => t5.id === e3)[0]));
                    for (const e3 of t4) i3[e3.id] = a3;
                  }
                }
                return i3;
              }(t2.buckets, i2.style), this.hasSymbolBuckets = false;
              for (const t3 in this.buckets) {
                const i3 = this.buckets[t3];
                if (i3 instanceof e.a6) {
                  if (this.hasSymbolBuckets = true, !a2) break;
                  i3.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const t3 in this.buckets) {
                const i3 = this.buckets[t3];
                if (i3 instanceof e.a6 && i3.hasRTLText) {
                  this.hasRTLText = true, nt2().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const t3 in this.buckets) {
                const e2 = this.buckets[t3];
                this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(t3).queryRadius(e2));
              }
              t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage);
            } else this.collisionBoxArray = new e.a5();
          }
          unloadVectorData() {
            for (const t2 in this.buckets) this.buckets[t2].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t2) {
            return this.buckets[t2.id];
          }
          upload(t2) {
            for (const e3 in this.buckets) {
              const i2 = this.buckets[e3];
              i2.uploadPending() && i2.upload(t2);
            }
            const e2 = t2.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new b(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new b(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t2) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t2, e2, i2, a2, s2, o2, r2, n2, l3, h2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: a2, cameraQueryGeometry: s2, scale: o2, tileSize: this.tileSize, pixelPosMatrix: h2, transform: n2, params: r2, queryPadding: this.queryPadding * l3 }, t2, e2, i2) : {};
          }
          querySourceFeatures(t2, i2) {
            const a2 = this.latestFeatureIndex;
            if (!a2 || !a2.rawTileData) return;
            const s2 = a2.loadVTLayers(), o2 = i2 && i2.sourceLayer ? i2.sourceLayer : "", r2 = s2._geojsonTileLayer || s2[o2];
            if (!r2) return;
            const n2 = e.a7(i2 && i2.filter), { z: l3, x: h2, y: c2 } = this.tileID.canonical, u2 = { z: l3, x: h2, y: c2 };
            for (let i3 = 0; i3 < r2.length; i3++) {
              const s3 = r2.feature(i3);
              if (n2.needGeometry) {
                const t3 = e.a8(s3, true);
                if (!n2.filter(new e.z(this.tileID.overscaledZ), t3, this.tileID.canonical)) continue;
              } else if (!n2.filter(new e.z(this.tileID.overscaledZ), s3)) continue;
              const d2 = a2.getId(s3, o2), _2 = new e.a9(s3, l3, h2, c2, d2);
              _2.tile = u2, t2.push(_2);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t2) {
            const i2 = this.expirationTime;
            if (t2.cacheControl) {
              const i3 = e.aa(t2.cacheControl);
              i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
            } else t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
            if (this.expirationTime) {
              const t3 = Date.now();
              let e2 = false;
              if (this.expirationTime > t3) e2 = false;
              else if (i2) if (this.expirationTime < i2) e2 = true;
              else {
                const a2 = this.expirationTime - i2;
                a2 ? this.expirationTime = t3 + Math.max(a2, 3e4) : e2 = true;
              }
              else e2 = true;
              e2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t2, e2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t2).length) return;
            const i2 = this.latestFeatureIndex.loadVTLayers();
            for (const a2 in this.buckets) {
              if (!e2.style.hasLayer(a2)) continue;
              const s2 = this.buckets[a2], o2 = s2.layers[0].sourceLayer || "_geojsonTileLayer", r2 = i2[o2], n2 = t2[o2];
              if (!r2 || !n2 || 0 === Object.keys(n2).length) continue;
              s2.update(n2, r2, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const l3 = e2 && e2.style && e2.style.getLayer(a2);
              l3 && (this.queryPadding = Math.max(this.queryPadding, l3.queryRadius(s2)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < o.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t2) {
            this.symbolFadeHoldUntil = o.now() + t2;
          }
          setDependencies(t2, e2) {
            const i2 = {};
            for (const t3 of e2) i2[t3] = true;
            this.dependencies[t2] = i2;
          }
          hasDependency(t2, e2) {
            for (const i2 of t2) {
              const t3 = this.dependencies[i2];
              if (t3) {
                for (const i3 of e2) if (t3[i3]) return true;
              }
            }
            return false;
          }
        }
        class ht2 {
          constructor(t2, e2) {
            this.max = t2, this.onRemove = e2, this.reset();
          }
          reset() {
            for (const t2 in this.data) for (const e2 of this.data[t2]) e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
            return this.data = {}, this.order = [], this;
          }
          add(t2, e2, i2) {
            const a2 = t2.wrapped().key;
            void 0 === this.data[a2] && (this.data[a2] = []);
            const s2 = { value: e2, timeout: void 0 };
            if (void 0 !== i2 && (s2.timeout = setTimeout(() => {
              this.remove(t2, s2);
            }, i2)), this.data[a2].push(s2), this.order.push(a2), this.order.length > this.max) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          has(t2) {
            return t2.wrapped().key in this.data;
          }
          getAndRemove(t2) {
            return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
          }
          _getAndRemoveByKey(t2) {
            const e2 = this.data[t2].shift();
            return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
          }
          getByKey(t2) {
            const e2 = this.data[t2];
            return e2 ? e2[0].value : null;
          }
          get(t2) {
            return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
          }
          remove(t2, e2) {
            if (!this.has(t2)) return this;
            const i2 = t2.wrapped().key, a2 = void 0 === e2 ? 0 : this.data[i2].indexOf(e2), s2 = this.data[i2][a2];
            return this.data[i2].splice(a2, 1), s2.timeout && clearTimeout(s2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(s2.value), this.order.splice(this.order.indexOf(i2), 1), this;
          }
          setMaxSize(t2) {
            for (this.max = t2; this.order.length > this.max; ) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          filter(t2) {
            const e2 = [];
            for (const i2 in this.data) for (const a2 of this.data[i2]) t2(a2.value) || e2.push(a2);
            for (const t3 of e2) this.remove(t3.value.tileID, t3);
          }
        }
        class ct2 {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t2, i2, a2) {
            const s2 = String(i2);
            if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][s2] = this.stateChanges[t2][s2] || {}, e.e(this.stateChanges[t2][s2], a2), null === this.deletedStates[t2]) {
              this.deletedStates[t2] = {};
              for (const e2 in this.state[t2]) e2 !== s2 && (this.deletedStates[t2][e2] = null);
            } else if (this.deletedStates[t2] && null === this.deletedStates[t2][s2]) {
              this.deletedStates[t2][s2] = {};
              for (const e2 in this.state[t2][s2]) a2[e2] || (this.deletedStates[t2][s2][e2] = null);
            } else for (const e2 in a2) this.deletedStates[t2] && this.deletedStates[t2][s2] && null === this.deletedStates[t2][s2][e2] && delete this.deletedStates[t2][s2][e2];
          }
          removeFeatureState(t2, e2, i2) {
            if (null === this.deletedStates[t2]) return;
            const a2 = String(e2);
            if (this.deletedStates[t2] = this.deletedStates[t2] || {}, i2 && void 0 !== e2) null !== this.deletedStates[t2][a2] && (this.deletedStates[t2][a2] = this.deletedStates[t2][a2] || {}, this.deletedStates[t2][a2][i2] = null);
            else if (void 0 !== e2) if (this.stateChanges[t2] && this.stateChanges[t2][a2]) for (i2 in this.deletedStates[t2][a2] = {}, this.stateChanges[t2][a2]) this.deletedStates[t2][a2][i2] = null;
            else this.deletedStates[t2][a2] = null;
            else this.deletedStates[t2] = null;
          }
          getState(t2, i2) {
            const a2 = String(i2), s2 = e.e({}, (this.state[t2] || {})[a2], (this.stateChanges[t2] || {})[a2]);
            if (null === this.deletedStates[t2]) return {};
            if (this.deletedStates[t2]) {
              const e2 = this.deletedStates[t2][i2];
              if (null === e2) return {};
              for (const t3 in e2) delete s2[t3];
            }
            return s2;
          }
          initializeTileState(t2, e2) {
            t2.setFeatureState(this.state, e2);
          }
          coalesceChanges(t2, i2) {
            const a2 = {};
            for (const t3 in this.stateChanges) {
              this.state[t3] = this.state[t3] || {};
              const i3 = {};
              for (const a3 in this.stateChanges[t3]) this.state[t3][a3] || (this.state[t3][a3] = {}), e.e(this.state[t3][a3], this.stateChanges[t3][a3]), i3[a3] = this.state[t3][a3];
              a2[t3] = i3;
            }
            for (const t3 in this.deletedStates) {
              this.state[t3] = this.state[t3] || {};
              const i3 = {};
              if (null === this.deletedStates[t3]) for (const e2 in this.state[t3]) i3[e2] = {}, this.state[t3][e2] = {};
              else for (const e2 in this.deletedStates[t3]) {
                if (null === this.deletedStates[t3][e2]) this.state[t3][e2] = {};
                else for (const i4 of Object.keys(this.deletedStates[t3][e2])) delete this.state[t3][e2][i4];
                i3[e2] = this.state[t3][e2];
              }
              a2[t3] = a2[t3] || {}, e.e(a2[t3], i3);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(a2).length) for (const e2 in t2) t2[e2].setFeatureState(a2, i2);
          }
        }
        class ut2 extends e.E {
          constructor(t2, e2, i2) {
            super(), this.id = t2, this.dispatcher = i2, this.on("data", (t3) => this._dataHandler(t3)), this.on("dataloading", () => {
              this._sourceErrored = false;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((t3, e3, i3, a2) => {
              const s2 = new (at2(e3.type))(t3, e3, i3, a2);
              if (s2.id !== t3) throw new Error("Expected Source id to be ".concat(t3, " instead of ").concat(s2.id));
              return s2;
            })(t2, e2, i2, this), this._tiles = {}, this._cache = new ht2(0, (t3) => this._unloadTile(t3)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ct2(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(t2) {
            this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t2 ? t2._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t2);
          }
          onRemove(t2) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t2);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded) return false;
            if (!this._source.loaded()) return false;
            if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const t2 in this._tiles) {
              const e2 = this._tiles[t2];
              if ("loaded" !== e2.state && "errored" !== e2.state) return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const t2 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t2, i2, a2) {
            return e._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(t2), this._tileLoaded(t2, i2, a2);
              } catch (i3) {
                t2.state = "errored", 404 !== i3.status ? this._source.fire(new e.j(i3, { tile: t2 })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(t2) {
            this._source.unloadTile && this._source.unloadTile(t2);
          }
          _abortTile(t2) {
            this._source.abortTile && this._source.abortTile(t2), this._source.fire(new e.k("dataabort", { tile: t2, coord: t2.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t2) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e2 in this._tiles) {
              const i2 = this._tiles[e2];
              i2.upload(t2), i2.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((t2) => t2.tileID).sort(dt2).map((t2) => t2.key);
          }
          getRenderableIds(t2) {
            const i2 = [];
            for (const e2 in this._tiles) this._isIdRenderable(e2, t2) && i2.push(this._tiles[e2]);
            return t2 ? i2.sort((t3, i3) => {
              const a2 = t3.tileID, s2 = i3.tileID, o2 = new e.P(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle), r2 = new e.P(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle);
              return a2.overscaledZ - s2.overscaledZ || r2.y - o2.y || r2.x - o2.x;
            }).map((t3) => t3.tileID.key) : i2.map((t3) => t3.tileID).sort(dt2).map((t3) => t3.key);
          }
          hasRenderableParent(t2) {
            const e2 = this.findLoadedParent(t2, 0);
            return !!e2 && this._isIdRenderable(e2.tileID.key);
          }
          _isIdRenderable(t2, e2) {
            return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
          }
          reload() {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t2 in this._tiles) "errored" !== this._tiles[t2].state && this._reloadTile(t2, "reloading");
            }
          }
          _reloadTile(t2, i2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = this._tiles[t2];
              e2 && ("loading" !== e2.state && (e2.state = i2), yield this._loadTile(e2, t2, i2));
            });
          }
          _tileLoaded(t2, i2, a2) {
            t2.timeAdded = o.now(), "expired" === a2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, t2), "raster-dem" === this.getSource().type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), t2.aborted || this._source.fire(new e.k("data", { dataType: "source", tile: t2, coord: t2.tileID }));
          }
          _backfillDEM(t2) {
            const e2 = this.getRenderableIds();
            for (let a2 = 0; a2 < e2.length; a2++) {
              const s2 = e2[a2];
              if (t2.neighboringTiles && t2.neighboringTiles[s2]) {
                const e3 = this.getTileByID(s2);
                i2(t2, e3), i2(e3, t2);
              }
            }
            function i2(t3, e3) {
              t3.needsHillshadePrepare = true, t3.needsTerrainPrepare = true;
              let i3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
              const a2 = e3.tileID.canonical.y - t3.tileID.canonical.y, s2 = Math.pow(2, t3.tileID.canonical.z), o2 = e3.tileID.key;
              0 === i3 && 0 === a2 || Math.abs(a2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + s2) ? i3 += s2 : 1 === Math.abs(i3 - s2) && (i3 -= s2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, i3, a2), t3.neighboringTiles && t3.neighboringTiles[o2] && (t3.neighboringTiles[o2].backfilled = true)));
            }
          }
          getTile(t2) {
            return this.getTileByID(t2.key);
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          _retainLoadedChildren(t2, e2, i2, a2) {
            for (const s2 in this._tiles) {
              let o2 = this._tiles[s2];
              if (a2[s2] || !o2.hasData() || o2.tileID.overscaledZ <= e2 || o2.tileID.overscaledZ > i2) continue;
              let r2 = o2.tileID;
              for (; o2 && o2.tileID.overscaledZ > e2 + 1; ) {
                const t3 = o2.tileID.scaledTo(o2.tileID.overscaledZ - 1);
                o2 = this._tiles[t3.key], o2 && o2.hasData() && (r2 = t3);
              }
              let n2 = r2;
              for (; n2.overscaledZ > e2; ) if (n2 = n2.scaledTo(n2.overscaledZ - 1), t2[n2.key]) {
                a2[r2.key] = r2;
                break;
              }
            }
          }
          findLoadedParent(t2, e2) {
            if (t2.key in this._loadedParentTiles) {
              const i2 = this._loadedParentTiles[t2.key];
              return i2 && i2.tileID.overscaledZ >= e2 ? i2 : null;
            }
            for (let i2 = t2.overscaledZ - 1; i2 >= e2; i2--) {
              const e3 = t2.scaledTo(i2), a2 = this._getLoadedTile(e3);
              if (a2) return a2;
            }
          }
          findLoadedSibling(t2) {
            return this._getLoadedTile(t2);
          }
          _getLoadedTile(t2) {
            const e2 = this._tiles[t2.key];
            return e2 && e2.hasData() ? e2 : this._cache.getByKey(t2.wrapped().key);
          }
          updateCacheSize(t2) {
            const i2 = Math.ceil(t2.width / this._source.tileSize) + 1, a2 = Math.ceil(t2.height / this._source.tileSize) + 1, s2 = Math.floor(i2 * a2 * (null === this._maxTileCacheZoomLevels ? e.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s2) : s2;
            this._cache.setMaxSize(o2);
          }
          handleWrapJump(t2) {
            const e2 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
            if (this._prevLng = t2, e2) {
              const t3 = {};
              for (const i2 in this._tiles) {
                const a2 = this._tiles[i2];
                a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e2), t3[a2.tileID.key] = a2;
              }
              this._tiles = t3;
              for (const t4 in this._timers) clearTimeout(this._timers[t4]), delete this._timers[t4];
              for (const t4 in this._tiles) this._setTileReloadTimer(t4, this._tiles[t4]);
            }
          }
          _updateCoveredAndRetainedTiles(t2, e2, i2, a2, s2, r2) {
            const n2 = {}, l3 = {}, h2 = Object.keys(t2), c2 = o.now();
            for (const i3 of h2) {
              const a3 = t2[i3], s3 = this._tiles[i3];
              if (!s3 || 0 !== s3.fadeEndTime && s3.fadeEndTime <= c2) continue;
              const o2 = this.findLoadedParent(a3, e2), r3 = this.findLoadedSibling(a3), h3 = o2 || r3 || null;
              h3 && (this._addTile(h3.tileID), n2[h3.tileID.key] = h3.tileID), l3[i3] = a3;
            }
            this._retainLoadedChildren(l3, a2, i2, t2);
            for (const e3 in n2) t2[e3] || (this._coveredTiles[e3] = true, t2[e3] = n2[e3]);
            if (r2) {
              const e3 = {}, i3 = {};
              for (const t3 of s2) this._tiles[t3.key].hasData() ? e3[t3.key] = t3 : i3[t3.key] = t3;
              for (const a3 in i3) {
                const s3 = i3[a3].children(this._source.maxzoom);
                this._tiles[s3[0].key] && this._tiles[s3[1].key] && this._tiles[s3[2].key] && this._tiles[s3[3].key] && (e3[s3[0].key] = t2[s3[0].key] = s3[0], e3[s3[1].key] = t2[s3[1].key] = s3[1], e3[s3[2].key] = t2[s3[2].key] = s3[2], e3[s3[3].key] = t2[s3[3].key] = s3[3], delete i3[a3]);
              }
              for (const a3 in i3) {
                const s3 = i3[a3], o2 = this.findLoadedParent(s3, this._source.minzoom), r3 = this.findLoadedSibling(s3), n3 = o2 || r3 || null;
                if (n3) {
                  e3[n3.tileID.key] = t2[n3.tileID.key] = n3.tileID;
                  for (const t3 in e3) e3[t3].isChildOf(n3.tileID) && delete e3[t3];
                }
              }
              for (const t3 in this._tiles) e3[t3] || (this._coveredTiles[t3] = true);
            }
          }
          update(t2, i2) {
            if (!this._sourceLoaded || this._paused) return;
            let a2;
            this.transform = t2, this.terrain = i2, this.updateCacheSize(t2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? a2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e.S(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (a2 = t2.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2 }), this._source.hasTile && (a2 = a2.filter((t3) => this._source.hasTile(t3)))) : a2 = [];
            const s2 = t2.coveringZoomLevel(this._source), o2 = Math.max(s2 - ut2.maxOverzooming, this._source.minzoom), r2 = Math.max(s2 + ut2.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const t3 = {};
              for (const e2 of a2) if (e2.canonical.z > this._source.minzoom) {
                const i3 = e2.scaledTo(e2.canonical.z - 1);
                t3[i3.key] = i3;
                const a3 = e2.scaledTo(Math.max(this._source.minzoom, Math.min(e2.canonical.z, 5)));
                t3[a3.key] = a3;
              }
              a2 = a2.concat(Object.values(t3));
            }
            const n2 = 0 === a2.length && !this._updated && this._didEmitContent;
            this._updated = true, n2 && this.fire(new e.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const l3 = this._updateRetainedTiles(a2, s2);
            _t2(this._source.type) && this._updateCoveredAndRetainedTiles(l3, o2, r2, s2, a2, i2);
            for (const t3 in l3) this._tiles[t3].clearFadeHold();
            const h2 = e.ab(this._tiles, l3);
            for (const t3 of h2) {
              const e2 = this._tiles[t3];
              e2.hasSymbolBuckets && !e2.holdingForFade() ? e2.setHoldDuration(this.map._fadeDuration) : e2.hasSymbolBuckets && !e2.symbolFadeFinished() || this._removeTile(t3);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const t2 in this._tiles) this._tiles[t2].holdingForFade() && this._removeTile(t2);
          }
          _updateRetainedTiles(t2, e2) {
            var i2;
            const a2 = {}, s2 = {}, o2 = Math.max(e2 - ut2.maxOverzooming, this._source.minzoom), r2 = Math.max(e2 + ut2.maxUnderzooming, this._source.minzoom), n2 = {};
            for (const i3 of t2) {
              const t3 = this._addTile(i3);
              a2[i3.key] = i3, t3.hasData() || e2 < this._source.maxzoom && (n2[i3.key] = i3);
            }
            this._retainLoadedChildren(n2, e2, r2, a2);
            for (const r3 of t2) {
              let t3 = this._tiles[r3.key];
              if (t3.hasData()) continue;
              if (e2 + 1 > this._source.maxzoom) {
                const t4 = r3.children(this._source.maxzoom)[0], e3 = this.getTile(t4);
                if (e3 && e3.hasData()) {
                  a2[t4.key] = t4;
                  continue;
                }
              } else {
                const t4 = r3.children(this._source.maxzoom);
                if (a2[t4[0].key] && a2[t4[1].key] && a2[t4[2].key] && a2[t4[3].key]) continue;
              }
              let n3 = t3.wasRequested();
              for (let e3 = r3.overscaledZ - 1; e3 >= o2; --e3) {
                const o3 = r3.scaledTo(e3);
                if (s2[o3.key]) break;
                if (s2[o3.key] = true, t3 = this.getTile(o3), !t3 && n3 && (t3 = this._addTile(o3)), t3) {
                  const e4 = t3.hasData();
                  if ((e4 || !(null === (i2 = this.map) || void 0 === i2 ? void 0 : i2.cancelPendingTileRequestsWhileZooming) || n3) && (a2[o3.key] = o3), n3 = t3.wasRequested(), e4) break;
                }
              }
            }
            return a2;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t2 in this._tiles) {
              const e2 = [];
              let i2, a2 = this._tiles[t2].tileID;
              for (; a2.overscaledZ > 0; ) {
                if (a2.key in this._loadedParentTiles) {
                  i2 = this._loadedParentTiles[a2.key];
                  break;
                }
                e2.push(a2.key);
                const t3 = a2.scaledTo(a2.overscaledZ - 1);
                if (i2 = this._getLoadedTile(t3), i2) break;
                a2 = t3;
              }
              for (const t3 of e2) this._loadedParentTiles[t3] = i2;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const t2 in this._tiles) {
              const e2 = this._tiles[t2].tileID, i2 = this._getLoadedTile(e2);
              this._loadedSiblingTiles[e2.key] = i2;
            }
          }
          _addTile(t2) {
            let i2 = this._tiles[t2.key];
            if (i2) return i2;
            i2 = this._cache.getAndRemove(t2), i2 && (this._setTileReloadTimer(t2.key, i2), i2.tileID = t2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, i2)));
            const a2 = i2;
            return i2 || (i2 = new lt2(t2, this._source.tileSize * t2.overscaleFactor()), this._loadTile(i2, t2.key, i2.state)), i2.uses++, this._tiles[t2.key] = i2, a2 || this._source.fire(new e.k("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
          }
          _setTileReloadTimer(t2, e2) {
            t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
            const i2 = e2.getExpiryTimeout();
            i2 && (this._timers[t2] = setTimeout(() => {
              this._reloadTile(t2, "expired"), delete this._timers[t2];
            }, i2));
          }
          _removeTile(t2) {
            const e2 = this._tiles[t2];
            e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
          }
          _dataHandler(t2) {
            const e2 = t2.sourceDataType;
            "source" === t2.dataType && "metadata" === e2 && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t2.dataType && "content" === e2 && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t2 in this._tiles) this._removeTile(t2);
            this._cache.reset();
          }
          tilesIn(t2, i2, a2) {
            const s2 = [], o2 = this.transform;
            if (!o2) return s2;
            const r2 = a2 ? o2.getCameraQueryGeometry(t2) : t2, n2 = t2.map((t3) => o2.pointCoordinate(t3, this.terrain)), l3 = r2.map((t3) => o2.pointCoordinate(t3, this.terrain)), h2 = this.getIds();
            let c2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0;
            for (const t3 of l3) c2 = Math.min(c2, t3.x), u2 = Math.min(u2, t3.y), d2 = Math.max(d2, t3.x), _2 = Math.max(_2, t3.y);
            for (let t3 = 0; t3 < h2.length; t3++) {
              const a3 = this._tiles[h2[t3]];
              if (a3.holdingForFade()) continue;
              const r3 = a3.tileID, p2 = Math.pow(2, o2.zoom - a3.tileID.overscaledZ), m2 = i2 * a3.queryPadding * e.X / a3.tileSize / p2, f2 = [r3.getTilePoint(new e.Z(c2, u2)), r3.getTilePoint(new e.Z(d2, _2))];
              if (f2[0].x - m2 < e.X && f2[0].y - m2 < e.X && f2[1].x + m2 >= 0 && f2[1].y + m2 >= 0) {
                const t4 = n2.map((t5) => r3.getTilePoint(t5)), e2 = l3.map((t5) => r3.getTilePoint(t5));
                s2.push({ tile: a3, tileID: r3, queryGeometry: t4, cameraQueryGeometry: e2, scale: p2 });
              }
            }
            return s2;
          }
          getVisibleCoordinates(t2) {
            const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
            for (const t3 of e2) t3.posMatrix = this.transform.calculatePosMatrix(t3.toUnwrapped());
            return e2;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (_t2(this._source.type)) {
              const t2 = o.now();
              for (const e2 in this._tiles) if (this._tiles[e2].fadeEndTime >= t2) return true;
            }
            return false;
          }
          setFeatureState(t2, e2, i2) {
            this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, i2);
          }
          removeFeatureState(t2, e2, i2) {
            this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, i2);
          }
          getFeatureState(t2, e2) {
            return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
          }
          setDependencies(t2, e2, i2) {
            const a2 = this._tiles[t2];
            a2 && a2.setDependencies(e2, i2);
          }
          reloadTilesForDependencies(t2, e2) {
            for (const i2 in this._tiles) this._tiles[i2].hasDependency(t2, e2) && this._reloadTile(i2, "reloading");
            this._cache.filter((i2) => !i2.hasDependency(t2, e2));
          }
        }
        function dt2(t2, e2) {
          const i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), a2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t2.overscaledZ - e2.overscaledZ || a2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
        }
        function _t2(t2) {
          return "raster" === t2 || "image" === t2 || "video" === t2;
        }
        ut2.maxOverzooming = 10, ut2.maxUnderzooming = 3;
        class pt2 {
          constructor(t2, e2) {
            this.reset(t2, e2);
          }
          reset(t2, e2) {
            this.points = t2 || [], this._distances = [0];
            for (let t3 = 1; t3 < this.points.length; t3++) this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t2) {
            if (1 === this.points.length) return this.points[0];
            t2 = e.ac(t2, 0, 1);
            let i2 = 1, a2 = this._distances[i2];
            const s2 = t2 * this.paddedLength + this.padding;
            for (; a2 < s2 && i2 < this._distances.length; ) a2 = this._distances[++i2];
            const o2 = i2 - 1, r2 = this._distances[o2], n2 = a2 - r2, l3 = n2 > 0 ? (s2 - r2) / n2 : 0;
            return this.points[o2].mult(1 - l3).add(this.points[i2].mult(l3));
          }
        }
        function mt2(t2, e2) {
          let i2 = true;
          return "always" === t2 || "never" !== t2 && "never" !== e2 || (i2 = false), i2;
        }
        class ft2 {
          constructor(t2, e2, i2) {
            const a2 = this.boxCells = [], s2 = this.circleCells = [];
            this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
            for (let t3 = 0; t3 < this.xCellCount * this.yCellCount; t3++) a2.push([]), s2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t2, e2, i2, a2, s2) {
            this._forEachCell(e2, i2, a2, s2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(a2), this.bboxes.push(s2);
          }
          insertCircle(t2, e2, i2, a2) {
            this._forEachCell(e2 - a2, i2 - a2, e2 + a2, i2 + a2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(a2);
          }
          _insertBoxCell(t2, e2, i2, a2, s2, o2) {
            this.boxCells[s2].push(o2);
          }
          _insertCircleCell(t2, e2, i2, a2, s2, o2) {
            this.circleCells[s2].push(o2);
          }
          _query(t2, e2, i2, a2, s2, o2, r2) {
            if (i2 < 0 || t2 > this.width || a2 < 0 || e2 > this.height) return [];
            const n2 = [];
            if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= a2) {
              if (s2) return [{ key: null, x1: t2, y1: e2, x2: i2, y2: a2 }];
              for (let t3 = 0; t3 < this.boxKeys.length; t3++) n2.push({ key: this.boxKeys[t3], x1: this.bboxes[4 * t3], y1: this.bboxes[4 * t3 + 1], x2: this.bboxes[4 * t3 + 2], y2: this.bboxes[4 * t3 + 3] });
              for (let t3 = 0; t3 < this.circleKeys.length; t3++) {
                const e3 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], a3 = this.circles[3 * t3 + 2];
                n2.push({ key: this.circleKeys[t3], x1: e3 - a3, y1: i3 - a3, x2: e3 + a3, y2: i3 + a3 });
              }
            } else this._forEachCell(t2, e2, i2, a2, this._queryCell, n2, { hitTest: s2, overlapMode: o2, seenUids: { box: {}, circle: {} } }, r2);
            return n2;
          }
          query(t2, e2, i2, a2) {
            return this._query(t2, e2, i2, a2, false, null);
          }
          hitTest(t2, e2, i2, a2, s2, o2) {
            return this._query(t2, e2, i2, a2, true, s2, o2).length > 0;
          }
          hitTestCircle(t2, e2, i2, a2, s2) {
            const o2 = t2 - i2, r2 = t2 + i2, n2 = e2 - i2, l3 = e2 + i2;
            if (r2 < 0 || o2 > this.width || l3 < 0 || n2 > this.height) return false;
            const h2 = [];
            return this._forEachCell(o2, n2, r2, l3, this._queryCellCircle, h2, { hitTest: true, overlapMode: a2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } }, s2), h2.length > 0;
          }
          _queryCell(t2, e2, i2, a2, s2, o2, r2, n2) {
            const { seenUids: l3, hitTest: h2, overlapMode: c2 } = r2, u2 = this.boxCells[s2];
            if (null !== u2) {
              const s3 = this.bboxes;
              for (const r3 of u2) if (!l3.box[r3]) {
                l3.box[r3] = true;
                const u3 = 4 * r3, d3 = this.boxKeys[r3];
                if (t2 <= s3[u3 + 2] && e2 <= s3[u3 + 3] && i2 >= s3[u3 + 0] && a2 >= s3[u3 + 1] && (!n2 || n2(d3)) && (!h2 || !mt2(c2, d3.overlapMode)) && (o2.push({ key: d3, x1: s3[u3], y1: s3[u3 + 1], x2: s3[u3 + 2], y2: s3[u3 + 3] }), h2)) return true;
              }
            }
            const d2 = this.circleCells[s2];
            if (null !== d2) {
              const s3 = this.circles;
              for (const r3 of d2) if (!l3.circle[r3]) {
                l3.circle[r3] = true;
                const u3 = 3 * r3, d3 = this.circleKeys[r3];
                if (this._circleAndRectCollide(s3[u3], s3[u3 + 1], s3[u3 + 2], t2, e2, i2, a2) && (!n2 || n2(d3)) && (!h2 || !mt2(c2, d3.overlapMode))) {
                  const t3 = s3[u3], e3 = s3[u3 + 1], i3 = s3[u3 + 2];
                  if (o2.push({ key: d3, x1: t3 - i3, y1: e3 - i3, x2: t3 + i3, y2: e3 + i3 }), h2) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(t2, e2, i2, a2, s2, o2, r2, n2) {
            const { circle: l3, seenUids: h2, overlapMode: c2 } = r2, u2 = this.boxCells[s2];
            if (null !== u2) {
              const t3 = this.bboxes;
              for (const e3 of u2) if (!h2.box[e3]) {
                h2.box[e3] = true;
                const i3 = 4 * e3, a3 = this.boxKeys[e3];
                if (this._circleAndRectCollide(l3.x, l3.y, l3.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!n2 || n2(a3)) && !mt2(c2, a3.overlapMode)) return o2.push(true), true;
              }
            }
            const d2 = this.circleCells[s2];
            if (null !== d2) {
              const t3 = this.circles;
              for (const e3 of d2) if (!h2.circle[e3]) {
                h2.circle[e3] = true;
                const i3 = 3 * e3, a3 = this.circleKeys[e3];
                if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l3.x, l3.y, l3.radius) && (!n2 || n2(a3)) && !mt2(c2, a3.overlapMode)) return o2.push(true), true;
              }
            }
          }
          _forEachCell(t2, e2, i2, a2, s2, o2, r2, n2) {
            const l3 = this._convertToXCellCoord(t2), h2 = this._convertToYCellCoord(e2), c2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(a2);
            for (let d2 = l3; d2 <= c2; d2++) for (let l4 = h2; l4 <= u2; l4++) if (s2.call(this, t2, e2, i2, a2, this.xCellCount * l4 + d2, o2, r2, n2)) return;
          }
          _convertToXCellCoord(t2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
          }
          _convertToYCellCoord(t2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
          }
          _circlesCollide(t2, e2, i2, a2, s2, o2) {
            const r2 = a2 - t2, n2 = s2 - e2, l3 = i2 + o2;
            return l3 * l3 > r2 * r2 + n2 * n2;
          }
          _circleAndRectCollide(t2, e2, i2, a2, s2, o2, r2) {
            const n2 = (o2 - a2) / 2, l3 = Math.abs(t2 - (a2 + n2));
            if (l3 > n2 + i2) return false;
            const h2 = (r2 - s2) / 2, c2 = Math.abs(e2 - (s2 + h2));
            if (c2 > h2 + i2) return false;
            if (l3 <= n2 || c2 <= h2) return true;
            const u2 = l3 - n2, d2 = c2 - h2;
            return u2 * u2 + d2 * d2 <= i2 * i2;
          }
        }
        function gt2(t2, i2, a2, s2, o2) {
          const r2 = e.H();
          return i2 ? (e.K(r2, r2, [1 / o2, 1 / o2, 1]), a2 || e.ad(r2, r2, s2.angle)) : e.L(r2, s2.labelPlaneMatrix, t2), r2;
        }
        function vt2(t2, i2, a2, s2, o2) {
          if (i2) {
            const i3 = e.ae(t2);
            return e.K(i3, i3, [o2, o2, 1]), a2 || e.ad(i3, i3, -s2.angle), i3;
          }
          return s2.glCoordMatrix;
        }
        function xt2(t2, i2, a2, s2) {
          let o2;
          s2 ? (o2 = [t2, i2, s2(t2, i2), 1], e.af(o2, o2, a2)) : (o2 = [t2, i2, 0, 1], kt(o2, o2, a2));
          const r2 = o2[3];
          return { point: new e.P(o2[0] / r2, o2[1] / r2), signedDistanceFromCamera: r2, isOccluded: false };
        }
        function yt2(t2, e2) {
          return 0.5 + t2 / e2 * 0.5;
        }
        function bt2(t2, e2) {
          return t2.x >= -e2[0] && t2.x <= e2[0] && t2.y >= -e2[1] && t2.y <= e2[1];
        }
        function wt2(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2, p2, m2) {
          const f2 = s2 ? t2.textSizeData : t2.iconSizeData, g2 = e.ag(f2, a2.transform.zoom), v2 = [256 / a2.width * 2 + 1, 256 / a2.height * 2 + 1], x2 = s2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
          x2.clear();
          const y3 = t2.lineVertexArray, b2 = s2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, w2 = a2.transform.width / a2.transform.height;
          let T2 = false;
          for (let s3 = 0; s3 < b2.length; s3++) {
            const I2 = b2.get(s3);
            if (I2.hidden || I2.writingMode === e.ah.vertical && !T2) {
              Rt2(I2.numGlyphs, x2);
              continue;
            }
            T2 = false;
            const E2 = xt2(I2.anchorX, I2.anchorY, i2, m2);
            if (!bt2(E2.point, v2)) {
              Rt2(I2.numGlyphs, x2);
              continue;
            }
            const P2 = yt2(a2.transform.cameraToCenterDistance, E2.signedDistanceFromCamera), C3 = e.ai(f2, g2, I2), S2 = n2 ? C3 / P2 : C3 * P2, z3 = { getElevation: m2, labelPlaneMatrix: o2, lineVertexArray: y3, pitchWithMap: n2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, projection: c2, tileAnchorPoint: new e.P(I2.anchorX, I2.anchorY), unwrappedTileID: u2, width: d2, height: _2, translation: p2 }, D2 = Et2(z3, I2, S2, false, l3, i2, r2, t2.glyphOffsetArray, x2, w2, h2);
            T2 = D2.useVertical, (D2.notEnoughRoom || T2 || D2.needsFlipping && Et2(z3, I2, S2, true, l3, i2, r2, t2.glyphOffsetArray, x2, w2, h2).notEnoughRoom) && Rt2(I2.numGlyphs, x2);
          }
          s2 ? t2.text.dynamicLayoutVertexBuffer.updateData(x2) : t2.icon.dynamicLayoutVertexBuffer.updateData(x2);
        }
        function Tt2(t2, e2, i2, a2, s2, o2, r2, n2) {
          const l3 = o2.glyphStartIndex + o2.numGlyphs, h2 = o2.lineStartIndex, c2 = o2.lineStartIndex + o2.lineLength, u2 = e2.getoffsetX(o2.glyphStartIndex), d2 = e2.getoffsetX(l3 - 1), _2 = Mt2(t2 * u2, i2, a2, s2, o2.segment, h2, c2, n2, r2);
          if (!_2) return null;
          const p2 = Mt2(t2 * d2, i2, a2, s2, o2.segment, h2, c2, n2, r2);
          return p2 ? n2.projectionCache.anyProjectionOccluded ? null : { first: _2, last: p2 } : null;
        }
        function It2(t2, i2, a2, s2) {
          return t2 === e.ah.horizontal && Math.abs(a2.y - i2.y) > Math.abs(a2.x - i2.x) * s2 ? { useVertical: true } : (t2 === e.ah.vertical ? i2.y < a2.y : i2.x > a2.x) ? { needsFlipping: true } : null;
        }
        function Et2(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2) {
          const d2 = a2 / 24, _2 = i2.lineOffsetX * d2, p2 = i2.lineOffsetY * d2;
          let m2;
          if (i2.numGlyphs > 1) {
            const e2 = i2.glyphStartIndex + i2.numGlyphs, a3 = i2.lineStartIndex, r3 = i2.lineStartIndex + i2.lineLength, h3 = Tt2(d2, l3, _2, p2, s2, i2, u2, t2);
            if (!h3) return { notEnoughRoom: true };
            const f2 = xt2(h3.first.point.x, h3.first.point.y, n2, t2.getElevation).point, g2 = xt2(h3.last.point.x, h3.last.point.y, n2, t2.getElevation).point;
            if (o2 && !s2) {
              const t3 = It2(i2.writingMode, f2, g2, c2);
              if (t3) return t3;
            }
            m2 = [h3.first];
            for (let o3 = i2.glyphStartIndex + 1; o3 < e2 - 1; o3++) m2.push(Mt2(d2 * l3.getoffsetX(o3), _2, p2, s2, i2.segment, a3, r3, t2, u2));
            m2.push(h3.last);
          } else {
            if (o2 && !s2) {
              const a4 = xt2(t2.tileAnchorPoint.x, t2.tileAnchorPoint.y, r2, t2.getElevation).point, s3 = i2.lineStartIndex + i2.segment + 1, o3 = new e.P(t2.lineVertexArray.getx(s3), t2.lineVertexArray.gety(s3)), n3 = xt2(o3.x, o3.y, r2, t2.getElevation), l4 = n3.signedDistanceFromCamera > 0 ? n3.point : function(t3, e2, i3, a5, s4, o4) {
                return Pt2(t3, e2, i3, 1, s4, o4);
              }(t2.tileAnchorPoint, o3, a4, 0, r2, t2), h3 = It2(i2.writingMode, a4, l4, c2);
              if (h3) return h3;
            }
            const a3 = Mt2(d2 * l3.getoffsetX(i2.glyphStartIndex), _2, p2, s2, i2.segment, i2.lineStartIndex, i2.lineStartIndex + i2.lineLength, t2, u2);
            if (!a3 || t2.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            m2 = [a3];
          }
          for (const t3 of m2) e.aj(h2, t3.point, t3.angle);
          return {};
        }
        function Pt2(t2, e2, i2, a2, s2, o2) {
          const r2 = t2.add(t2.sub(e2)._unit()), n2 = void 0 !== s2 ? xt2(r2.x, r2.y, s2, o2.getElevation).point : St2(r2.x, r2.y, o2).point, l3 = i2.sub(n2);
          return i2.add(l3._mult(a2 / l3.mag()));
        }
        function Ct2(t2, i2, a2) {
          const s2 = i2.projectionCache;
          if (s2.projections[t2]) return s2.projections[t2];
          const o2 = new e.P(i2.lineVertexArray.getx(t2), i2.lineVertexArray.gety(t2)), r2 = St2(o2.x, o2.y, i2);
          if (r2.signedDistanceFromCamera > 0) return s2.projections[t2] = r2.point, s2.anyProjectionOccluded = s2.anyProjectionOccluded || r2.isOccluded, r2.point;
          const n2 = t2 - a2.direction;
          return function(t3, e2, i3, a3, s3) {
            return Pt2(t3, e2, i3, a3, void 0, s3);
          }(0 === a2.distanceFromAnchor ? i2.tileAnchorPoint : new e.P(i2.lineVertexArray.getx(n2), i2.lineVertexArray.gety(n2)), o2, a2.previousVertex, a2.absOffsetX - a2.distanceFromAnchor + 1, i2);
        }
        function St2(t2, e2, i2) {
          const a2 = t2 + i2.translation[0], s2 = e2 + i2.translation[1];
          let o2;
          return !i2.pitchWithMap && i2.projection.useSpecialProjectionForSymbols ? (o2 = i2.projection.projectTileCoordinates(a2, s2, i2.unwrappedTileID, i2.getElevation), o2.point.x = (0.5 * o2.point.x + 0.5) * i2.width, o2.point.y = (0.5 * -o2.point.y + 0.5) * i2.height) : (o2 = xt2(a2, s2, i2.labelPlaneMatrix, i2.getElevation), o2.isOccluded = false), o2;
        }
        function zt2(t2, e2, i2) {
          return t2._unit()._perp()._mult(e2 * i2);
        }
        function Dt2(t2, i2, a2, s2, o2, r2, n2, l3, h2) {
          if (l3.projectionCache.offsets[t2]) return l3.projectionCache.offsets[t2];
          const c2 = a2.add(i2);
          if (t2 + h2.direction < s2 || t2 + h2.direction >= o2) return l3.projectionCache.offsets[t2] = c2, c2;
          const u2 = Ct2(t2 + h2.direction, l3, h2), d2 = zt2(u2.sub(a2), n2, h2.direction), _2 = a2.add(d2), p2 = u2.add(d2);
          return l3.projectionCache.offsets[t2] = e.ak(r2, c2, _2, p2) || c2, l3.projectionCache.offsets[t2];
        }
        function Mt2(t2, e2, i2, a2, s2, o2, r2, n2, l3) {
          const h2 = a2 ? t2 - e2 : t2 + e2;
          let c2 = h2 > 0 ? 1 : -1, u2 = 0;
          a2 && (c2 *= -1, u2 = Math.PI), c2 < 0 && (u2 += Math.PI);
          let d2, _2 = c2 > 0 ? o2 + s2 : o2 + s2 + 1;
          n2.projectionCache.cachedAnchorPoint ? d2 = n2.projectionCache.cachedAnchorPoint : (d2 = St2(n2.tileAnchorPoint.x, n2.tileAnchorPoint.y, n2).point, n2.projectionCache.cachedAnchorPoint = d2);
          let p2, m2, f2 = d2, g2 = d2, v2 = 0, x2 = 0;
          const y3 = Math.abs(h2), b2 = [];
          let w2;
          for (; v2 + x2 <= y3; ) {
            if (_2 += c2, _2 < o2 || _2 >= r2) return null;
            v2 += x2, g2 = f2, m2 = p2;
            const t3 = { absOffsetX: y3, direction: c2, distanceFromAnchor: v2, previousVertex: g2 };
            if (f2 = Ct2(_2, n2, t3), 0 === i2) b2.push(g2), w2 = f2.sub(g2);
            else {
              let e3;
              const a3 = f2.sub(g2);
              e3 = 0 === a3.mag() ? zt2(Ct2(_2 + c2, n2, t3).sub(f2), i2, c2) : zt2(a3, i2, c2), m2 || (m2 = g2.add(e3)), p2 = Dt2(_2, e3, f2, o2, r2, m2, i2, n2, t3), b2.push(m2), w2 = p2.sub(m2);
            }
            x2 = w2.mag();
          }
          const T2 = w2._mult((y3 - v2) / x2)._add(m2 || g2), I2 = u2 + Math.atan2(f2.y - g2.y, f2.x - g2.x);
          return b2.push(T2), { point: T2, angle: l3 ? I2 : 0, path: b2 };
        }
        const At2 = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Rt2(t2, e2) {
          for (let i2 = 0; i2 < t2; i2++) {
            const t3 = e2.length;
            e2.resize(t3 + 4), e2.float32.set(At2, 3 * t3);
          }
        }
        function kt(t2, e2, i2) {
          const a2 = e2[0], s2 = e2[1];
          return t2[0] = i2[0] * a2 + i2[4] * s2 + i2[12], t2[1] = i2[1] * a2 + i2[5] * s2 + i2[13], t2[3] = i2[3] * a2 + i2[7] * s2 + i2[15], t2;
        }
        const Lt2 = 100;
        class Ft2 {
          constructor(t2, e2, i2 = new ft2(t2.width + 200, t2.height + 200, 25), a2 = new ft2(t2.width + 200, t2.height + 200, 25)) {
            this.transform = t2, this.mapProjection = e2, this.grid = i2, this.ignoredGrid = a2, this.pitchFactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + Lt2, this.screenBottomBoundary = t2.height + Lt2, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t2, e2, i2, a2, s2, o2, r2, n2, l3, h2, c2) {
            const u2 = t2.anchorPointX + n2[0], d2 = t2.anchorPointY + n2[1], _2 = this.projectAndGetPerspectiveRatio(a2, u2, d2, s2, h2), p2 = i2 * _2.perspectiveRatio;
            let m2;
            if (o2 || r2) m2 = this._projectCollisionBox(t2, p2, a2, s2, o2, r2, n2, _2, h2, c2);
            else {
              const e3 = _2.point.x + (c2 ? c2.x * p2 : 0), i3 = _2.point.y + (c2 ? c2.y * p2 : 0);
              m2 = { allPointsOccluded: false, box: [e3 + t2.x1 * p2, i3 + t2.y1 * p2, e3 + t2.x2 * p2, i3 + t2.y2 * p2] };
            }
            const [f2, g2, v2, x2] = m2.box;
            return this.mapProjection.useSpecialProjectionForSymbols && (o2 ? m2.allPointsOccluded : this.mapProjection.isOccluded(u2, d2, s2)) || _2.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(f2, g2, v2, x2) || "always" !== e2 && this.grid.hitTest(f2, g2, v2, x2, e2, l3) ? { box: [f2, g2, v2, x2], placeable: false, offscreen: false } : { box: [f2, g2, v2, x2], placeable: true, offscreen: this.isOffscreen(f2, g2, v2, x2) };
          }
          placeCollisionCircles(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2, p2, m2, f2) {
            const g2 = [], v2 = new e.P(i2.anchorX, i2.anchorY), x2 = this.getPerspectiveRatio(r2, v2.x, v2.y, n2, f2), y3 = (u2 ? o2 / x2 : o2 * x2) / e.ap, b2 = { getElevation: f2, labelPlaneMatrix: l3, lineVertexArray: a2, pitchWithMap: u2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, projection: this.mapProjection, tileAnchorPoint: v2, unwrappedTileID: n2, width: this.transform.width, height: this.transform.height, translation: m2 }, w2 = Tt2(y3, s2, i2.lineOffsetX * y3, i2.lineOffsetY * y3, false, i2, false, b2);
            let T2 = false, I2 = false, E2 = true;
            if (w2) {
              const i3 = 0.5 * _2 * x2 + p2, a3 = new e.P(-100, -100), s3 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), o3 = new pt2(), r3 = w2.first, n3 = w2.last;
              let l4 = [];
              for (let t3 = r3.path.length - 1; t3 >= 1; t3--) l4.push(r3.path[t3]);
              for (let t3 = 1; t3 < n3.path.length; t3++) l4.push(n3.path[t3]);
              const u3 = 2.5 * i3;
              if (h2) {
                const t3 = this.projectPathToScreenSpace(l4, b2, h2);
                l4 = t3.some((t4) => t4.signedDistanceFromCamera <= 0) ? [] : t3.map((t4) => t4.point);
              }
              let m3 = [];
              if (l4.length > 0) {
                const t3 = l4[0].clone(), i4 = l4[0].clone();
                for (let e2 = 1; e2 < l4.length; e2++) t3.x = Math.min(t3.x, l4[e2].x), t3.y = Math.min(t3.y, l4[e2].y), i4.x = Math.max(i4.x, l4[e2].x), i4.y = Math.max(i4.y, l4[e2].y);
                m3 = t3.x >= a3.x && i4.x <= s3.x && t3.y >= a3.y && i4.y <= s3.y ? [l4] : i4.x < a3.x || t3.x > s3.x || i4.y < a3.y || t3.y > s3.y ? [] : e.al([l4], a3.x, a3.y, s3.x, s3.y);
              }
              for (const e2 of m3) {
                o3.reset(e2, 0.25 * i3);
                let a4 = 0;
                a4 = o3.length <= 0.5 * i3 ? 1 : Math.ceil(o3.paddedLength / u3) + 1;
                for (let e3 = 0; e3 < a4; e3++) {
                  const s4 = e3 / Math.max(a4 - 1, 1), r4 = o3.lerp(s4), n4 = r4.x + Lt2, l5 = r4.y + Lt2;
                  g2.push(n4, l5, i3, 0);
                  const h3 = n4 - i3, u4 = l5 - i3, _3 = n4 + i3, p3 = l5 + i3;
                  if (E2 = E2 && this.isOffscreen(h3, u4, _3, p3), I2 = I2 || this.isInsideGrid(h3, u4, _3, p3), "always" !== t2 && this.grid.hitTestCircle(n4, l5, i3, t2, d2) && (T2 = true, !c2)) return { circles: [], offscreen: false, collisionDetected: T2 };
                }
              }
            }
            return { circles: !c2 && T2 || !I2 || x2 < this.perspectiveRatioCutoff ? [] : g2, offscreen: E2, collisionDetected: T2 };
          }
          projectPathToScreenSpace(t2, e2, i2) {
            return t2.map((t3) => xt2(t3.x, t3.y, i2, e2.getElevation));
          }
          queryRenderedSymbols(t2) {
            if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
            const i2 = [];
            let a2 = 1 / 0, s2 = 1 / 0, o2 = -1 / 0, r2 = -1 / 0;
            for (const n3 of t2) {
              const t3 = new e.P(n3.x + Lt2, n3.y + Lt2);
              a2 = Math.min(a2, t3.x), s2 = Math.min(s2, t3.y), o2 = Math.max(o2, t3.x), r2 = Math.max(r2, t3.y), i2.push(t3);
            }
            const n2 = this.grid.query(a2, s2, o2, r2).concat(this.ignoredGrid.query(a2, s2, o2, r2)), l3 = {}, h2 = {};
            for (const t3 of n2) {
              const a3 = t3.key;
              if (void 0 === l3[a3.bucketInstanceId] && (l3[a3.bucketInstanceId] = {}), l3[a3.bucketInstanceId][a3.featureIndex]) continue;
              const s3 = [new e.P(t3.x1, t3.y1), new e.P(t3.x2, t3.y1), new e.P(t3.x2, t3.y2), new e.P(t3.x1, t3.y2)];
              e.am(i2, s3) && (l3[a3.bucketInstanceId][a3.featureIndex] = true, void 0 === h2[a3.bucketInstanceId] && (h2[a3.bucketInstanceId] = []), h2[a3.bucketInstanceId].push(a3.featureIndex));
            }
            return h2;
          }
          insertCollisionBox(t2, e2, i2, a2, s2, o2) {
            (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: a2, featureIndex: s2, collisionGroupID: o2, overlapMode: e2 }, t2[0], t2[1], t2[2], t2[3]);
          }
          insertCollisionCircles(t2, e2, i2, a2, s2, o2) {
            const r2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: a2, featureIndex: s2, collisionGroupID: o2, overlapMode: e2 };
            for (let e3 = 0; e3 < t2.length; e3 += 4) r2.insertCircle(n2, t2[e3], t2[e3 + 1], t2[e3 + 2]);
          }
          projectAndGetPerspectiveRatio(t2, i2, a2, s2, o2) {
            let r2;
            o2 ? (r2 = [i2, a2, o2(i2, a2), 1], e.af(r2, r2, t2)) : (r2 = [i2, a2, 0, 1], kt(r2, r2, t2));
            const n2 = r2[3];
            return { point: new e.P((r2[0] / n2 + 1) / 2 * this.transform.width + Lt2, (-r2[1] / n2 + 1) / 2 * this.transform.height + Lt2), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / n2 * 0.5, isOccluded: false, signedDistanceFromCamera: n2 };
          }
          getPerspectiveRatio(t2, e2, i2, a2, s2) {
            const o2 = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(e2, i2, a2, s2) : xt2(e2, i2, t2, s2);
            return 0.5 + this.transform.cameraToCenterDistance / o2.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(t2, e2, i2, a2) {
            return i2 < Lt2 || t2 >= this.screenRightBoundary || a2 < Lt2 || e2 > this.screenBottomBoundary;
          }
          isInsideGrid(t2, e2, i2, a2) {
            return i2 >= 0 && t2 < this.gridRightBoundary && a2 >= 0 && e2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t2 = e.an([]);
            return e.J(t2, t2, [-100, -100, 0]), t2;
          }
          _projectCollisionBox(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2) {
            let u2 = new e.P(1, 0), d2 = new e.P(0, 1);
            const _2 = new e.P(t2.anchorPointX + n2[0], t2.anchorPointY + n2[1]);
            if (r2 && !o2) {
              const t3 = this.projectAndGetPerspectiveRatio(a2, _2.x + 1, _2.y, s2, h2).point.sub(l3.point).unit(), i3 = Math.atan(t3.y / t3.x) + (t3.x < 0 ? Math.PI : 0), o3 = Math.sin(i3), r3 = Math.cos(i3);
              u2 = new e.P(r3, o3), d2 = new e.P(-o3, r3);
            } else if (!r2 && o2) {
              const t3 = -this.transform.angle, i3 = Math.sin(t3), a3 = Math.cos(t3);
              u2 = new e.P(a3, i3), d2 = new e.P(-i3, a3);
            }
            let p2 = l3.point, m2 = i2;
            if (o2) {
              p2 = _2;
              const t3 = this.transform.zoom - Math.floor(this.transform.zoom);
              m2 = Math.pow(2, -t3), m2 *= this.mapProjection.getPitchedTextCorrection(this.transform, _2, s2), c2 || (m2 *= e.ac(0.5 + l3.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
            }
            c2 && (p2 = p2.add(u2.mult(c2.x * m2)).add(d2.mult(c2.y * m2)));
            const f2 = t2.x1 * m2, g2 = t2.x2 * m2, v2 = (f2 + g2) / 2, x2 = t2.y1 * m2, y3 = t2.y2 * m2, b2 = (x2 + y3) / 2, w2 = [{ offsetX: f2, offsetY: x2 }, { offsetX: v2, offsetY: x2 }, { offsetX: g2, offsetY: x2 }, { offsetX: g2, offsetY: b2 }, { offsetX: g2, offsetY: y3 }, { offsetX: v2, offsetY: y3 }, { offsetX: f2, offsetY: y3 }, { offsetX: f2, offsetY: b2 }];
            let T2 = [];
            for (const { offsetX: t3, offsetY: i3 } of w2) T2.push(new e.P(p2.x + u2.x * t3 + d2.x * i3, p2.y + u2.y * t3 + d2.y * i3));
            let I2 = false;
            if (o2) {
              const t3 = T2.map((t4) => this.projectAndGetPerspectiveRatio(a2, t4.x, t4.y, s2, h2));
              I2 = t3.some((t4) => !t4.isOccluded), T2 = t3.map((t4) => t4.point);
            } else I2 = true;
            return { box: e.ao(T2), allPointsOccluded: !I2 };
          }
        }
        function Bt2(t2, i2, a2) {
          return i2 * (e.X / (t2.tileSize * Math.pow(2, a2 - t2.tileID.overscaledZ)));
        }
        class Ot2 {
          constructor(t2, e2, i2, a2) {
            this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : a2 && i2 ? 1 : 0, this.placed = i2;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class Nt2 {
          constructor(t2, e2, i2, a2, s2) {
            this.text = new Ot2(t2 ? t2.text : null, e2, i2, s2), this.icon = new Ot2(t2 ? t2.icon : null, e2, a2, s2);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Ut2 {
          constructor(t2, e2, i2) {
            this.text = t2, this.icon = e2, this.skipFade = i2;
          }
        }
        class jt {
          constructor() {
            this.invProjMatrix = e.H(), this.viewportMatrix = e.H(), this.circles = [];
          }
        }
        class Zt2 {
          constructor(t2, e2, i2, a2, s2) {
            this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = a2, this.tileID = s2;
          }
        }
        class qt2 {
          constructor(t2) {
            this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t2) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[t2]) {
              const e2 = ++this.maxGroupID;
              this.collisionGroups[t2] = { ID: e2, predicate: (t3) => t3.collisionGroupID === e2 };
            }
            return this.collisionGroups[t2];
          }
        }
        function Vt2(t2, i2, a2, s2, o2) {
          const { horizontalAlign: r2, verticalAlign: n2 } = e.au(t2);
          return new e.P(-(r2 - 0.5) * i2 + s2[0] * o2, -(n2 - 0.5) * a2 + s2[1] * o2);
        }
        class Gt2 {
          constructor(t2, e2, i2, a2, s2, o2) {
            this.transform = t2.clone(), this.terrain = i2, this.collisionIndex = new Ft2(this.transform, e2), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = a2, this.retainedQueryData = {}, this.collisionGroups = new qt2(s2), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(t2) {
            const e2 = this.terrain;
            return e2 ? (i2, a2) => e2.getElevation(t2, i2, a2) : null;
          }
          getBucketParts(t2, i2, a2, s2) {
            const o2 = a2.getBucket(i2), r2 = a2.latestFeatureIndex;
            if (!o2 || !r2 || i2.id !== o2.layerIds[0]) return;
            const n2 = a2.collisionBoxArray, l3 = o2.layers[0].layout, h2 = o2.layers[0].paint, c2 = Math.pow(2, this.transform.zoom - a2.tileID.overscaledZ), u2 = a2.tileSize / e.X, d2 = a2.tileID.toUnwrapped(), _2 = this.transform.calculatePosMatrix(d2), p2 = "map" === l3.get("text-pitch-alignment"), m2 = "map" === l3.get("text-rotation-alignment"), f2 = Bt2(a2, 1, this.transform.zoom), g2 = this.collisionIndex.mapProjection.translatePosition(this.transform, a2, h2.get("text-translate"), h2.get("text-translate-anchor")), v2 = this.collisionIndex.mapProjection.translatePosition(this.transform, a2, h2.get("icon-translate"), h2.get("icon-translate-anchor")), x2 = gt2(_2, p2, m2, this.transform, f2);
            let y3 = null;
            if (p2) {
              const t3 = vt2(_2, p2, m2, this.transform, f2);
              y3 = e.L([], this.transform.labelPlaneMatrix, t3);
            }
            this.retainedQueryData[o2.bucketInstanceId] = new Zt2(o2.bucketInstanceId, r2, o2.sourceLayerIndex, o2.index, a2.tileID);
            const b2 = { bucket: o2, layout: l3, translationText: g2, translationIcon: v2, posMatrix: _2, unwrappedTileID: d2, textLabelPlaneMatrix: x2, labelToScreenMatrix: y3, scale: c2, textPixelRatio: u2, holdingForFade: a2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: e.ag(o2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o2.sourceID) };
            if (s2) for (const e2 of o2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: s3 } = e2;
              t2.push({ sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: s3, parameters: b2 });
            }
            else t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: o2.symbolInstances.length, parameters: b2 });
          }
          attemptAnchorPlacement(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2, p2, m2, f2, g2, v2, x2) {
            const y3 = e.aq[t2.textAnchor], b2 = [t2.textOffset0, t2.textOffset1], w2 = Vt2(y3, a2, s2, b2, o2), T2 = this.collisionIndex.placeCollisionBox(i2, d2, l3, h2, c2, n2, r2, f2, u2.predicate, x2, w2);
            if ((!v2 || this.collisionIndex.placeCollisionBox(v2, d2, l3, h2, c2, n2, r2, g2, u2.predicate, x2, w2).placeable) && T2.placeable) {
              let t3;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID].text && (t3 = this.prevPlacement.variableOffsets[_2.crossTileID].anchor), 0 === _2.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[_2.crossTileID] = { textOffset: b2, width: a2, height: s2, anchor: y3, textBoxScale: o2, prevAnchor: t3 }, this.markUsedJustification(p2, y3, _2, m2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, m2, _2), this.placedOrientations[_2.crossTileID] = m2), { shift: w2, placedGlyphBoxes: T2 };
            }
          }
          placeLayerBucketPart(t2, i2, a2) {
            const { bucket: s2, layout: o2, translationText: r2, translationIcon: n2, posMatrix: l3, unwrappedTileID: h2, textLabelPlaneMatrix: c2, labelToScreenMatrix: u2, textPixelRatio: d2, holdingForFade: _2, collisionBoxArray: p2, partiallyEvaluatedTextSize: m2, collisionGroup: f2 } = t2.parameters, g2 = o2.get("text-optional"), v2 = o2.get("icon-optional"), x2 = e.ar(o2, "text-overlap", "text-allow-overlap"), y3 = "always" === x2, b2 = e.ar(o2, "icon-overlap", "icon-allow-overlap"), w2 = "always" === b2, T2 = "map" === o2.get("text-rotation-alignment"), I2 = "map" === o2.get("text-pitch-alignment"), E2 = "none" !== o2.get("icon-text-fit"), P2 = "viewport-y" === o2.get("symbol-z-order"), C3 = y3 && (w2 || !s2.hasIconData() || v2), S2 = w2 && (y3 || !s2.hasTextData() || g2);
            !s2.collisionArrays && p2 && s2.deserializeCollisionBoxes(p2);
            const z3 = this._getTerrainElevationFunc(this.retainedQueryData[s2.bucketInstanceId].tileID), D2 = (t3, p3, w3) => {
              var P3, D3;
              if (i2[t3.crossTileID]) return;
              if (_2) return void (this.placements[t3.crossTileID] = new Ut2(false, false, false));
              let M3 = false, A3 = false, R2 = true, k2 = null, L3 = { box: null, placeable: false, offscreen: null }, F2 = { box: null, placeable: false, offscreen: null }, B2 = null, O2 = null, N2 = null, U3 = 0, j2 = 0, Z2 = 0;
              p3.textFeatureIndex ? U3 = p3.textFeatureIndex : t3.useRuntimeCollisionCircles && (U3 = t3.featureIndex), p3.verticalTextFeatureIndex && (j2 = p3.verticalTextFeatureIndex);
              const q2 = p3.textBox;
              if (q2) {
                const i3 = (i4) => {
                  let a3 = e.ah.horizontal;
                  if (s2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                    const e2 = this.prevPlacement.placedOrientations[t3.crossTileID];
                    e2 && (this.placedOrientations[t3.crossTileID] = e2, a3 = e2, this.markUsedOrientation(s2, a3, t3));
                  }
                  return a3;
                }, o3 = (i4, a3) => {
                  if (s2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && p3.verticalTextBox) {
                    for (const t4 of s2.writingModes) if (t4 === e.ah.vertical ? (L3 = a3(), F2 = L3) : L3 = i4(), L3 && L3.placeable) break;
                  } else L3 = i4();
                }, c3 = t3.textAnchorOffsetStartIndex, u3 = t3.textAnchorOffsetEndIndex;
                if (u3 === c3) {
                  const a3 = (e2, i4) => {
                    const a4 = this.collisionIndex.placeCollisionBox(e2, x2, d2, l3, h2, I2, T2, r2, f2.predicate, z3);
                    return a4 && a4.placeable && (this.markUsedOrientation(s2, i4, t3), this.placedOrientations[t3.crossTileID] = i4), a4;
                  };
                  o3(() => a3(q2, e.ah.horizontal), () => {
                    const i4 = p3.verticalTextBox;
                    return s2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && i4 ? a3(i4, e.ah.vertical) : { box: null, offscreen: null };
                  }), i3(L3 && L3.placeable);
                } else {
                  let _3 = e.aq[null === (D3 = null === (P3 = this.prevPlacement) || void 0 === P3 ? void 0 : P3.variableOffsets[t3.crossTileID]) || void 0 === D3 ? void 0 : D3.anchor];
                  const m3 = (i4, o4, p4) => {
                    const m4 = i4.x2 - i4.x1, g4 = i4.y2 - i4.y1, v3 = t3.textBoxScale, y4 = E2 && "never" === b2 ? o4 : null;
                    let w4 = null, P4 = "never" === x2 ? 1 : 2, C4 = "never";
                    _3 && P4++;
                    for (let e2 = 0; e2 < P4; e2++) {
                      for (let e3 = c3; e3 < u3; e3++) {
                        const a3 = s2.textAnchorOffsets.get(e3);
                        if (_3 && a3.textAnchor !== _3) continue;
                        const o5 = this.attemptAnchorPlacement(a3, i4, m4, g4, v3, T2, I2, d2, l3, h2, f2, C4, t3, s2, p4, r2, n2, y4, z3);
                        if (o5 && (w4 = o5.placedGlyphBoxes, w4 && w4.placeable)) return M3 = true, k2 = o5.shift, w4;
                      }
                      _3 ? _3 = null : C4 = x2;
                    }
                    return a2 && !w4 && (w4 = { box: this.collisionIndex.placeCollisionBox(q2, "always", d2, l3, h2, I2, T2, r2, f2.predicate, z3, new e.P(0, 0)).box, offscreen: false, placeable: false }), w4;
                  };
                  o3(() => m3(q2, p3.iconBox, e.ah.horizontal), () => {
                    const i4 = p3.verticalTextBox;
                    return s2.allowVerticalPlacement && (!L3 || !L3.placeable) && t3.numVerticalGlyphVertices > 0 && i4 ? m3(i4, p3.verticalIconBox, e.ah.vertical) : { box: null, occluded: true, offscreen: null };
                  }), L3 && (M3 = L3.placeable, R2 = L3.offscreen);
                  const g3 = i3(L3 && L3.placeable);
                  if (!M3 && this.prevPlacement) {
                    const e2 = this.prevPlacement.variableOffsets[t3.crossTileID];
                    e2 && (this.variableOffsets[t3.crossTileID] = e2, this.markUsedJustification(s2, e2.anchor, t3, g3));
                  }
                }
              }
              if (B2 = L3, M3 = B2 && B2.placeable, R2 = B2 && B2.offscreen, t3.useRuntimeCollisionCircles) {
                const i3 = s2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex), n3 = e.ai(s2.textSizeData, m2, i3), d3 = o2.get("text-padding");
                O2 = this.collisionIndex.placeCollisionCircles(x2, i3, s2.lineVertexArray, s2.glyphOffsetArray, n3, l3, h2, c2, u2, a2, I2, f2.predicate, t3.collisionCircleDiameter, d3, r2, z3), O2.circles.length && O2.collisionDetected && !a2 && e.w("Collisions detected, but collision boxes are not shown"), M3 = y3 || O2.circles.length > 0 && !O2.collisionDetected, R2 = R2 && O2.offscreen;
              }
              if (p3.iconFeatureIndex && (Z2 = p3.iconFeatureIndex), p3.iconBox) {
                const t4 = (t5) => this.collisionIndex.placeCollisionBox(t5, b2, d2, l3, h2, I2, T2, n2, f2.predicate, z3, E2 && k2 ? k2 : void 0);
                F2 && F2.placeable && p3.verticalIconBox ? (N2 = t4(p3.verticalIconBox), A3 = N2.placeable) : (N2 = t4(p3.iconBox), A3 = N2.placeable), R2 = R2 && N2.offscreen;
              }
              const V3 = g2 || 0 === t3.numHorizontalGlyphVertices && 0 === t3.numVerticalGlyphVertices, G2 = v2 || 0 === t3.numIconVertices;
              V3 || G2 ? G2 ? V3 || (A3 = A3 && M3) : M3 = A3 && M3 : A3 = M3 = A3 && M3;
              const H2 = A3 && N2.placeable;
              if (M3 && B2.placeable && this.collisionIndex.insertCollisionBox(B2.box, x2, o2.get("text-ignore-placement"), s2.bucketInstanceId, F2 && F2.placeable && j2 ? j2 : U3, f2.ID), H2 && this.collisionIndex.insertCollisionBox(N2.box, b2, o2.get("icon-ignore-placement"), s2.bucketInstanceId, Z2, f2.ID), O2 && M3 && this.collisionIndex.insertCollisionCircles(O2.circles, x2, o2.get("text-ignore-placement"), s2.bucketInstanceId, U3, f2.ID), a2 && this.storeCollisionData(s2.bucketInstanceId, w3, p3, B2, N2, O2), 0 === t3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              if (0 === s2.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[t3.crossTileID] = new Ut2(M3 || C3, A3 || S2, R2 || s2.justReloaded), i2[t3.crossTileID] = true;
            };
            if (P2) {
              if (0 !== t2.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
              const e2 = s2.getSortedSymbolIndexes(this.transform.angle);
              for (let t3 = e2.length - 1; t3 >= 0; --t3) {
                const i3 = e2[t3];
                D2(s2.symbolInstances.get(i3), s2.collisionArrays[i3], i3);
              }
            } else for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++) D2(s2.symbolInstances.get(e2), s2.collisionArrays[e2], e2);
            if (a2 && s2.bucketInstanceId in this.collisionCircleArrays) {
              const t3 = this.collisionCircleArrays[s2.bucketInstanceId];
              e.as(t3.invProjMatrix, l3), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            s2.justReloaded = false;
          }
          storeCollisionData(t2, e2, i2, a2, s2, o2) {
            if (i2.textBox || i2.iconBox) {
              let o3, r2;
              this.collisionBoxArrays.has(t2) ? o3 = this.collisionBoxArrays.get(t2) : (o3 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(t2, o3)), o3.has(e2) ? r2 = o3.get(e2) : (r2 = { text: null, icon: null }, o3.set(e2, r2)), i2.textBox && (r2.text = a2.box), i2.iconBox && (r2.icon = s2.box);
            }
            if (o2) {
              let e3 = this.collisionCircleArrays[t2];
              void 0 === e3 && (e3 = this.collisionCircleArrays[t2] = new jt());
              for (let t3 = 0; t3 < o2.circles.length; t3 += 4) e3.circles.push(o2.circles[t3 + 0]), e3.circles.push(o2.circles[t3 + 1]), e3.circles.push(o2.circles[t3 + 2]), e3.circles.push(o2.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(t2, i2, a2, s2) {
            let o2;
            o2 = s2 === e.ah.vertical ? a2.verticalPlacedTextSymbolIndex : { left: a2.leftJustifiedTextSymbolIndex, center: a2.centerJustifiedTextSymbolIndex, right: a2.rightJustifiedTextSymbolIndex }[e.at(i2)];
            const r2 = [a2.leftJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.rightJustifiedTextSymbolIndex, a2.verticalPlacedTextSymbolIndex];
            for (const e2 of r2) e2 >= 0 && (t2.text.placedSymbolArray.get(e2).crossTileID = o2 >= 0 && e2 !== o2 ? 0 : a2.crossTileID);
          }
          markUsedOrientation(t2, i2, a2) {
            const s2 = i2 === e.ah.horizontal || i2 === e.ah.horizontalOnly ? i2 : 0, o2 = i2 === e.ah.vertical ? i2 : 0, r2 = [a2.leftJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.rightJustifiedTextSymbolIndex];
            for (const e2 of r2) t2.text.placedSymbolArray.get(e2).placedOrientation = s2;
            a2.verticalPlacedTextSymbolIndex && (t2.text.placedSymbolArray.get(a2.verticalPlacedTextSymbolIndex).placedOrientation = o2);
          }
          commit(t2) {
            this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const e2 = this.prevPlacement;
            let i2 = false;
            this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
            const a2 = e2 ? e2.symbolFadeChange(t2) : 1, s2 = e2 ? e2.opacities : {}, o2 = e2 ? e2.variableOffsets : {}, r2 = e2 ? e2.placedOrientations : {};
            for (const t3 in this.placements) {
              const e3 = this.placements[t3], o3 = s2[t3];
              o3 ? (this.opacities[t3] = new Nt2(o3, a2, e3.text, e3.icon), i2 = i2 || e3.text !== o3.text.placed || e3.icon !== o3.icon.placed) : (this.opacities[t3] = new Nt2(null, a2, e3.text, e3.icon, e3.skipFade), i2 = i2 || e3.text || e3.icon);
            }
            for (const t3 in s2) {
              const e3 = s2[t3];
              if (!this.opacities[t3]) {
                const s3 = new Nt2(e3, a2, false, false);
                s3.isHidden() || (this.opacities[t3] = s3, i2 = i2 || e3.text.placed || e3.icon.placed);
              }
            }
            for (const t3 in o2) this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = o2[t3]);
            for (const t3 in r2) this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = r2[t3]);
            if (e2 && void 0 === e2.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
            i2 ? this.lastPlacementChangeTime = t2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
          }
          updateLayerOpacities(t2, e2) {
            const i2 = {};
            for (const a2 of e2) {
              const e3 = a2.getBucket(t2);
              e3 && a2.latestFeatureIndex && t2.id === e3.layerIds[0] && this.updateBucketOpacities(e3, a2.tileID, i2, a2.collisionBoxArray);
            }
          }
          updateBucketOpacities(t2, i2, a2, s2) {
            t2.hasTextData() && (t2.text.opacityVertexArray.clear(), t2.text.hasVisibleVertices = false), t2.hasIconData() && (t2.icon.opacityVertexArray.clear(), t2.icon.hasVisibleVertices = false), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
            const o2 = t2.layers[0], r2 = o2.layout, n2 = new Nt2(null, 0, false, false, true), l3 = r2.get("text-allow-overlap"), h2 = r2.get("icon-allow-overlap"), c2 = o2._unevaluatedLayout.hasValue("text-variable-anchor") || o2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u2 = "map" === r2.get("text-rotation-alignment"), d2 = "map" === r2.get("text-pitch-alignment"), _2 = "none" !== r2.get("icon-text-fit"), p2 = new Nt2(null, 0, l3 && (h2 || !t2.hasIconData() || r2.get("icon-optional")), h2 && (l3 || !t2.hasTextData() || r2.get("text-optional")), true);
            !t2.collisionArrays && s2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(s2);
            const m2 = (t3, e2, i3) => {
              for (let a3 = 0; a3 < e2 / 4; a3++) t3.opacityVertexArray.emplaceBack(i3);
              t3.hasVisibleVertices = t3.hasVisibleVertices || i3 !== ee2;
            }, f2 = this.collisionBoxArrays.get(t2.bucketInstanceId);
            for (let i3 = 0; i3 < t2.symbolInstances.length; i3++) {
              const s3 = t2.symbolInstances.get(i3), { numHorizontalGlyphVertices: o3, numVerticalGlyphVertices: r3, crossTileID: l4 } = s3;
              let h3 = this.opacities[l4];
              a2[l4] ? h3 = n2 : h3 || (h3 = p2, this.opacities[l4] = h3), a2[l4] = true;
              const g2 = s3.numIconVertices > 0, v2 = this.placedOrientations[s3.crossTileID], x2 = v2 === e.ah.vertical, y3 = v2 === e.ah.horizontal || v2 === e.ah.horizontalOnly;
              if (o3 > 0 || r3 > 0) {
                const e2 = te(h3.text);
                m2(t2.text, o3, x2 ? ee2 : e2), m2(t2.text, r3, y3 ? ee2 : e2);
                const i4 = h3.text.isHidden();
                [s3.rightJustifiedTextSymbolIndex, s3.centerJustifiedTextSymbolIndex, s3.leftJustifiedTextSymbolIndex].forEach((e3) => {
                  e3 >= 0 && (t2.text.placedSymbolArray.get(e3).hidden = i4 || x2 ? 1 : 0);
                }), s3.verticalPlacedTextSymbolIndex >= 0 && (t2.text.placedSymbolArray.get(s3.verticalPlacedTextSymbolIndex).hidden = i4 || y3 ? 1 : 0);
                const a3 = this.variableOffsets[s3.crossTileID];
                a3 && this.markUsedJustification(t2, a3.anchor, s3, v2);
                const n3 = this.placedOrientations[s3.crossTileID];
                n3 && (this.markUsedJustification(t2, "left", s3, n3), this.markUsedOrientation(t2, n3, s3));
              }
              if (g2) {
                const e2 = te(h3.icon), i4 = !(_2 && s3.verticalPlacedIconSymbolIndex && x2);
                s3.placedIconSymbolIndex >= 0 && (m2(t2.icon, s3.numIconVertices, i4 ? e2 : ee2), t2.icon.placedSymbolArray.get(s3.placedIconSymbolIndex).hidden = h3.icon.isHidden()), s3.verticalPlacedIconSymbolIndex >= 0 && (m2(t2.icon, s3.numVerticalIconVertices, i4 ? ee2 : e2), t2.icon.placedSymbolArray.get(s3.verticalPlacedIconSymbolIndex).hidden = h3.icon.isHidden());
              }
              const b2 = f2 && f2.has(i3) ? f2.get(i3) : { text: null, icon: null };
              if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
                const a3 = t2.collisionArrays[i3];
                if (a3) {
                  let i4 = new e.P(0, 0);
                  if (a3.textBox || a3.verticalTextBox) {
                    let e2 = true;
                    if (c2) {
                      const t3 = this.variableOffsets[l4];
                      t3 ? (i4 = Vt2(t3.anchor, t3.width, t3.height, t3.textOffset, t3.textBoxScale), u2 && i4._rotate(d2 ? this.transform.angle : -this.transform.angle)) : e2 = false;
                    }
                    if (a3.textBox || a3.verticalTextBox) {
                      let s4;
                      a3.textBox && (s4 = x2), a3.verticalTextBox && (s4 = y3), Ht2(t2.textCollisionBox.collisionVertexArray, h3.text.placed, !e2 || s4, b2.text, i4.x, i4.y);
                    }
                  }
                  if (a3.iconBox || a3.verticalIconBox) {
                    const e2 = Boolean(!y3 && a3.verticalIconBox);
                    let s4;
                    a3.iconBox && (s4 = e2), a3.verticalIconBox && (s4 = !e2), Ht2(t2.iconCollisionBox.collisionVertexArray, h3.icon.placed, s4, b2.icon, _2 ? i4.x : 0, _2 ? i4.y : 0);
                  }
                }
              }
            }
            if (t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.text.opacityVertexArray.length !== t2.text.layoutVertexArray.length / 4) throw new Error("bucket.text.opacityVertexArray.length (= ".concat(t2.text.opacityVertexArray.length, ") !== bucket.text.layoutVertexArray.length (= ").concat(t2.text.layoutVertexArray.length, ") / 4"));
            if (t2.icon.opacityVertexArray.length !== t2.icon.layoutVertexArray.length / 4) throw new Error("bucket.icon.opacityVertexArray.length (= ".concat(t2.icon.opacityVertexArray.length, ") !== bucket.icon.layoutVertexArray.length (= ").concat(t2.icon.layoutVertexArray.length, ") / 4"));
            if (t2.bucketInstanceId in this.collisionCircleArrays) {
              const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
              t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
            }
          }
          symbolFadeChange(t2) {
            return 0 === this.fadeDuration ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t2) {
            return Math.max(0, (this.transform.zoom - t2) / 1.5);
          }
          hasTransitions(t2) {
            return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t2, e2) {
            const i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
            return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
          }
          setStale() {
            this.stale = true;
          }
        }
        function Ht2(t2, e2, i2, a2, s2, o2) {
          a2 && 0 !== a2.length || (a2 = [0, 0, 0, 0]);
          const r2 = a2[0] - Lt2, n2 = a2[1] - Lt2, l3 = a2[2] - Lt2, h2 = a2[3] - Lt2;
          t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, r2, n2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, l3, n2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, l3, h2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, r2, h2);
        }
        const Wt2 = Math.pow(2, 25), $t2 = Math.pow(2, 24), Xt2 = Math.pow(2, 17), Kt2 = Math.pow(2, 16), Jt2 = Math.pow(2, 9), Yt2 = Math.pow(2, 8), Qt2 = Math.pow(2, 1);
        function te(t2) {
          if (0 === t2.opacity && !t2.placed) return 0;
          if (1 === t2.opacity && t2.placed) return 4294967295;
          const e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
          return i2 * Wt2 + e2 * $t2 + i2 * Xt2 + e2 * Kt2 + i2 * Jt2 + e2 * Yt2 + i2 * Qt2 + e2;
        }
        const ee2 = 0;
        function ie() {
          return { isOccluded: (t2, e2, i2) => false, getPitchedTextCorrection: (t2, e2, i2) => 1, get useSpecialProjectionForSymbols() {
            return false;
          }, projectTileCoordinates(t2, e2, i2, a2) {
            throw new Error("Not implemented.");
          }, translatePosition: (t2, e2, i2, a2) => function(t3, e3, i3, a3, s2 = false) {
            if (!i3[0] && !i3[1]) return [0, 0];
            const o2 = s2 ? "map" === a3 ? t3.angle : 0 : "viewport" === a3 ? -t3.angle : 0;
            if (o2) {
              const t4 = Math.sin(o2), e4 = Math.cos(o2);
              i3 = [i3[0] * e4 - i3[1] * t4, i3[0] * t4 + i3[1] * e4];
            }
            return [s2 ? i3[0] : Bt2(e3, i3[0], t3.zoom), s2 ? i3[1] : Bt2(e3, i3[1], t3.zoom)];
          }(t2, e2, i2, a2), getCircleRadiusCorrection: (t2) => 1 };
        }
        class ae2 {
          constructor(t2) {
            this._sortAcrossTiles = "viewport-y" !== t2.layout.get("symbol-z-order") && !t2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t2, e2, i2, a2, s2) {
            const o2 = this._bucketParts;
            for (; this._currentTileIndex < t2.length; ) if (e2.getBucketParts(o2, a2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, s2()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort((t3, e3) => t3.sortKey - e3.sortKey)); this._currentPartIndex < o2.length; ) if (e2.placeLayerBucketPart(o2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, s2()) return true;
            return false;
          }
        }
        class se2 {
          constructor(t2, e2, i2, a2, s2, o2, r2, n2) {
            this.placement = new Gt2(t2, ie(), e2, o2, r2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = a2, this._showCollisionBoxes = s2, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t2, e2, i2) {
            const a2 = o.now(), s2 = () => !this._forceFullPlacement && o.now() - a2 > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const a3 = e2[t2[this._currentPlacementIndex]], o2 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === a3.type && (!a3.minzoom || a3.minzoom <= o2) && (!a3.maxzoom || a3.maxzoom > o2)) {
                if (this._inProgressLayer || (this._inProgressLayer = new ae2(a3)), this._inProgressLayer.continuePlacement(i2[a3.source], this.placement, this._showCollisionBoxes, a3, s2)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(t2) {
            return this.placement.commit(t2), this.placement;
          }
        }
        const oe = 512 / e.X / 2;
        class re2 {
          constructor(t2, i2, a2) {
            this.tileID = t2, this.bucketInstanceId = a2, this._symbolsByKey = {};
            const s2 = /* @__PURE__ */ new Map();
            for (let t3 = 0; t3 < i2.length; t3++) {
              const e2 = i2.get(t3), a3 = e2.key, o2 = s2.get(a3);
              o2 ? o2.push(e2) : s2.set(a3, [e2]);
            }
            for (const [t3, i3] of s2) {
              const a3 = { positions: i3.map((t4) => ({ x: Math.floor(t4.anchorX * oe), y: Math.floor(t4.anchorY * oe) })), crossTileIDs: i3.map((t4) => t4.crossTileID) };
              if (a3.positions.length > 128) {
                const t4 = new e.av(a3.positions.length, 16, Uint16Array);
                for (const { x: e2, y: i4 } of a3.positions) t4.add(e2, i4);
                t4.finish(), delete a3.positions, a3.index = t4;
              }
              this._symbolsByKey[t3] = a3;
            }
          }
          getScaledCoordinates(t2, i2) {
            const { x: a2, y: s2, z: o2 } = this.tileID.canonical, { x: r2, y: n2, z: l3 } = i2.canonical, h2 = oe / Math.pow(2, l3 - o2), c2 = (n2 * e.X + t2.anchorY) * h2, u2 = s2 * e.X * oe;
            return { x: Math.floor((r2 * e.X + t2.anchorX) * h2 - a2 * e.X * oe), y: Math.floor(c2 - u2) };
          }
          findMatches(t2, e2, i2) {
            const a2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
            for (let s2 = 0; s2 < t2.length; s2++) {
              const o2 = t2.get(s2);
              if (o2.crossTileID) continue;
              const r2 = this._symbolsByKey[o2.key];
              if (!r2) continue;
              const n2 = this.getScaledCoordinates(o2, e2);
              if (r2.index) {
                const t3 = r2.index.range(n2.x - a2, n2.y - a2, n2.x + a2, n2.y + a2).sort();
                for (const e3 of t3) {
                  const t4 = r2.crossTileIDs[e3];
                  if (!i2[t4]) {
                    i2[t4] = true, o2.crossTileID = t4;
                    break;
                  }
                }
              } else if (r2.positions) for (let t3 = 0; t3 < r2.positions.length; t3++) {
                const e3 = r2.positions[t3], s3 = r2.crossTileIDs[t3];
                if (Math.abs(e3.x - n2.x) <= a2 && Math.abs(e3.y - n2.y) <= a2 && !i2[s3]) {
                  i2[s3] = true, o2.crossTileID = s3;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: t2 }) => t2);
          }
        }
        class ne2 {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class le {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t2) {
            const e2 = Math.round((t2 - this.lng) / 360);
            if (0 !== e2) for (const t3 in this.indexes) {
              const i2 = this.indexes[t3], a2 = {};
              for (const t4 in i2) {
                const s2 = i2[t4];
                s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + e2), a2[s2.tileID.key] = s2;
              }
              this.indexes[t3] = a2;
            }
            this.lng = t2;
          }
          addBucket(t2, e2, i2) {
            if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
              if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
            }
            for (let t3 = 0; t3 < e2.symbolInstances.length; t3++) e2.symbolInstances.get(t3).crossTileID = 0;
            this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
            const a2 = this.usedCrossTileIDs[t2.overscaledZ];
            for (const i3 in this.indexes) {
              const s2 = this.indexes[i3];
              if (Number(i3) > t2.overscaledZ) for (const i4 in s2) {
                const o2 = s2[i4];
                o2.tileID.isChildOf(t2) && o2.findMatches(e2.symbolInstances, t2, a2);
              }
              else {
                const o2 = s2[t2.scaledTo(Number(i3)).key];
                o2 && o2.findMatches(e2.symbolInstances, t2, a2);
              }
            }
            for (let t3 = 0; t3 < e2.symbolInstances.length; t3++) {
              const s2 = e2.symbolInstances.get(t3);
              s2.crossTileID || (s2.crossTileID = i2.generate(), a2[s2.crossTileID] = true);
            }
            return void 0 === this.indexes[t2.overscaledZ] && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new re2(t2, e2.symbolInstances, e2.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(t2, e2) {
            for (const i2 of e2.getCrossTileIDsLists()) for (const e3 of i2) delete this.usedCrossTileIDs[t2][e3];
          }
          removeStaleBuckets(t2) {
            let e2 = false;
            for (const i2 in this.indexes) {
              const a2 = this.indexes[i2];
              for (const s2 in a2) t2[a2[s2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, a2[s2]), delete a2[s2], e2 = true);
            }
            return e2;
          }
        }
        class he2 {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new ne2(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t2, e2, i2) {
            let a2 = this.layerIndexes[t2.id];
            void 0 === a2 && (a2 = this.layerIndexes[t2.id] = new le());
            let s2 = false;
            const o2 = {};
            a2.handleWrapJump(i2);
            for (const i3 of e2) {
              const e3 = i3.getBucket(t2);
              e3 && t2.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), a2.addBucket(i3.tileID, e3, this.crossTileIDs) && (s2 = true), o2[e3.bucketInstanceId] = true);
            }
            return a2.removeStaleBuckets(o2) && (s2 = true), s2;
          }
          pruneUnusedLayers(t2) {
            const e2 = {};
            t2.forEach((t3) => {
              e2[t3] = true;
            });
            for (const t3 in this.layerIndexes) e2[t3] || delete this.layerIndexes[t3];
          }
        }
        const ce2 = (t2, i2) => e.t(t2, i2 && i2.filter((t3) => "source.canvas" !== t3.identifier)), ue2 = e.aw();
        class de2 extends e.E {
          constructor(t2, i2 = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const t3 in this.sourceCaches) {
                const e2 = this.sourceCaches[t3].getSource().type;
                "vector" !== e2 && "geojson" !== e2 || this.sourceCaches[t3].reload();
              }
            }, this.map = t2, this.dispatcher = new U2(N(), t2._getMapId()), this.dispatcher.registerMessageHandler("GG", (t3, e2) => this.getGlyphs(t3, e2)), this.dispatcher.registerMessageHandler("GI", (t3, e2) => this.getImages(t3, e2)), this.imageManager = new T(), this.imageManager.setEventedParent(this), this.glyphManager = new C2(t2._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new R(256, 512), this.crossTileSymbolIndex = new he2(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new e.ax(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", e.ay()), nt2().on(st2, this._rtlPluginLoaded), this.on("data", (t3) => {
              if ("source" !== t3.dataType || "metadata" !== t3.sourceDataType) return;
              const e2 = this.sourceCaches[t3.sourceId];
              if (!e2) return;
              const i3 = e2.getSource();
              if (i3 && i3.vectorLayerIds) for (const t4 in this._layers) {
                const e3 = this._layers[t4];
                e3.source === i3.id && this._validateLayer(e3);
              }
            });
          }
          loadURL(t2, i2 = {}, a2) {
            this.fire(new e.k("dataloading", { dataType: "style" })), i2.validate = "boolean" != typeof i2.validate || i2.validate;
            const s2 = this.map._requestManager.transformRequest(t2, "Style");
            this._loadStyleRequest = new AbortController();
            const o2 = this._loadStyleRequest;
            e.h(s2, this._loadStyleRequest).then((t3) => {
              this._loadStyleRequest = null, this._load(t3.data, i2, a2);
            }).catch((t3) => {
              this._loadStyleRequest = null, t3 && !o2.signal.aborted && this.fire(new e.j(t3));
            });
          }
          loadJSON(t2, i2 = {}, a2) {
            this.fire(new e.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), o.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, i2.validate = false !== i2.validate, this._load(t2, i2, a2);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new e.k("dataloading", { dataType: "style" })), this._load(ue2, { validate: false });
          }
          _load(t2, i2, a2) {
            var s2;
            const o2 = i2.transformStyle ? i2.transformStyle(a2, t2) : t2;
            if (!i2.validate || !ce2(this, e.u(o2))) {
              this._loaded = true, this.stylesheet = o2;
              for (const t3 in o2.sources) this.addSource(t3, o2.sources[t3], { validate: false });
              o2.sprite ? this._loadSprite(o2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o2.glyphs), this._createLayers(), this.light = new D(this.stylesheet.light), this.sky = new A2(this.stylesheet.sky), this.map.setTerrain(null !== (s2 = this.stylesheet.terrain) && void 0 !== s2 ? s2 : null), this.fire(new e.k("data", { dataType: "style" })), this.fire(new e.k("style.load"));
            }
          }
          _createLayers() {
            const t2 = e.az(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", t2), this._order = t2.map((t3) => t3.id), this._layers = {}, this._serializedLayers = null;
            for (const i2 of t2) {
              const t3 = e.aA(i2);
              t3.setEventedParent(this, { layer: { id: i2.id } }), this._layers[i2.id] = t3;
            }
          }
          _loadSprite(t2, i2 = false, a2 = void 0) {
            let s2;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), function(t3, i3, a3, s3) {
              return e._(this, void 0, void 0, function* () {
                const r2 = x(t3), n2 = a3 > 1 ? "@2x" : "", l3 = {}, h2 = {};
                for (const { id: t4, url: a4 } of r2) {
                  const o2 = i3.transformRequest(y2(a4, n2, ".json"), "SpriteJSON");
                  l3[t4] = e.h(o2, s3);
                  const r3 = i3.transformRequest(y2(a4, n2, ".png"), "SpriteImage");
                  h2[t4] = _.getImage(r3, s3);
                }
                return yield Promise.all([...Object.values(l3), ...Object.values(h2)]), function(t4, i4) {
                  return e._(this, void 0, void 0, function* () {
                    const e2 = {};
                    for (const a4 in t4) {
                      e2[a4] = {};
                      const s4 = o.getImageCanvasContext((yield i4[a4]).data), r3 = (yield t4[a4]).data;
                      for (const t5 in r3) {
                        const { width: i5, height: o2, x: n3, y: l4, sdf: h3, pixelRatio: c2, stretchX: u2, stretchY: d2, content: _2, textFitWidth: p2, textFitHeight: m2 } = r3[t5];
                        e2[a4][t5] = { data: null, pixelRatio: c2, sdf: h3, stretchX: u2, stretchY: d2, content: _2, textFitWidth: p2, textFitHeight: m2, spriteData: { width: i5, height: o2, x: n3, y: l4, context: s4 } };
                      }
                    }
                    return e2;
                  });
                }(l3, h2);
              });
            }(t2, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((t3) => {
              if (this._spriteRequest = null, t3) for (const e2 in t3) {
                this._spritesImagesIds[e2] = [];
                const a3 = this._spritesImagesIds[e2] ? this._spritesImagesIds[e2].filter((e3) => !(e3 in t3)) : [];
                for (const t4 of a3) this.imageManager.removeImage(t4), this._changedImages[t4] = true;
                for (const a4 in t3[e2]) {
                  const s3 = "default" === e2 ? a4 : "".concat(e2, ":").concat(a4);
                  this._spritesImagesIds[e2].push(s3), s3 in this.imageManager.images ? this.imageManager.updateImage(s3, t3[e2][a4], false) : this.imageManager.addImage(s3, t3[e2][a4]), i2 && (this._changedImages[s3] = true);
                }
              }
            }).catch((t3) => {
              this._spriteRequest = null, s2 = t3, this.fire(new e.j(s2));
            }).finally(() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i2 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" })), a2 && a2(s2);
            });
          }
          _unloadSprite() {
            for (const t2 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t2), this._changedImages[t2] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
          }
          _validateLayer(t2) {
            const i2 = this.sourceCaches[t2.source];
            if (!i2) return;
            const a2 = t2.sourceLayer;
            if (!a2) return;
            const s2 = i2.getSource();
            ("geojson" === s2.type || s2.vectorLayerIds && -1 === s2.vectorLayerIds.indexOf(a2)) && this.fire(new e.j(new Error('Source layer "'.concat(a2, '" does not exist on source "').concat(s2.id, '" as specified by style layer "').concat(t2.id, '".'))));
          }
          loaded() {
            if (!this._loaded) return false;
            if (Object.keys(this._updatedSources).length) return false;
            for (const t2 in this.sourceCaches) if (!this.sourceCaches[t2].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t2, i2 = false) {
            const a2 = this._serializedAllLayers();
            if (!t2 || 0 === t2.length) return Object.values(i2 ? e.aB(a2) : a2);
            const s2 = [];
            for (const o2 of t2) if (a2[o2]) {
              const t3 = i2 ? e.aB(a2[o2]) : a2[o2];
              s2.push(t3);
            }
            return s2;
          }
          _serializedAllLayers() {
            let t2 = this._serializedLayers;
            if (t2) return t2;
            t2 = this._serializedLayers = {};
            const e2 = Object.keys(this._layers);
            for (const i2 of e2) {
              const e3 = this._layers[i2];
              "custom" !== e3.type && (t2[i2] = e3.serialize());
            }
            return t2;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition()) return true;
            if (this.sky && this.sky.hasTransition()) return true;
            for (const t2 in this.sourceCaches) if (this.sourceCaches[t2].hasTransition()) return true;
            for (const t2 in this._layers) if (this._layers[t2].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(t2) {
            if (!this._loaded) return;
            const i2 = this._changed;
            if (i2) {
              const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
              (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
              for (const t3 in this._updatedSources) {
                const e3 = this._updatedSources[t3];
                if ("reload" === e3) this._reloadSource(t3);
                else {
                  if ("clear" !== e3) throw new Error("Invalid action ".concat(e3));
                  this._clearSource(t3);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const e3 in this._updatedPaintProps) this._layers[e3].updateTransitions(t2);
              this.light.updateTransitions(t2), this.sky.updateTransitions(t2), this._resetUpdates();
            }
            const a2 = {};
            for (const t3 in this.sourceCaches) {
              const e2 = this.sourceCaches[t3];
              a2[t3] = e2.used, e2.used = false;
            }
            for (const e2 of this._order) {
              const i3 = this._layers[e2];
              i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
            }
            for (const t3 in a2) {
              const i3 = this.sourceCaches[t3];
              !!a2[t3] != !!i3.used && i3.fire(new e.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: t3 }));
            }
            this.light.recalculate(t2), this.sky.recalculate(t2), this.z = t2.zoom, i2 && this.fire(new e.k("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t2 = Object.keys(this._changedImages);
            if (t2.length) {
              for (const e2 in this.sourceCaches) this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t2);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t2 in this.sourceCaches) this.sourceCaches[t2].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(t2, e2) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t2, false), removedIds: e2 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(t2, i2 = {}) {
            var a2;
            this._checkLoaded();
            const s2 = this.serialize();
            if (t2 = i2.transformStyle ? i2.transformStyle(s2, t2) : t2, (null === (a2 = i2.validate) || void 0 === a2 || a2) && ce2(this, e.u(t2))) return false;
            (t2 = e.aB(t2)).layers = e.az(t2.layers);
            const o2 = e.aC(s2, t2), r2 = this._getOperationsToPerform(o2);
            if (r2.unimplemented.length > 0) throw new Error("Unimplemented: ".concat(r2.unimplemented.join(", "), "."));
            if (0 === r2.operations.length) return false;
            for (const t3 of r2.operations) t3();
            return this.stylesheet = t2, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(t2) {
            const e2 = [], i2 = [];
            for (const a2 of t2) switch (a2.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
                continue;
              case "addLayer":
                e2.push(() => this.addLayer.apply(this, a2.args));
                break;
              case "removeLayer":
                e2.push(() => this.removeLayer.apply(this, a2.args));
                break;
              case "setPaintProperty":
                e2.push(() => this.setPaintProperty.apply(this, a2.args));
                break;
              case "setLayoutProperty":
                e2.push(() => this.setLayoutProperty.apply(this, a2.args));
                break;
              case "setFilter":
                e2.push(() => this.setFilter.apply(this, a2.args));
                break;
              case "addSource":
                e2.push(() => this.addSource.apply(this, a2.args));
                break;
              case "removeSource":
                e2.push(() => this.removeSource.apply(this, a2.args));
                break;
              case "setLayerZoomRange":
                e2.push(() => this.setLayerZoomRange.apply(this, a2.args));
                break;
              case "setLight":
                e2.push(() => this.setLight.apply(this, a2.args));
                break;
              case "setGeoJSONSourceData":
                e2.push(() => this.setGeoJSONSourceData.apply(this, a2.args));
                break;
              case "setGlyphs":
                e2.push(() => this.setGlyphs.apply(this, a2.args));
                break;
              case "setSprite":
                e2.push(() => this.setSprite.apply(this, a2.args));
                break;
              case "setSky":
                e2.push(() => this.setSky.apply(this, a2.args));
                break;
              case "setTerrain":
                e2.push(() => this.map.setTerrain.apply(this, a2.args));
                break;
              case "setTransition":
                e2.push(() => {
                });
                break;
              default:
                i2.push(a2.command);
            }
            return { operations: e2, unimplemented: i2 };
          }
          addImage(t2, i2) {
            if (this.getImage(t2)) return this.fire(new e.j(new Error('An image named "'.concat(t2, '" already exists.'))));
            this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2);
          }
          updateImage(t2, e2) {
            this.imageManager.updateImage(t2, e2);
          }
          getImage(t2) {
            return this.imageManager.getImage(t2);
          }
          removeImage(t2) {
            if (!this.getImage(t2)) return this.fire(new e.j(new Error('An image named "'.concat(t2, '" does not exist.'))));
            this.imageManager.removeImage(t2), this._afterImageUpdated(t2);
          }
          _afterImageUpdated(t2) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(t2, i2, a2 = {}) {
            if (this._checkLoaded(), void 0 !== this.sourceCaches[t2]) throw new Error('Source "'.concat(t2, '" already exists.'));
            if (!i2.type) throw new Error("The type property must be defined, but only the following properties were given: ".concat(Object.keys(i2).join(", "), "."));
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.u.source, "sources.".concat(t2), i2, null, a2)) return;
            this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
            const s2 = this.sourceCaches[t2] = new ut2(t2, i2, this.dispatcher);
            s2.style = this, s2.setEventedParent(this, () => ({ isSourceLoaded: s2.loaded(), source: s2.serialize(), sourceId: t2 })), s2.onAdd(this.map), this._changed = true;
          }
          removeSource(t2) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[t2]) throw new Error("There is no source with this ID");
            for (const i3 in this._layers) if (this._layers[i3].source === t2) return this.fire(new e.j(new Error('Source "'.concat(t2, '" cannot be removed while layer "').concat(i3, '" is using it.'))));
            const i2 = this.sourceCaches[t2];
            delete this.sourceCaches[t2], delete this._updatedSources[t2], i2.fire(new e.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: t2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(t2, e2) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[t2]) throw new Error("There is no source with this ID=".concat(t2));
            const i2 = this.sourceCaches[t2].getSource();
            if ("geojson" !== i2.type) throw new Error("geojsonSource.type is ".concat(i2.type, ", which is !== 'geojson"));
            i2.setData(e2), this._changed = true;
          }
          getSource(t2) {
            return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
          }
          addLayer(t2, i2, a2 = {}) {
            this._checkLoaded();
            const s2 = t2.id;
            if (this.getLayer(s2)) return void this.fire(new e.j(new Error('Layer "'.concat(s2, '" already exists on this map.'))));
            let o2;
            if ("custom" === t2.type) {
              if (ce2(this, e.aD(t2))) return;
              o2 = e.aA(t2);
            } else {
              if ("source" in t2 && "object" == typeof t2.source && (this.addSource(s2, t2.source), t2 = e.aB(t2), t2 = e.e(t2, { source: s2 })), this._validate(e.u.layer, "layers.".concat(s2), t2, { arrayIndex: -1 }, a2)) return;
              o2 = e.aA(t2), this._validateLayer(o2), o2.setEventedParent(this, { layer: { id: s2 } });
            }
            const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
            if (i2 && -1 === r2) this.fire(new e.j(new Error('Cannot add layer "'.concat(s2, '" before non-existing layer "').concat(i2, '".'))));
            else {
              if (this._order.splice(r2, 0, s2), this._layerOrderChanged = true, this._layers[s2] = o2, this._removedLayers[s2] && o2.source && "custom" !== o2.type) {
                const t3 = this._removedLayers[s2];
                delete this._removedLayers[s2], t3.type !== o2.type ? this._updatedSources[o2.source] = "clear" : (this._updatedSources[o2.source] = "reload", this.sourceCaches[o2.source].pause());
              }
              this._updateLayer(o2), o2.onAdd && o2.onAdd(this.map);
            }
          }
          moveLayer(t2, i2) {
            if (this._checkLoaded(), this._changed = true, !this._layers[t2]) return void this.fire(new e.j(new Error("The layer '".concat(t2, "' does not exist in the map's style and cannot be moved."))));
            if (t2 === i2) return;
            const a2 = this._order.indexOf(t2);
            this._order.splice(a2, 1);
            const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
            i2 && -1 === s2 ? this.fire(new e.j(new Error('Cannot move layer "'.concat(t2, '" before non-existing layer "').concat(i2, '".')))) : (this._order.splice(s2, 0, t2), this._layerOrderChanged = true);
          }
          removeLayer(t2) {
            this._checkLoaded();
            const i2 = this._layers[t2];
            if (!i2) return void this.fire(new e.j(new Error('Cannot remove non-existing layer "'.concat(t2, '".'))));
            i2.setEventedParent(null);
            const a2 = this._order.indexOf(t2);
            this._order.splice(a2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], this._serializedLayers && delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map);
          }
          getLayer(t2) {
            return this._layers[t2];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t2) {
            return t2 in this._layers;
          }
          setLayerZoomRange(t2, i2, a2) {
            this._checkLoaded();
            const s2 = this.getLayer(t2);
            s2 ? s2.minzoom === i2 && s2.maxzoom === a2 || (null != i2 && (s2.minzoom = i2), null != a2 && (s2.maxzoom = a2), this._updateLayer(s2)) : this.fire(new e.j(new Error('Cannot set the zoom range of non-existing layer "'.concat(t2, '".'))));
          }
          setFilter(t2, i2, a2 = {}) {
            this._checkLoaded();
            const s2 = this.getLayer(t2);
            if (s2) {
              if (!e.aE(s2.filter, i2)) return null == i2 ? (s2.filter = void 0, void this._updateLayer(s2)) : void (this._validate(e.u.filter, "layers.".concat(s2.id, ".filter"), i2, null, a2) || (s2.filter = e.aB(i2), this._updateLayer(s2)));
            } else this.fire(new e.j(new Error('Cannot filter non-existing layer "'.concat(t2, '".'))));
          }
          getFilter(t2) {
            return e.aB(this.getLayer(t2).filter);
          }
          setLayoutProperty(t2, i2, a2, s2 = {}) {
            this._checkLoaded();
            const o2 = this.getLayer(t2);
            o2 ? e.aE(o2.getLayoutProperty(i2), a2) || (o2.setLayoutProperty(i2, a2, s2), this._updateLayer(o2)) : this.fire(new e.j(new Error('Cannot style non-existing layer "'.concat(t2, '".'))));
          }
          getLayoutProperty(t2, i2) {
            const a2 = this.getLayer(t2);
            if (a2) return a2.getLayoutProperty(i2);
            this.fire(new e.j(new Error('Cannot get style of non-existing layer "'.concat(t2, '".'))));
          }
          setPaintProperty(t2, i2, a2, s2 = {}) {
            this._checkLoaded();
            const o2 = this.getLayer(t2);
            o2 ? e.aE(o2.getPaintProperty(i2), a2) || (o2.setPaintProperty(i2, a2, s2) && this._updateLayer(o2), this._changed = true, this._updatedPaintProps[t2] = true, this._serializedLayers = null) : this.fire(new e.j(new Error('Cannot style non-existing layer "'.concat(t2, '".'))));
          }
          getPaintProperty(t2, e2) {
            return this.getLayer(t2).getPaintProperty(e2);
          }
          setFeatureState(t2, i2) {
            this._checkLoaded();
            const a2 = t2.source, s2 = t2.sourceLayer, o2 = this.sourceCaches[a2];
            if (void 0 === o2) return void this.fire(new e.j(new Error("The source '".concat(a2, "' does not exist in the map's style."))));
            const r2 = o2.getSource().type;
            "geojson" === r2 && s2 ? this.fire(new e.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r2 || s2 ? (void 0 === t2.id && this.fire(new e.j(new Error("The feature id parameter must be provided."))), o2.setFeatureState(s2, t2.id, i2)) : this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(t2, i2) {
            this._checkLoaded();
            const a2 = t2.source, s2 = this.sourceCaches[a2];
            if (void 0 === s2) return void this.fire(new e.j(new Error("The source '".concat(a2, "' does not exist in the map's style."))));
            const o2 = s2.getSource().type, r2 = "vector" === o2 ? t2.sourceLayer : void 0;
            "vector" !== o2 || r2 ? i2 && "string" != typeof t2.id && "number" != typeof t2.id ? this.fire(new e.j(new Error("A feature id is required to remove its specific state property."))) : s2.removeFeatureState(r2, t2.id, i2) : this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(t2) {
            this._checkLoaded();
            const i2 = t2.source, a2 = t2.sourceLayer, s2 = this.sourceCaches[i2];
            if (void 0 !== s2) return "vector" !== s2.getSource().type || a2 ? (void 0 === t2.id && this.fire(new e.j(new Error("The feature id parameter must be provided."))), s2.getFeatureState(a2, t2.id)) : void this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new e.j(new Error("The source '".concat(i2, "' does not exist in the map's style."))));
          }
          getTransition() {
            return e.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const t2 = e.aF(this.sourceCaches, (t3) => t3.serialize()), i2 = this._serializeByIds(this._order, true), a2 = this.map.getTerrain() || void 0, s2 = this.stylesheet;
            return e.aG({ version: s2.version, name: s2.name, metadata: s2.metadata, light: s2.light, sky: s2.sky, center: s2.center, zoom: s2.zoom, bearing: s2.bearing, pitch: s2.pitch, sprite: s2.sprite, glyphs: s2.glyphs, transition: s2.transition, sources: t2, layers: i2, terrain: a2 }, (t3) => void 0 !== t3);
          }
          _updateLayer(t2) {
            this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && "raster" !== this.sourceCaches[t2.source].getSource().type && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(t2) {
            const e2 = (t3) => "fill-extrusion" === this._layers[t3].type, i2 = {}, a2 = [];
            for (let s3 = this._order.length - 1; s3 >= 0; s3--) {
              const o2 = this._order[s3];
              if (e2(o2)) {
                i2[o2] = s3;
                for (const e3 of t2) {
                  const t3 = e3[o2];
                  if (t3) for (const e4 of t3) a2.push(e4);
                }
              }
            }
            a2.sort((t3, e3) => e3.intersectionZ - t3.intersectionZ);
            const s2 = [];
            for (let o2 = this._order.length - 1; o2 >= 0; o2--) {
              const r2 = this._order[o2];
              if (e2(r2)) for (let t3 = a2.length - 1; t3 >= 0; t3--) {
                const e3 = a2[t3].feature;
                if (i2[e3.layer.id] < o2) break;
                s2.push(e3), a2.pop();
              }
              else for (const e3 of t2) {
                const t3 = e3[r2];
                if (t3) for (const e4 of t3) s2.push(e4.feature);
              }
            }
            return s2;
          }
          queryRenderedFeatures(t2, i2, a2) {
            i2 && i2.filter && this._validate(e.u.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
            const s2 = {};
            if (i2 && i2.layers) {
              if (!Array.isArray(i2.layers)) return this.fire(new e.j(new Error("parameters.layers must be an Array."))), [];
              for (const t3 of i2.layers) {
                const i3 = this._layers[t3];
                if (!i3) return this.fire(new e.j(new Error("The layer '".concat(t3, "' does not exist in the map's style and cannot be queried for features.")))), [];
                s2[i3.source] = true;
              }
            }
            const o2 = [];
            i2.availableImages = this._availableImages;
            const r2 = this._serializedAllLayers();
            for (const e2 in this.sourceCaches) i2.layers && !s2[e2] || o2.push(q(this.sourceCaches[e2], this._layers, r2, t2, i2, a2));
            return this.placement && o2.push(function(t3, e2, i3, a3, s3, o3, r3) {
              const n2 = {}, l3 = o3.queryRenderedSymbols(a3), h2 = [];
              for (const t4 of Object.keys(l3).map(Number)) h2.push(r3[t4]);
              h2.sort(V2);
              for (const i4 of h2) {
                const a4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], e2, i4.bucketIndex, i4.sourceLayerIndex, s3.filter, s3.layers, s3.availableImages, t3);
                for (const t4 in a4) {
                  const e3 = n2[t4] = n2[t4] || [], s4 = a4[t4];
                  s4.sort((t5, e4) => {
                    const a5 = i4.featureSortOrder;
                    if (a5) {
                      const i5 = a5.indexOf(t5.featureIndex);
                      return a5.indexOf(e4.featureIndex) - i5;
                    }
                    return e4.featureIndex - t5.featureIndex;
                  });
                  for (const t5 of s4) e3.push(t5);
                }
              }
              for (const e3 in n2) n2[e3].forEach((a4) => {
                const s4 = a4.feature, o4 = i3[t3[e3].source].getFeatureState(s4.layer["source-layer"], s4.id);
                s4.source = s4.layer.source, s4.layer["source-layer"] && (s4.sourceLayer = s4.layer["source-layer"]), s4.state = o4;
              });
              return n2;
            }(this._layers, r2, this.sourceCaches, t2, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o2);
          }
          querySourceFeatures(t2, i2) {
            i2 && i2.filter && this._validate(e.u.filter, "querySourceFeatures.filter", i2.filter, null, i2);
            const a2 = this.sourceCaches[t2];
            return a2 ? function(t3, e2) {
              const i3 = t3.getRenderableIds().map((e3) => t3.getTileByID(e3)), a3 = [], s2 = {};
              for (let t4 = 0; t4 < i3.length; t4++) {
                const o2 = i3[t4], r2 = o2.tileID.canonical.key;
                s2[r2] || (s2[r2] = true, o2.querySourceFeatures(a3, e2));
              }
              return a3;
            }(a2, i2) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(t2, i2 = {}) {
            this._checkLoaded();
            const a2 = this.light.getLight();
            let s2 = false;
            for (const i3 in t2) if (!e.aE(t2[i3], a2[i3])) {
              s2 = true;
              break;
            }
            if (!s2) return;
            const r2 = { now: o.now(), transition: e.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(t2, i2), this.light.updateTransitions(r2);
          }
          getSky() {
            var t2;
            return null === (t2 = this.stylesheet) || void 0 === t2 ? void 0 : t2.sky;
          }
          setSky(t2, i2 = {}) {
            const a2 = this.getSky();
            let s2 = false;
            if (!t2 && !a2) return;
            if (t2 && !a2) s2 = true;
            else if (!t2 && a2) s2 = true;
            else for (const i3 in t2) if (!e.aE(t2[i3], a2[i3])) {
              s2 = true;
              break;
            }
            if (!s2) return;
            const r2 = { now: o.now(), transition: e.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = t2, this.sky.setSky(t2, i2), this.sky.updateTransitions(r2);
          }
          _validate(t2, i2, a2, s2, o2 = {}) {
            return (!o2 || false !== o2.validate) && ce2(this, t2.call(e.u, e.e({ key: i2, style: this.serialize(), value: a2, styleSpec: e.v }, s2)));
          }
          _remove(t2 = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), nt2().off(st2, this._rtlPluginLoaded);
            for (const t3 in this._layers) this._layers[t3].setEventedParent(null);
            for (const t3 in this.sourceCaches) {
              const e2 = this.sourceCaches[t3];
              e2.setEventedParent(null), e2.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), t2 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t2);
          }
          _clearSource(t2) {
            this.sourceCaches[t2].clearTiles();
          }
          _reloadSource(t2) {
            this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
          }
          _updateSources(t2) {
            for (const e2 in this.sourceCaches) this.sourceCaches[e2].update(t2, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t2 in this.sourceCaches) this._reloadSource(t2);
          }
          _updatePlacement(t2, e2, i2, a2, s2 = false) {
            let r2 = false, n2 = false;
            const l3 = {};
            for (const e3 of this._order) {
              const i3 = this._layers[e3];
              if ("symbol" !== i3.type) continue;
              if (!l3[i3.source]) {
                const t3 = this.sourceCaches[i3.source];
                l3[i3.source] = t3.getRenderableIds(true).map((e4) => t3.getTileByID(e4)).sort((t4, e4) => e4.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e4.tileID) ? -1 : 1));
              }
              const a3 = this.crossTileSymbolIndex.addLayer(i3, l3[i3.source], t2.center.lng);
              r2 = r2 || a3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((s2 = s2 || this._layerOrderChanged || 0 === i2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.now(), t2.zoom)) && (this.pauseablePlacement = new se2(t2, this.map.terrain, this._order, s2, e2, i2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.now()), n2 = true), r2 && this.pauseablePlacement.placement.setStale()), n2 || r2) for (const t3 of this._order) {
              const e3 = this._layers[t3];
              "symbol" === e3.type && this.placement.updateLayerOpacities(e3, l3[e3.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.now());
          }
          _releaseSymbolFadeTiles() {
            for (const t2 in this.sourceCaches) this.sourceCaches[t2].releaseSymbolFadeTiles();
          }
          getImages(t2, i2) {
            return e._(this, void 0, void 0, function* () {
              const t3 = yield this.imageManager.getImages(i2.icons);
              this._updateTilesForChangedImages();
              const e2 = this.sourceCaches[i2.source];
              return e2 && e2.setDependencies(i2.tileID.key, i2.type, i2.icons), t3;
            });
          }
          getGlyphs(t2, i2) {
            return e._(this, void 0, void 0, function* () {
              const t3 = yield this.glyphManager.getGlyphs(i2.stacks), e2 = this.sourceCaches[i2.source];
              return e2 && e2.setDependencies(i2.tileID.key, i2.type, [""]), t3;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(t2, i2 = {}) {
            this._checkLoaded(), t2 && this._validate(e.u.glyphs, "glyphs", t2, null, i2) || (this._glyphsDidChange = true, this.stylesheet.glyphs = t2, this.glyphManager.entries = {}, this.glyphManager.setURL(t2));
          }
          addSprite(t2, i2, a2 = {}, s2) {
            this._checkLoaded();
            const o2 = [{ id: t2, url: i2 }], r2 = [...x(this.stylesheet.sprite), ...o2];
            this._validate(e.u.sprite, "sprite", r2, null, a2) || (this.stylesheet.sprite = r2, this._loadSprite(o2, true, s2));
          }
          removeSprite(t2) {
            this._checkLoaded();
            const i2 = x(this.stylesheet.sprite);
            if (i2.find((e2) => e2.id === t2)) {
              if (this._spritesImagesIds[t2]) for (const e2 of this._spritesImagesIds[t2]) this.imageManager.removeImage(e2), this._changedImages[e2] = true;
              i2.splice(i2.findIndex((e2) => e2.id === t2), 1), this.stylesheet.sprite = i2.length > 0 ? i2 : void 0, delete this._spritesImagesIds[t2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
            } else this.fire(new e.j(new Error('Sprite "'.concat(t2, "\" doesn't exists on this map."))));
          }
          getSprite() {
            return x(this.stylesheet.sprite);
          }
          setSprite(t2, i2 = {}, a2) {
            this._checkLoaded(), t2 && this._validate(e.u.sprite, "sprite", t2, null, i2) || (this.stylesheet.sprite = t2, t2 ? this._loadSprite(t2, true, a2) : (this._unloadSprite(), a2 && a2(null)));
          }
        }
        var _e2 = e.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
        const pe = { prelude: me2("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: me2("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: me2("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: me2("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: me2("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: me2("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}"), heatmapTexture: me2("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: me2("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: me2("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: me2("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: me2("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: me2("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: me2("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: me2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: me2("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: me2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: me2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: me2("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: me2("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: me2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: me2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: me2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: me2("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: me2("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: me2("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: me2("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: me2("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: me2("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: me2("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: me2("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function me2(t2, e2) {
          const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, a2 = e2.match(/attribute ([\w]+) ([\w]+)/g), s2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = o2 ? o2.concat(s2) : s2, n2 = {};
          return { fragmentSource: t2 = t2.replace(i2, (t3, e3, i3, a3, s3) => (n2[s3] = true, "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_".concat(s3, "\nvarying ").concat(i3, " ").concat(a3, " ").concat(s3, ";\n#else\nuniform ").concat(i3, " ").concat(a3, " u_").concat(s3, ";\n#endif\n") : "\n#ifdef HAS_UNIFORM_u_".concat(s3, "\n    ").concat(i3, " ").concat(a3, " ").concat(s3, " = u_").concat(s3, ";\n#endif\n"))), vertexSource: e2 = e2.replace(i2, (t3, e3, i3, a3, s3) => {
            const o3 = "float" === a3 ? "vec2" : "vec4", r3 = s3.match(/color/) ? "color" : o3;
            return n2[s3] ? "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_".concat(s3, "\nuniform lowp float u_").concat(s3, "_t;\nattribute ").concat(i3, " ").concat(o3, " a_").concat(s3, ";\nvarying ").concat(i3, " ").concat(a3, " ").concat(s3, ";\n#else\nuniform ").concat(i3, " ").concat(a3, " u_").concat(s3, ";\n#endif\n") : "vec4" === r3 ? "\n#ifndef HAS_UNIFORM_u_".concat(s3, "\n    ").concat(s3, " = a_").concat(s3, ";\n#else\n    ").concat(i3, " ").concat(a3, " ").concat(s3, " = u_").concat(s3, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(s3, "\n    ").concat(s3, " = unpack_mix_").concat(r3, "(a_").concat(s3, ", u_").concat(s3, "_t);\n#else\n    ").concat(i3, " ").concat(a3, " ").concat(s3, " = u_").concat(s3, ";\n#endif\n") : "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_".concat(s3, "\nuniform lowp float u_").concat(s3, "_t;\nattribute ").concat(i3, " ").concat(o3, " a_").concat(s3, ";\n#else\nuniform ").concat(i3, " ").concat(a3, " u_").concat(s3, ";\n#endif\n") : "vec4" === r3 ? "\n#ifndef HAS_UNIFORM_u_".concat(s3, "\n    ").concat(i3, " ").concat(a3, " ").concat(s3, " = a_").concat(s3, ";\n#else\n    ").concat(i3, " ").concat(a3, " ").concat(s3, " = u_").concat(s3, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(s3, "\n    ").concat(i3, " ").concat(a3, " ").concat(s3, " = unpack_mix_").concat(r3, "(a_").concat(s3, ", u_").concat(s3, "_t);\n#else\n    ").concat(i3, " ").concat(a3, " ").concat(s3, " = u_").concat(s3, ";\n#endif\n");
          }), staticAttributes: a2, staticUniforms: r2 };
        }
        class fe2 {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t2, e2, i2, a2, s2, o2, r2, n2, l3) {
            this.context = t2;
            let h2 = this.boundPaintVertexBuffers.length !== a2.length;
            for (let t3 = 0; !h2 && t3 < a2.length; t3++) this.boundPaintVertexBuffers[t3] !== a2[t3] && (h2 = true);
            !this.vao || this.boundProgram !== e2 || this.boundLayoutVertexBuffer !== i2 || h2 || this.boundIndexBuffer !== s2 || this.boundVertexOffset !== o2 || this.boundDynamicVertexBuffer !== r2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l3 ? this.freshBind(e2, i2, a2, s2, o2, r2, n2, l3) : (t2.bindVertexArray.set(this.vao), r2 && r2.bind(), s2 && s2.dynamicDraw && s2.bind(), n2 && n2.bind(), l3 && l3.bind());
          }
          freshBind(t2, e2, i2, a2, s2, o2, r2, n2) {
            const l3 = t2.numAttributes, h2 = this.context, c2 = h2.gl;
            this.vao && this.destroy(), this.vao = h2.createVertexArray(), h2.bindVertexArray.set(this.vao), this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = a2, this.boundVertexOffset = s2, this.boundDynamicVertexBuffer = o2, this.boundDynamicVertexBuffer2 = r2, this.boundDynamicVertexBuffer3 = n2, e2.enableAttributes(c2, t2);
            for (const e3 of i2) e3.enableAttributes(c2, t2);
            o2 && o2.enableAttributes(c2, t2), r2 && r2.enableAttributes(c2, t2), n2 && n2.enableAttributes(c2, t2), e2.bind(), e2.setVertexAttribPointers(c2, t2, s2);
            for (const e3 of i2) e3.bind(), e3.setVertexAttribPointers(c2, t2, s2);
            o2 && (o2.bind(), o2.setVertexAttribPointers(c2, t2, s2)), a2 && a2.bind(), r2 && (r2.bind(), r2.setVertexAttribPointers(c2, t2, s2)), n2 && (n2.bind(), n2.setVertexAttribPointers(c2, t2, s2)), h2.currentNumAttributes = l3;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const ge2 = (t2, i2, a2, s2, o2) => ({ u_matrix: t2, u_texture: 0, u_ele_delta: i2, u_fog_matrix: a2, u_fog_color: s2 ? s2.properties.get("fog-color") : e.aM.white, u_fog_ground_blend: s2 ? s2.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: s2 ? s2.calculateFogBlendOpacity(o2) : 0, u_horizon_color: s2 ? s2.properties.get("horizon-color") : e.aM.white, u_horizon_fog_blend: s2 ? s2.properties.get("horizon-fog-blend") : 1 });
        function ve(t2) {
          const e2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            if (null === t2[i2]) continue;
            const a2 = t2[i2].split(" ");
            e2.push(a2.pop());
          }
          return e2;
        }
        class xe2 {
          constructor(t2, i2, a2, s2, o2, r2) {
            const n2 = t2.gl;
            this.program = n2.createProgram();
            const l3 = ve(i2.staticAttributes), h2 = a2 ? a2.getBinderAttributes() : [], c2 = l3.concat(h2), u2 = pe.prelude.staticUniforms ? ve(pe.prelude.staticUniforms) : [], d2 = i2.staticUniforms ? ve(i2.staticUniforms) : [], _2 = a2 ? a2.getBinderUniforms() : [], p2 = u2.concat(d2).concat(_2), m2 = [];
            for (const t3 of p2) m2.indexOf(t3) < 0 && m2.push(t3);
            const f2 = a2 ? a2.defines() : [];
            o2 && f2.push("#define OVERDRAW_INSPECTOR;"), r2 && f2.push("#define TERRAIN3D;");
            const g2 = f2.concat(pe.prelude.fragmentSource, i2.fragmentSource).join("\n"), v2 = f2.concat(pe.prelude.vertexSource, i2.vertexSource).join("\n"), x2 = n2.createShader(n2.FRAGMENT_SHADER);
            if (n2.isContextLost()) return void (this.failedToCreate = true);
            if (n2.shaderSource(x2, g2), n2.compileShader(x2), !n2.getShaderParameter(x2, n2.COMPILE_STATUS)) throw new Error("Could not compile fragment shader: ".concat(n2.getShaderInfoLog(x2)));
            n2.attachShader(this.program, x2);
            const y3 = n2.createShader(n2.VERTEX_SHADER);
            if (n2.isContextLost()) return void (this.failedToCreate = true);
            if (n2.shaderSource(y3, v2), n2.compileShader(y3), !n2.getShaderParameter(y3, n2.COMPILE_STATUS)) throw new Error("Could not compile vertex shader: ".concat(n2.getShaderInfoLog(y3)));
            n2.attachShader(this.program, y3), this.attributes = {};
            const b2 = {};
            this.numAttributes = c2.length;
            for (let t3 = 0; t3 < this.numAttributes; t3++) c2[t3] && (n2.bindAttribLocation(this.program, t3, c2[t3]), this.attributes[c2[t3]] = t3);
            if (n2.linkProgram(this.program), !n2.getProgramParameter(this.program, n2.LINK_STATUS)) throw new Error("Program failed to link: ".concat(n2.getProgramInfoLog(this.program)));
            n2.deleteShader(y3), n2.deleteShader(x2);
            for (let t3 = 0; t3 < m2.length; t3++) {
              const e2 = m2[t3];
              if (e2 && !b2[e2]) {
                const t4 = n2.getUniformLocation(this.program, e2);
                t4 && (b2[e2] = t4);
              }
            }
            this.fixedUniforms = s2(t2, b2), this.terrainUniforms = ((t3, i3) => ({ u_depth: new e.aH(t3, i3.u_depth), u_terrain: new e.aH(t3, i3.u_terrain), u_terrain_dim: new e.aI(t3, i3.u_terrain_dim), u_terrain_matrix: new e.aJ(t3, i3.u_terrain_matrix), u_terrain_unpack: new e.aK(t3, i3.u_terrain_unpack), u_terrain_exaggeration: new e.aI(t3, i3.u_terrain_exaggeration) }))(t2, b2), this.binderUniforms = a2 ? a2.getUniforms(t2, b2) : [];
          }
          draw(t2, e2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2, p2, m2, f2, g2) {
            const v2 = t2.gl;
            if (this.failedToCreate) return;
            if (t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(a2), t2.setColorMode(s2), t2.setCullFace(o2), n2) {
              t2.activeTexture.set(v2.TEXTURE2), v2.bindTexture(v2.TEXTURE_2D, n2.depthTexture), t2.activeTexture.set(v2.TEXTURE3), v2.bindTexture(v2.TEXTURE_2D, n2.texture);
              for (const t3 in this.terrainUniforms) this.terrainUniforms[t3].set(n2[t3]);
            }
            for (const t3 in this.fixedUniforms) this.fixedUniforms[t3].set(r2[t3]);
            p2 && p2.setUniforms(t2, this.binderUniforms, d2, { zoom: _2 });
            let x2 = 0;
            switch (e2) {
              case v2.LINES:
                x2 = 2;
                break;
              case v2.TRIANGLES:
                x2 = 3;
                break;
              case v2.LINE_STRIP:
                x2 = 1;
            }
            for (const i3 of u2.get()) {
              const a3 = i3.vaos || (i3.vaos = {});
              (a3[l3] || (a3[l3] = new fe2())).bind(t2, this, h2, p2 ? p2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, m2, f2, g2), v2.drawElements(e2, i3.primitiveLength * x2, v2.UNSIGNED_SHORT, i3.primitiveOffset * x2 * 2);
            }
          }
        }
        function ye2(t2, e2, i2) {
          const a2 = 1 / Bt2(i2, 1, e2.transform.tileZoom), s2 = Math.pow(2, i2.tileID.overscaledZ), o2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / s2, r2 = o2 * (i2.tileID.canonical.x + i2.tileID.wrap * s2), n2 = o2 * i2.tileID.canonical.y;
          return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [a2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [r2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n2] };
        }
        const be2 = (t2, i2, a2, s2) => {
          const o2 = i2.style.light, r2 = o2.properties.get("position"), n2 = [r2.x, r2.y, r2.z], l3 = function() {
            var t3 = new e.A(9);
            return e.A != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
          }();
          "viewport" === o2.properties.get("anchor") && function(t3, e2) {
            var i3 = Math.sin(e2), a3 = Math.cos(e2);
            t3[0] = a3, t3[1] = i3, t3[2] = 0, t3[3] = -i3, t3[4] = a3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1;
          }(l3, -i2.transform.angle), function(t3, e2, i3) {
            var a3 = e2[0], s3 = e2[1], o3 = e2[2];
            t3[0] = a3 * i3[0] + s3 * i3[3] + o3 * i3[6], t3[1] = a3 * i3[1] + s3 * i3[4] + o3 * i3[7], t3[2] = a3 * i3[2] + s3 * i3[5] + o3 * i3[8];
          }(n2, n2, l3);
          const h2 = o2.properties.get("color");
          return { u_matrix: t2, u_lightpos: n2, u_lightintensity: o2.properties.get("intensity"), u_lightcolor: [h2.r, h2.g, h2.b], u_vertical_gradient: +a2, u_opacity: s2 };
        }, we2 = (t2, i2, a2, s2, o2, r2, n2) => e.e(be2(t2, i2, a2, s2), ye2(r2, i2, n2), { u_height_factor: -Math.pow(2, o2.overscaledZ) / n2.tileSize / 8 }), Te2 = (t2) => ({ u_matrix: t2 }), Ie2 = (t2, i2, a2, s2) => e.e(Te2(t2), ye2(a2, i2, s2)), Ee2 = (t2, e2) => ({ u_matrix: t2, u_world: e2 }), Pe2 = (t2, i2, a2, s2, o2) => e.e(Ie2(t2, i2, a2, s2), { u_world: o2 }), Ce2 = (t2, e2, i2, a2) => {
          const s2 = t2.transform;
          let o2, r2;
          if ("map" === a2.paint.get("circle-pitch-alignment")) {
            const t3 = Bt2(i2, 1, s2.zoom);
            o2 = true, r2 = [t3, t3];
          } else o2 = false, r2 = s2.pixelsToGLUnits;
          return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +("map" === a2.paint.get("circle-pitch-scale")), u_matrix: t2.translatePosMatrix(e2.posMatrix, i2, a2.paint.get("circle-translate"), a2.paint.get("circle-translate-anchor")), u_pitch_with_map: +o2, u_device_pixel_ratio: t2.pixelRatio, u_extrude_scale: r2 };
        }, Se2 = (t2, e2, i2) => ({ u_matrix: t2, u_inv_matrix: e2, u_camera_to_center_distance: i2.cameraToCenterDistance, u_viewport_size: [i2.width, i2.height] }), ze = (t2, e2, i2 = 1) => ({ u_matrix: t2, u_color: e2, u_overlay: 0, u_overlay_scale: i2 }), De2 = (t2) => ({ u_matrix: t2 }), Me2 = (t2, e2, i2, a2) => ({ u_matrix: t2, u_extrude_scale: Bt2(e2, 1, i2), u_intensity: a2 }), Ae2 = (t2, i2, a2, s2) => {
          const o2 = e.H();
          e.aP(o2, 0, t2.width, t2.height, 0, 0, 1);
          const r2 = t2.context.gl;
          return { u_matrix: o2, u_world: [r2.drawingBufferWidth, r2.drawingBufferHeight], u_image: a2, u_color_ramp: s2, u_opacity: i2.paint.get("heatmap-opacity") };
        };
        function Re2(t2, i2) {
          const a2 = Math.pow(2, i2.canonical.z), s2 = i2.canonical.y;
          return [new e.Z(0, s2 / a2).toLngLat().lat, new e.Z(0, (s2 + 1) / a2).toLngLat().lat];
        }
        const ke = (t2, e2, i2, a2) => {
          const s2 = t2.transform;
          return { u_matrix: Ne2(t2, e2, i2, a2), u_ratio: 1 / Bt2(e2, 1, s2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]] };
        }, Le2 = (t2, i2, a2, s2, o2) => e.e(ke(t2, i2, a2, o2), { u_image: 0, u_image_height: s2 }), Fe2 = (t2, e2, i2, a2, s2) => {
          const o2 = t2.transform, r2 = Oe2(e2, o2);
          return { u_matrix: Ne2(t2, e2, i2, s2), u_texsize: e2.imageAtlasTexture.size, u_ratio: 1 / Bt2(e2, 1, o2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_image: 0, u_scale: [r2, a2.fromScale, a2.toScale], u_fade: a2.t, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]] };
        }, Be2 = (t2, i2, a2, s2, o2, r2) => {
          const n2 = t2.lineAtlas, l3 = Oe2(i2, t2.transform), h2 = "round" === a2.layout.get("line-cap"), c2 = n2.getDash(s2.from, h2), u2 = n2.getDash(s2.to, h2), d2 = c2.width * o2.fromScale, _2 = u2.width * o2.toScale;
          return e.e(ke(t2, i2, a2, r2), { u_patternscale_a: [l3 / d2, -c2.height / 2], u_patternscale_b: [l3 / _2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, _2) * t2.pixelRatio) / 2, u_image: 0, u_tex_y_a: c2.y, u_tex_y_b: u2.y, u_mix: o2.t });
        };
        function Oe2(t2, e2) {
          return 1 / Bt2(t2, 1, e2.tileZoom);
        }
        function Ne2(t2, e2, i2, a2) {
          return t2.translatePosMatrix(a2 ? a2.posMatrix : e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
        }
        const Ue2 = (t2, e2, i2, a2, s2) => {
          return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: a2.mix, u_opacity: a2.opacity * s2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: s2.paint.get("raster-brightness-min"), u_brightness_high: s2.paint.get("raster-brightness-max"), u_saturation_factor: (r2 = s2.paint.get("raster-saturation"), r2 > 0 ? 1 - 1 / (1.001 - r2) : -r2), u_contrast_factor: (o2 = s2.paint.get("raster-contrast"), o2 > 0 ? 1 / (1 - o2) : 1 + o2), u_spin_weights: je2(s2.paint.get("raster-hue-rotate")) };
          var o2, r2;
        };
        function je2(t2) {
          t2 *= Math.PI / 180;
          const e2 = Math.sin(t2), i2 = Math.cos(t2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
        }
        const Ze2 = (t2, e2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2) => {
          const p2 = r2.transform;
          return { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: p2.cameraToCenterDistance, u_pitch: p2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: p2.width / p2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: n2, u_label_plane_matrix: l3, u_coord_matrix: h2, u_is_text: +u2, u_pitch_with_map: +a2, u_is_along_line: s2, u_is_variable_anchor: o2, u_texsize: d2, u_texture: 0, u_translation: c2, u_pitched_scale: _2 };
        }, qe2 = (t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2, p2, m2) => {
          const f2 = n2.transform;
          return e.e(Ze2(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2, m2), { u_gamma_scale: s2 ? Math.cos(f2._pitch) * f2.cameraToCenterDistance : 1, u_device_pixel_ratio: n2.pixelRatio, u_is_halo: +p2 });
        }, Ve2 = (t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2, p2) => e.e(qe2(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, true, d2, true, p2), { u_texsize_icon: _2, u_texture_icon: 1 }), Ge2 = (t2, e2, i2) => ({ u_matrix: t2, u_opacity: e2, u_color: i2 }), He2 = (t2, i2, a2, s2, o2, r2) => e.e(function(t3, e2, i3, a3) {
          const s3 = i3.imageManager.getPattern(t3.from.toString()), o3 = i3.imageManager.getPattern(t3.to.toString()), { width: r3, height: n2 } = i3.imageManager.getPixelSize(), l3 = Math.pow(2, a3.tileID.overscaledZ), h2 = a3.tileSize * Math.pow(2, i3.transform.tileZoom) / l3, c2 = h2 * (a3.tileID.canonical.x + a3.tileID.wrap * l3), u2 = h2 * a3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: s3.tl, u_pattern_br_a: s3.br, u_pattern_tl_b: o3.tl, u_pattern_br_b: o3.br, u_texsize: [r3, n2], u_mix: e2.t, u_pattern_size_a: s3.displaySize, u_pattern_size_b: o3.displaySize, u_scale_a: e2.fromScale, u_scale_b: e2.toScale, u_tile_units_to_pixels: 1 / Bt2(a3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [c2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & c2, 65535 & u2] };
        }(s2, r2, a2, o2), { u_matrix: t2, u_opacity: i2 }), We2 = { fillExtrusion: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_lightpos: new e.aN(t2, i2.u_lightpos), u_lightintensity: new e.aI(t2, i2.u_lightintensity), u_lightcolor: new e.aN(t2, i2.u_lightcolor), u_vertical_gradient: new e.aI(t2, i2.u_vertical_gradient), u_opacity: new e.aI(t2, i2.u_opacity) }), fillExtrusionPattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_lightpos: new e.aN(t2, i2.u_lightpos), u_lightintensity: new e.aI(t2, i2.u_lightintensity), u_lightcolor: new e.aN(t2, i2.u_lightcolor), u_vertical_gradient: new e.aI(t2, i2.u_vertical_gradient), u_height_factor: new e.aI(t2, i2.u_height_factor), u_image: new e.aH(t2, i2.u_image), u_texsize: new e.aO(t2, i2.u_texsize), u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower), u_scale: new e.aN(t2, i2.u_scale), u_fade: new e.aI(t2, i2.u_fade), u_opacity: new e.aI(t2, i2.u_opacity) }), fill: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix) }), fillPattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_image: new e.aH(t2, i2.u_image), u_texsize: new e.aO(t2, i2.u_texsize), u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower), u_scale: new e.aN(t2, i2.u_scale), u_fade: new e.aI(t2, i2.u_fade) }), fillOutline: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_world: new e.aO(t2, i2.u_world) }), fillOutlinePattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_world: new e.aO(t2, i2.u_world), u_image: new e.aH(t2, i2.u_image), u_texsize: new e.aO(t2, i2.u_texsize), u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower), u_scale: new e.aN(t2, i2.u_scale), u_fade: new e.aI(t2, i2.u_fade) }), circle: (t2, i2) => ({ u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_scale_with_map: new e.aH(t2, i2.u_scale_with_map), u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map), u_extrude_scale: new e.aO(t2, i2.u_extrude_scale), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_matrix: new e.aJ(t2, i2.u_matrix) }), collisionBox: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_pixel_extrude_scale: new e.aO(t2, i2.u_pixel_extrude_scale) }), collisionCircle: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_inv_matrix: new e.aJ(t2, i2.u_inv_matrix), u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_viewport_size: new e.aO(t2, i2.u_viewport_size) }), debug: (t2, i2) => ({ u_color: new e.aL(t2, i2.u_color), u_matrix: new e.aJ(t2, i2.u_matrix), u_overlay: new e.aH(t2, i2.u_overlay), u_overlay_scale: new e.aI(t2, i2.u_overlay_scale) }), clippingMask: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix) }), heatmap: (t2, i2) => ({ u_extrude_scale: new e.aI(t2, i2.u_extrude_scale), u_intensity: new e.aI(t2, i2.u_intensity), u_matrix: new e.aJ(t2, i2.u_matrix) }), heatmapTexture: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_world: new e.aO(t2, i2.u_world), u_image: new e.aH(t2, i2.u_image), u_color_ramp: new e.aH(t2, i2.u_color_ramp), u_opacity: new e.aI(t2, i2.u_opacity) }), hillshade: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_image: new e.aH(t2, i2.u_image), u_latrange: new e.aO(t2, i2.u_latrange), u_light: new e.aO(t2, i2.u_light), u_shadow: new e.aL(t2, i2.u_shadow), u_highlight: new e.aL(t2, i2.u_highlight), u_accent: new e.aL(t2, i2.u_accent) }), hillshadePrepare: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_image: new e.aH(t2, i2.u_image), u_dimension: new e.aO(t2, i2.u_dimension), u_zoom: new e.aI(t2, i2.u_zoom), u_unpack: new e.aK(t2, i2.u_unpack) }), line: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_ratio: new e.aI(t2, i2.u_ratio), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels) }), lineGradient: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_ratio: new e.aI(t2, i2.u_ratio), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels), u_image: new e.aH(t2, i2.u_image), u_image_height: new e.aI(t2, i2.u_image_height) }), linePattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_texsize: new e.aO(t2, i2.u_texsize), u_ratio: new e.aI(t2, i2.u_ratio), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_image: new e.aH(t2, i2.u_image), u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels), u_scale: new e.aN(t2, i2.u_scale), u_fade: new e.aI(t2, i2.u_fade) }), lineSDF: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_ratio: new e.aI(t2, i2.u_ratio), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels), u_patternscale_a: new e.aO(t2, i2.u_patternscale_a), u_patternscale_b: new e.aO(t2, i2.u_patternscale_b), u_sdfgamma: new e.aI(t2, i2.u_sdfgamma), u_image: new e.aH(t2, i2.u_image), u_tex_y_a: new e.aI(t2, i2.u_tex_y_a), u_tex_y_b: new e.aI(t2, i2.u_tex_y_b), u_mix: new e.aI(t2, i2.u_mix) }), raster: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_tl_parent: new e.aO(t2, i2.u_tl_parent), u_scale_parent: new e.aI(t2, i2.u_scale_parent), u_buffer_scale: new e.aI(t2, i2.u_buffer_scale), u_fade_t: new e.aI(t2, i2.u_fade_t), u_opacity: new e.aI(t2, i2.u_opacity), u_image0: new e.aH(t2, i2.u_image0), u_image1: new e.aH(t2, i2.u_image1), u_brightness_low: new e.aI(t2, i2.u_brightness_low), u_brightness_high: new e.aI(t2, i2.u_brightness_high), u_saturation_factor: new e.aI(t2, i2.u_saturation_factor), u_contrast_factor: new e.aI(t2, i2.u_contrast_factor), u_spin_weights: new e.aN(t2, i2.u_spin_weights) }), symbolIcon: (t2, i2) => ({ u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant), u_size_t: new e.aI(t2, i2.u_size_t), u_size: new e.aI(t2, i2.u_size), u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_pitch: new e.aI(t2, i2.u_pitch), u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio), u_fade_change: new e.aI(t2, i2.u_fade_change), u_matrix: new e.aJ(t2, i2.u_matrix), u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix), u_is_text: new e.aH(t2, i2.u_is_text), u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map), u_is_along_line: new e.aH(t2, i2.u_is_along_line), u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor), u_texsize: new e.aO(t2, i2.u_texsize), u_texture: new e.aH(t2, i2.u_texture), u_translation: new e.aO(t2, i2.u_translation), u_pitched_scale: new e.aI(t2, i2.u_pitched_scale) }), symbolSDF: (t2, i2) => ({ u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant), u_size_t: new e.aI(t2, i2.u_size_t), u_size: new e.aI(t2, i2.u_size), u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_pitch: new e.aI(t2, i2.u_pitch), u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio), u_fade_change: new e.aI(t2, i2.u_fade_change), u_matrix: new e.aJ(t2, i2.u_matrix), u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix), u_is_text: new e.aH(t2, i2.u_is_text), u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map), u_is_along_line: new e.aH(t2, i2.u_is_along_line), u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor), u_texsize: new e.aO(t2, i2.u_texsize), u_texture: new e.aH(t2, i2.u_texture), u_gamma_scale: new e.aI(t2, i2.u_gamma_scale), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_is_halo: new e.aH(t2, i2.u_is_halo), u_translation: new e.aO(t2, i2.u_translation), u_pitched_scale: new e.aI(t2, i2.u_pitched_scale) }), symbolTextAndIcon: (t2, i2) => ({ u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant), u_size_t: new e.aI(t2, i2.u_size_t), u_size: new e.aI(t2, i2.u_size), u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_pitch: new e.aI(t2, i2.u_pitch), u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio), u_fade_change: new e.aI(t2, i2.u_fade_change), u_matrix: new e.aJ(t2, i2.u_matrix), u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix), u_is_text: new e.aH(t2, i2.u_is_text), u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map), u_is_along_line: new e.aH(t2, i2.u_is_along_line), u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor), u_texsize: new e.aO(t2, i2.u_texsize), u_texsize_icon: new e.aO(t2, i2.u_texsize_icon), u_texture: new e.aH(t2, i2.u_texture), u_texture_icon: new e.aH(t2, i2.u_texture_icon), u_gamma_scale: new e.aI(t2, i2.u_gamma_scale), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_is_halo: new e.aH(t2, i2.u_is_halo), u_translation: new e.aO(t2, i2.u_translation), u_pitched_scale: new e.aI(t2, i2.u_pitched_scale) }), background: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_opacity: new e.aI(t2, i2.u_opacity), u_color: new e.aL(t2, i2.u_color) }), backgroundPattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_opacity: new e.aI(t2, i2.u_opacity), u_image: new e.aH(t2, i2.u_image), u_pattern_tl_a: new e.aO(t2, i2.u_pattern_tl_a), u_pattern_br_a: new e.aO(t2, i2.u_pattern_br_a), u_pattern_tl_b: new e.aO(t2, i2.u_pattern_tl_b), u_pattern_br_b: new e.aO(t2, i2.u_pattern_br_b), u_texsize: new e.aO(t2, i2.u_texsize), u_mix: new e.aI(t2, i2.u_mix), u_pattern_size_a: new e.aO(t2, i2.u_pattern_size_a), u_pattern_size_b: new e.aO(t2, i2.u_pattern_size_b), u_scale_a: new e.aI(t2, i2.u_scale_a), u_scale_b: new e.aI(t2, i2.u_scale_b), u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new e.aI(t2, i2.u_tile_units_to_pixels) }), terrain: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_texture: new e.aH(t2, i2.u_texture), u_ele_delta: new e.aI(t2, i2.u_ele_delta), u_fog_matrix: new e.aJ(t2, i2.u_fog_matrix), u_fog_color: new e.aL(t2, i2.u_fog_color), u_fog_ground_blend: new e.aI(t2, i2.u_fog_ground_blend), u_fog_ground_blend_opacity: new e.aI(t2, i2.u_fog_ground_blend_opacity), u_horizon_color: new e.aL(t2, i2.u_horizon_color), u_horizon_fog_blend: new e.aI(t2, i2.u_horizon_fog_blend) }), terrainDepth: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_ele_delta: new e.aI(t2, i2.u_ele_delta) }), terrainCoords: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_texture: new e.aH(t2, i2.u_texture), u_terrain_coords_id: new e.aI(t2, i2.u_terrain_coords_id), u_ele_delta: new e.aI(t2, i2.u_ele_delta) }), sky: (t2, i2) => ({ u_sky_color: new e.aL(t2, i2.u_sky_color), u_horizon_color: new e.aL(t2, i2.u_horizon_color), u_horizon: new e.aI(t2, i2.u_horizon), u_sky_horizon_blend: new e.aI(t2, i2.u_sky_horizon_blend) }) };
        class $e2 {
          constructor(t2, e2, i2) {
            this.context = t2;
            const a2 = t2.gl;
            this.buffer = a2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), a2.bufferData(a2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t2) {
            const e2 = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Xe2 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Ke2 {
          constructor(t2, e2, i2, a2) {
            this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = a2, this.context = t2;
            const s2 = t2.gl;
            this.buffer = s2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), s2.bufferData(s2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t2) {
            if (t2.length !== this.length) throw new Error("Length of new data is ".concat(t2.length, ", which doesn't match current length of ").concat(this.length));
            const e2 = this.context.gl;
            this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
          }
          enableAttributes(t2, e2) {
            for (let i2 = 0; i2 < this.attributes.length; i2++) {
              const a2 = e2.attributes[this.attributes[i2].name];
              void 0 !== a2 && t2.enableVertexAttribArray(a2);
            }
          }
          setVertexAttribPointers(t2, e2, i2) {
            for (let a2 = 0; a2 < this.attributes.length; a2++) {
              const s2 = this.attributes[a2], o2 = e2.attributes[s2.name];
              void 0 !== o2 && t2.vertexAttribPointer(o2, s2.components, t2[Xe2[s2.type]], false, this.itemSize, s2.offset + this.itemSize * (i2 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Je2 = /* @__PURE__ */ new WeakMap();
        function Ye2(t2) {
          var e2;
          if (Je2.has(t2)) return Je2.get(t2);
          {
            const i2 = null === (e2 = t2.getParameter(t2.VERSION)) || void 0 === e2 ? void 0 : e2.startsWith("WebGL 2.0");
            return Je2.set(t2, i2), i2;
          }
        }
        class Qe2 {
          constructor(t2) {
            this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(t2) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class ti2 extends Qe2 {
          getDefault() {
            return e.aM.transparent;
          }
          set(t2) {
            const e2 = this.current;
            (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
          }
        }
        class ei2 extends Qe2 {
          getDefault() {
            return 1;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = false);
          }
        }
        class ii2 extends Qe2 {
          getDefault() {
            return 0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = false);
          }
        }
        class ai2 extends Qe2 {
          getDefault() {
            return [true, true, true, true];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
          }
        }
        class si2 extends Qe2 {
          getDefault() {
            return true;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = false);
          }
        }
        class oi2 extends Qe2 {
          getDefault() {
            return 255;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = false);
          }
        }
        class ri2 extends Qe2 {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t2) {
            const e2 = this.current;
            (t2.func !== e2.func || t2.ref !== e2.ref || t2.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = false);
          }
        }
        class ni2 extends Qe2 {
          getDefault() {
            const t2 = this.gl;
            return [t2.KEEP, t2.KEEP, t2.KEEP];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = false);
          }
        }
        class li2 extends Qe2 {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            t2 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t2, this.dirty = false;
          }
        }
        class hi2 extends Qe2 {
          getDefault() {
            return [0, 1];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = false);
          }
        }
        class ci2 extends Qe2 {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            t2 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t2, this.dirty = false;
          }
        }
        class ui2 extends Qe2 {
          getDefault() {
            return this.gl.LESS;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = false);
          }
        }
        class di2 extends Qe2 {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            t2 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t2, this.dirty = false;
          }
        }
        class _i2 extends Qe2 {
          getDefault() {
            const t2 = this.gl;
            return [t2.ONE, t2.ZERO];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = false);
          }
        }
        class pi2 extends Qe2 {
          getDefault() {
            return e.aM.transparent;
          }
          set(t2) {
            const e2 = this.current;
            (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
          }
        }
        class mi2 extends Qe2 {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = false);
          }
        }
        class fi2 extends Qe2 {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            t2 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t2, this.dirty = false;
          }
        }
        class gi2 extends Qe2 {
          getDefault() {
            return this.gl.BACK;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = false);
          }
        }
        class vi2 extends Qe2 {
          getDefault() {
            return this.gl.CCW;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = false);
          }
        }
        class xi2 extends Qe2 {
          getDefault() {
            return null;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = false);
          }
        }
        class yi2 extends Qe2 {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = false);
          }
        }
        class bi2 extends Qe2 {
          getDefault() {
            const t2 = this.gl;
            return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
          }
        }
        class wi2 extends Qe2 {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.bindFramebuffer(e2.FRAMEBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class Ti2 extends Qe2 {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.bindRenderbuffer(e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class Ii2 extends Qe2 {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.bindTexture(e2.TEXTURE_2D, t2), this.current = t2, this.dirty = false;
          }
        }
        class Ei2 extends Qe2 {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.bindBuffer(e2.ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class Pi2 extends Qe2 {
          getDefault() {
            return null;
          }
          set(t2) {
            const e2 = this.gl;
            e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class Ci2 extends Qe2 {
          getDefault() {
            return null;
          }
          set(t2) {
            var e2;
            if (t2 === this.current && !this.dirty) return;
            const i2 = this.gl;
            Ye2(i2) ? i2.bindVertexArray(t2) : null === (e2 = i2.getExtension("OES_vertex_array_object")) || void 0 === e2 || e2.bindVertexArrayOES(t2), this.current = t2, this.dirty = false;
          }
        }
        class Si2 extends Qe2 {
          getDefault() {
            return 4;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = false;
          }
        }
        class zi2 extends Qe2 {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = false;
          }
        }
        class Di2 extends Qe2 {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = false;
          }
        }
        class Mi2 extends Qe2 {
          constructor(t2, e2) {
            super(t2), this.context = t2, this.parent = e2;
          }
          getDefault() {
            return null;
          }
        }
        class Ai2 extends Mi2 {
          setDirty() {
            this.dirty = true;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = false;
          }
        }
        class Ri2 extends Mi2 {
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class ki2 extends Mi2 {
          set(t2) {
            if (t2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class Li2 {
          constructor(t2, e2, i2, a2, s2) {
            this.context = t2, this.width = e2, this.height = i2;
            const o2 = t2.gl, r2 = this.framebuffer = o2.createFramebuffer();
            if (this.colorAttachment = new Ai2(t2, r2), a2) this.depthAttachment = s2 ? new ki2(t2, r2) : new Ri2(t2, r2);
            else if (s2) throw new Error("Stencil cannot be set without depth");
            if (o2.checkFramebufferStatus(o2.FRAMEBUFFER) !== o2.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
          }
          destroy() {
            const t2 = this.context.gl, e2 = this.colorAttachment.get();
            if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
              const e3 = this.depthAttachment.get();
              e3 && t2.deleteRenderbuffer(e3);
            }
            t2.deleteFramebuffer(this.framebuffer);
          }
        }
        class Fi2 {
          constructor(t2, e2, i2) {
            this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
          }
        }
        Fi2.Replace = [1, 0], Fi2.disabled = new Fi2(Fi2.Replace, e.aM.transparent, [false, false, false, false]), Fi2.unblended = new Fi2(Fi2.Replace, e.aM.transparent, [true, true, true, true]), Fi2.alphaBlended = new Fi2([1, 771], e.aM.transparent, [true, true, true, true]);
        class Bi2 {
          constructor(t2) {
            var e2, i2;
            if (this.gl = t2, this.clearColor = new ti2(this), this.clearDepth = new ei2(this), this.clearStencil = new ii2(this), this.colorMask = new ai2(this), this.depthMask = new si2(this), this.stencilMask = new oi2(this), this.stencilFunc = new ri2(this), this.stencilOp = new ni2(this), this.stencilTest = new li2(this), this.depthRange = new hi2(this), this.depthTest = new ci2(this), this.depthFunc = new ui2(this), this.blend = new di2(this), this.blendFunc = new _i2(this), this.blendColor = new pi2(this), this.blendEquation = new mi2(this), this.cullFace = new fi2(this), this.cullFaceSide = new gi2(this), this.frontFace = new vi2(this), this.program = new xi2(this), this.activeTexture = new yi2(this), this.viewport = new bi2(this), this.bindFramebuffer = new wi2(this), this.bindRenderbuffer = new Ti2(this), this.bindTexture = new Ii2(this), this.bindVertexBuffer = new Ei2(this), this.bindElementBuffer = new Pi2(this), this.bindVertexArray = new Ci2(this), this.pixelStoreUnpack = new Si2(this), this.pixelStoreUnpackPremultiplyAlpha = new zi2(this), this.pixelStoreUnpackFlipY = new Di2(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE), Ye2(t2)) {
              this.HALF_FLOAT = t2.HALF_FLOAT;
              const a2 = t2.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = null !== (e2 = t2.RGBA16F) && void 0 !== e2 ? e2 : null == a2 ? void 0 : a2.RGBA16F_EXT, this.RGB16F = null !== (i2 = t2.RGB16F) && void 0 !== i2 ? i2 : null == a2 ? void 0 : a2.RGB16F_EXT, t2.getExtension("EXT_color_buffer_float");
            } else {
              t2.getExtension("EXT_color_buffer_half_float"), t2.getExtension("OES_texture_half_float_linear");
              const e3 = t2.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = null == e3 ? void 0 : e3.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(t2, e2) {
            return new $e2(this, t2, e2);
          }
          createVertexBuffer(t2, e2, i2) {
            return new Ke2(this, t2, e2, i2);
          }
          createRenderbuffer(t2, e2, i2) {
            const a2 = this.gl, s2 = a2.createRenderbuffer();
            return this.bindRenderbuffer.set(s2), a2.renderbufferStorage(a2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), s2;
          }
          createFramebuffer(t2, e2, i2, a2) {
            return new Li2(this, t2, e2, i2, a2);
          }
          clear({ color: t2, depth: e2, stencil: i2 }) {
            const a2 = this.gl;
            let s2 = 0;
            t2 && (s2 |= a2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([true, true, true, true])), void 0 !== e2 && (s2 |= a2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), void 0 !== i2 && (s2 |= a2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), a2.clear(s2);
          }
          setCullFace(t2) {
            false === t2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
          }
          setDepthMode(t2) {
            t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
          }
          setStencilMode(t2) {
            t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(t2) {
            e.aE(t2.blendFunction, Fi2.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
          }
          createVertexArray() {
            var t2;
            return Ye2(this.gl) ? this.gl.createVertexArray() : null === (t2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t2 ? void 0 : t2.createVertexArrayOES();
          }
          deleteVertexArray(t2) {
            var e2;
            return Ye2(this.gl) ? this.gl.deleteVertexArray(t2) : null === (e2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e2 ? void 0 : e2.deleteVertexArrayOES(t2);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        class Oi2 {
          constructor(t2, e2, i2) {
            this.func = t2, this.mask = e2, this.range = i2;
          }
        }
        Oi2.ReadOnly = false, Oi2.ReadWrite = true, Oi2.disabled = new Oi2(519, Oi2.ReadOnly, [0, 1]);
        const Ni2 = 7680;
        class Ui2 {
          constructor(t2, e2, i2, a2, s2, o2) {
            this.test = t2, this.ref = e2, this.mask = i2, this.fail = a2, this.depthFail = s2, this.pass = o2;
          }
        }
        Ui2.disabled = new Ui2({ func: 519, mask: 0 }, 0, 0, Ni2, Ni2, Ni2);
        class ji2 {
          constructor(t2, e2, i2) {
            this.enable = t2, this.mode = e2, this.frontFace = i2;
          }
        }
        let Zi2;
        function qi2(t2, i2, a2, s2, o2) {
          const r2 = t2.context, n2 = r2.gl, l3 = t2.useProgram("collisionBox"), h2 = [];
          let c2 = 0, u2 = 0;
          for (let _3 = 0; _3 < s2.length; _3++) {
            const p3 = s2[_3], m3 = i2.getTile(p3).getBucket(a2);
            if (!m3) continue;
            const f3 = o2 ? m3.textCollisionBox : m3.iconCollisionBox, g3 = m3.collisionCircleArray;
            if (g3.length > 0) {
              const i3 = e.H();
              e.aQ(i3, m3.placementInvProjMatrix, t2.transform.glCoordMatrix), e.aQ(i3, i3, m3.placementViewportMatrix), h2.push({ circleArray: g3, circleOffset: u2, transform: p3.posMatrix, invTransform: i3, coord: p3 }), c2 += g3.length / 4, u2 = c2;
            }
            f3 && l3.draw(r2, n2.LINES, Oi2.disabled, Ui2.disabled, t2.colorModeForRenderPass(), ji2.disabled, { u_matrix: p3.posMatrix, u_pixel_extrude_scale: [1 / (d2 = t2.transform).width, 1 / d2.height] }, t2.style.map.terrain && t2.style.map.terrain.getTerrainData(p3), a2.id, f3.layoutVertexBuffer, f3.indexBuffer, f3.segments, null, t2.transform.zoom, null, null, f3.collisionVertexBuffer);
          }
          var d2;
          if (!o2 || !h2.length) return;
          const _2 = t2.useProgram("collisionCircle"), p2 = new e.aR();
          p2.resize(4 * c2), p2._trim();
          let m2 = 0;
          for (const t3 of h2) for (let e2 = 0; e2 < t3.circleArray.length / 4; e2++) {
            const i3 = 4 * e2, a3 = t3.circleArray[i3 + 0], s3 = t3.circleArray[i3 + 1], o3 = t3.circleArray[i3 + 2], r3 = t3.circleArray[i3 + 3];
            p2.emplace(m2++, a3, s3, o3, r3, 0), p2.emplace(m2++, a3, s3, o3, r3, 1), p2.emplace(m2++, a3, s3, o3, r3, 2), p2.emplace(m2++, a3, s3, o3, r3, 3);
          }
          (!Zi2 || Zi2.length < 2 * c2) && (Zi2 = function(t3) {
            const i3 = 2 * t3, a3 = new e.aT();
            a3.resize(i3), a3._trim();
            for (let t4 = 0; t4 < i3; t4++) {
              const e2 = 6 * t4;
              a3.uint16[e2 + 0] = 4 * t4 + 0, a3.uint16[e2 + 1] = 4 * t4 + 1, a3.uint16[e2 + 2] = 4 * t4 + 2, a3.uint16[e2 + 3] = 4 * t4 + 2, a3.uint16[e2 + 4] = 4 * t4 + 3, a3.uint16[e2 + 5] = 4 * t4 + 0;
            }
            return a3;
          }(c2));
          const f2 = r2.createIndexBuffer(Zi2, true), g2 = r2.createVertexBuffer(p2, e.aS.members, true);
          for (const i3 of h2) {
            const s3 = Se2(i3.transform, i3.invTransform, t2.transform);
            _2.draw(r2, n2.TRIANGLES, Oi2.disabled, Ui2.disabled, t2.colorModeForRenderPass(), ji2.disabled, s3, t2.style.map.terrain && t2.style.map.terrain.getTerrainData(i3.coord), a2.id, g2, f2, e.a0.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, t2.transform.zoom, null, null, null);
          }
          g2.destroy(), f2.destroy();
        }
        ji2.disabled = new ji2(false, 1029, 2305), ji2.backCCW = new ji2(true, 1029, 2305);
        const Vi2 = e.an(new Float32Array(16));
        function Gi2(t2, i2, a2, s2, o2, r2) {
          const { horizontalAlign: n2, verticalAlign: l3 } = e.au(t2);
          return new e.P((-(n2 - 0.5) * i2 / o2 + s2[0]) * r2, (-(l3 - 0.5) * a2 / o2 + s2[1]) * r2);
        }
        function Hi2(t2, i2, a2, s2, o2, r2) {
          const n2 = i2.tileAnchorPoint.add(new e.P(i2.translation[0], i2.translation[1]));
          if (i2.pitchWithMap) {
            let t3 = s2.mult(r2);
            a2 || (t3 = t3.rotate(-o2));
            const e2 = n2.add(t3);
            return xt2(e2.x, e2.y, i2.labelPlaneMatrix, i2.getElevation).point;
          }
          if (a2) {
            const e2 = St2(i2.tileAnchorPoint.x + 1, i2.tileAnchorPoint.y, i2).point.sub(t2), a3 = Math.atan(e2.y / e2.x) + (e2.x < 0 ? Math.PI : 0);
            return t2.add(s2.rotate(a3));
          }
          return t2.add(s2);
        }
        function Wi2(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2, _2, p2) {
          const m2 = t2.text.placedSymbolArray, f2 = t2.text.dynamicLayoutVertexArray, g2 = t2.icon.dynamicLayoutVertexArray, v2 = {};
          f2.clear();
          for (let g3 = 0; g3 < m2.length; g3++) {
            const x2 = m2.get(g3), y3 = x2.hidden || !x2.crossTileID || t2.allowVerticalPlacement && !x2.placedOrientation ? null : s2[x2.crossTileID];
            if (y3) {
              const s3 = new e.P(x2.anchorX, x2.anchorY), m3 = { getElevation: p2, width: o2.width, height: o2.height, labelPlaneMatrix: r2, lineVertexArray: null, pitchWithMap: a2, projection: u2, projectionCache: null, tileAnchorPoint: s3, translation: d2, unwrappedTileID: _2 }, g4 = a2 ? xt2(s3.x, s3.y, n2, p2) : St2(s3.x, s3.y, m3), b2 = yt2(o2.cameraToCenterDistance, g4.signedDistanceFromCamera);
              let w2 = e.ai(t2.textSizeData, h2, x2) * b2 / e.ap;
              a2 && (w2 *= t2.tilePixelRatio / l3);
              const { width: T2, height: I2, anchor: E2, textOffset: P2, textBoxScale: C3 } = y3, S2 = Gi2(E2, T2, I2, P2, C3, w2), z3 = u2.getPitchedTextCorrection(o2, s3.add(new e.P(d2[0], d2[1])), _2), D2 = Hi2(g4.point, m3, i2, S2, o2.angle, z3), M3 = t2.allowVerticalPlacement && x2.placedOrientation === e.ah.vertical ? Math.PI / 2 : 0;
              for (let t3 = 0; t3 < x2.numGlyphs; t3++) e.aj(f2, D2, M3);
              c2 && x2.associatedIconIndex >= 0 && (v2[x2.associatedIconIndex] = { shiftedAnchor: D2, angle: M3 });
            } else Rt2(x2.numGlyphs, f2);
          }
          if (c2) {
            g2.clear();
            const i3 = t2.icon.placedSymbolArray;
            for (let t3 = 0; t3 < i3.length; t3++) {
              const a3 = i3.get(t3);
              if (a3.hidden) Rt2(a3.numGlyphs, g2);
              else {
                const i4 = v2[t3];
                if (i4) for (let t4 = 0; t4 < a3.numGlyphs; t4++) e.aj(g2, i4.shiftedAnchor, i4.angle);
                else Rt2(a3.numGlyphs, g2);
              }
            }
            t2.icon.dynamicLayoutVertexBuffer.updateData(g2);
          }
          t2.text.dynamicLayoutVertexBuffer.updateData(f2);
        }
        function $i2(t2, e2, i2) {
          return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
        }
        function Xi2(t2, i2, a2, s2, o2, r2, n2, l3, h2, c2, u2, d2) {
          const _2 = t2.context, p2 = _2.gl, m2 = t2.transform, f2 = ie(), g2 = "map" === l3, v2 = "map" === h2, x2 = "viewport" !== l3 && "point" !== a2.layout.get("symbol-placement"), y3 = g2 && !v2 && !x2, b2 = !v2 && x2, w2 = !a2.layout.get("symbol-sort-key").isConstant();
          let T2 = false;
          const I2 = t2.depthModeForSublayer(0, Oi2.ReadOnly), E2 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), P2 = [], C3 = f2.getCircleRadiusCorrection(m2);
          for (const l4 of s2) {
            const s3 = i2.getTile(l4), h3 = s3.getBucket(a2);
            if (!h3) continue;
            const u3 = o2 ? h3.text : h3.icon;
            if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices) continue;
            const d3 = u3.programConfigurations.get(a2.id), _3 = o2 || h3.sdfIcons, I3 = o2 ? h3.textSizeData : h3.iconSizeData, S2 = v2 || 0 !== m2.pitch, z3 = t2.useProgram($i2(_3, o2, h3), d3), D2 = e.ag(I3, m2.zoom), M3 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(l4);
            let A3, R2, k2, L3, F2 = [0, 0], B2 = null;
            if (o2) R2 = s3.glyphAtlasTexture, k2 = p2.LINEAR, A3 = s3.glyphAtlasTexture.size, h3.iconsInText && (F2 = s3.imageAtlasTexture.size, B2 = s3.imageAtlasTexture, L3 = S2 || t2.options.rotating || t2.options.zooming || "composite" === I3.kind || "camera" === I3.kind ? p2.LINEAR : p2.NEAREST);
            else {
              const e2 = 1 !== a2.layout.get("icon-size").constantOr(0) || h3.iconsNeedLinear;
              R2 = s3.imageAtlasTexture, k2 = _3 || t2.options.rotating || t2.options.zooming || e2 || S2 ? p2.LINEAR : p2.NEAREST, A3 = s3.imageAtlasTexture.size;
            }
            const O2 = Bt2(s3, 1, t2.transform.zoom), N2 = b2 ? l4.posMatrix : Vi2, U3 = gt2(N2, v2, g2, t2.transform, O2), j2 = vt2(N2, v2, g2, t2.transform, O2), Z2 = vt2(l4.posMatrix, v2, g2, t2.transform, O2), q2 = f2.translatePosition(t2.transform, s3, r2, n2), V3 = E2 && h3.hasTextData(), G2 = "none" !== a2.layout.get("icon-text-fit") && V3 && h3.hasIconData();
            if (x2) {
              const e2 = t2.style.map.terrain ? (e3, i4) => t2.style.map.terrain.getElevation(l4, e3, i4) : null, i3 = "map" === a2.layout.get("text-rotation-alignment");
              wt2(h3, l4.posMatrix, t2, o2, U3, Z2, v2, c2, i3, f2, l4.toUnwrapped(), m2.width, m2.height, q2, e2);
            }
            const H2 = l4.posMatrix, W3 = o2 && E2 || G2, $2 = x2 || W3 ? Vi2 : U3, X2 = j2, K2 = _3 && 0 !== a2.paint.get(o2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let J3;
            J3 = _3 ? h3.iconsInText ? Ve2(I3.kind, D2, y3, v2, x2, W3, t2, H2, $2, X2, q2, A3, F2, C3) : qe2(I3.kind, D2, y3, v2, x2, W3, t2, H2, $2, X2, q2, o2, A3, true, C3) : Ze2(I3.kind, D2, y3, v2, x2, W3, t2, H2, $2, X2, q2, o2, A3, C3);
            const Y2 = { program: z3, buffers: u3, uniformValues: J3, atlasTexture: R2, atlasTextureIcon: B2, atlasInterpolation: k2, atlasInterpolationIcon: L3, isSDF: _3, hasHalo: K2 };
            if (w2 && h3.canOverlap) {
              T2 = true;
              const t3 = u3.segments.get();
              for (const i3 of t3) P2.push({ segments: new e.a0([i3]), sortKey: i3.sortKey, state: Y2, terrainData: M3 });
            } else P2.push({ segments: u3.segments, sortKey: 0, state: Y2, terrainData: M3 });
          }
          T2 && P2.sort((t3, e2) => t3.sortKey - e2.sortKey);
          for (const e2 of P2) {
            const i3 = e2.state;
            if (_2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (_2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
              const s3 = i3.uniformValues;
              i3.hasHalo && (s3.u_is_halo = 1, Ki2(i3.buffers, e2.segments, a2, t2, i3.program, I2, u2, d2, s3, e2.terrainData)), s3.u_is_halo = 0;
            }
            Ki2(i3.buffers, e2.segments, a2, t2, i3.program, I2, u2, d2, i3.uniformValues, e2.terrainData);
          }
        }
        function Ki2(t2, e2, i2, a2, s2, o2, r2, n2, l3, h2) {
          const c2 = a2.context;
          s2.draw(c2, c2.gl.TRIANGLES, o2, r2, n2, ji2.disabled, l3, h2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, a2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
        }
        function Ji2(t2, i2, a2, s2) {
          const o2 = t2.context, r2 = o2.gl, n2 = Ui2.disabled, l3 = new Fi2([r2.ONE, r2.ONE], e.aM.transparent, [true, true, true, true]), h2 = i2.getBucket(a2);
          if (!h2) return;
          const c2 = s2.key;
          let u2 = a2.heatmapFbos.get(c2);
          u2 || (u2 = Qi2(o2, i2.tileSize, i2.tileSize), a2.heatmapFbos.set(c2, u2)), o2.bindFramebuffer.set(u2.framebuffer), o2.viewport.set([0, 0, i2.tileSize, i2.tileSize]), o2.clear({ color: e.aM.transparent });
          const d2 = h2.programConfigurations.get(a2.id), _2 = t2.useProgram("heatmap", d2), p2 = t2.style.map.terrain.getTerrainData(s2);
          _2.draw(o2, r2.TRIANGLES, Oi2.disabled, n2, l3, ji2.disabled, Me2(s2.posMatrix, i2, t2.transform.zoom, a2.paint.get("heatmap-intensity")), p2, a2.id, h2.layoutVertexBuffer, h2.indexBuffer, h2.segments, a2.paint, t2.transform.zoom, d2);
        }
        function Yi2(t2, e2, i2) {
          const a2 = t2.context, s2 = a2.gl;
          a2.setColorMode(t2.colorModeForRenderPass());
          const o2 = ta2(a2, e2), r2 = i2.key, n2 = e2.heatmapFbos.get(r2);
          n2 && (a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, n2.colorAttachment.get()), a2.activeTexture.set(s2.TEXTURE1), o2.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), t2.useProgram("heatmapTexture").draw(a2, s2.TRIANGLES, Oi2.disabled, Ui2.disabled, t2.colorModeForRenderPass(), ji2.disabled, Ae2(t2, e2, 0, 1), null, e2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments, e2.paint, t2.transform.zoom), n2.destroy(), e2.heatmapFbos.delete(r2));
        }
        function Qi2(t2, e2, i2) {
          var a2, s2;
          const o2 = t2.gl, r2 = o2.createTexture();
          o2.bindTexture(o2.TEXTURE_2D, r2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, o2.LINEAR), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, o2.LINEAR);
          const n2 = null !== (a2 = t2.HALF_FLOAT) && void 0 !== a2 ? a2 : o2.UNSIGNED_BYTE, l3 = null !== (s2 = t2.RGBA16F) && void 0 !== s2 ? s2 : o2.RGBA;
          o2.texImage2D(o2.TEXTURE_2D, 0, l3, e2, i2, 0, o2.RGBA, n2, null);
          const h2 = t2.createFramebuffer(e2, i2, false, false);
          return h2.colorAttachment.set(r2), h2;
        }
        function ta2(t2, e2) {
          return e2.colorRampTexture || (e2.colorRampTexture = new b(t2, e2.colorRamp, t2.gl.RGBA)), e2.colorRampTexture;
        }
        function ea2(t2, e2, i2, a2, s2) {
          if (!i2 || !a2 || !a2.imageAtlas) return;
          const o2 = a2.imageAtlas.patternPositions;
          let r2 = o2[i2.to.toString()], n2 = o2[i2.from.toString()];
          if (!r2 && n2 && (r2 = n2), !n2 && r2 && (n2 = r2), !r2 || !n2) {
            const t3 = s2.getPaintProperty(e2);
            r2 = o2[t3], n2 = o2[t3];
          }
          r2 && n2 && t2.setConstantPatternPositions(r2, n2);
        }
        function ia2(t2, e2, i2, a2, s2, o2, r2) {
          const n2 = t2.context.gl, l3 = "fill-pattern", h2 = i2.paint.get(l3), c2 = h2 && h2.constantOr(1), u2 = i2.getCrossfadeParameters();
          let d2, _2, p2, m2, f2;
          r2 ? (_2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d2 = n2.LINES) : (_2 = c2 ? "fillPattern" : "fill", d2 = n2.TRIANGLES);
          const g2 = h2.constantOr(null);
          for (const h3 of a2) {
            const a3 = e2.getTile(h3);
            if (c2 && !a3.patternsLoaded()) continue;
            const v2 = a3.getBucket(i2);
            if (!v2) continue;
            const x2 = v2.programConfigurations.get(i2.id), y3 = t2.useProgram(_2, x2), b2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(h3);
            c2 && (t2.context.activeTexture.set(n2.TEXTURE0), a3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2.updatePaintBuffers(u2)), ea2(x2, l3, g2, a3, i2);
            const w2 = b2 ? h3 : null, T2 = t2.translatePosMatrix(w2 ? w2.posMatrix : h3.posMatrix, a3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
            if (r2) {
              m2 = v2.indexBuffer2, f2 = v2.segments2;
              const e3 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
              p2 = "fillOutlinePattern" === _2 && c2 ? Pe2(T2, t2, u2, a3, e3) : Ee2(T2, e3);
            } else m2 = v2.indexBuffer, f2 = v2.segments, p2 = c2 ? Ie2(T2, t2, u2, a3) : Te2(T2);
            y3.draw(t2.context, d2, s2, t2.stencilModeForClipping(h3), o2, ji2.disabled, p2, b2, i2.id, v2.layoutVertexBuffer, m2, f2, i2.paint, t2.transform.zoom, x2);
          }
        }
        function aa2(t2, e2, i2, a2, s2, o2, r2) {
          const n2 = t2.context, l3 = n2.gl, h2 = "fill-extrusion-pattern", c2 = i2.paint.get(h2), u2 = c2.constantOr(1), d2 = i2.getCrossfadeParameters(), _2 = i2.paint.get("fill-extrusion-opacity"), p2 = c2.constantOr(null);
          for (const c3 of a2) {
            const a3 = e2.getTile(c3), m2 = a3.getBucket(i2);
            if (!m2) continue;
            const f2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(c3), g2 = m2.programConfigurations.get(i2.id), v2 = t2.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", g2);
            u2 && (t2.context.activeTexture.set(l3.TEXTURE0), a3.imageAtlasTexture.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), g2.updatePaintBuffers(d2)), ea2(g2, h2, p2, a3, i2);
            const x2 = t2.translatePosMatrix(c3.posMatrix, a3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), y3 = i2.paint.get("fill-extrusion-vertical-gradient"), b2 = u2 ? we2(x2, t2, y3, _2, c3, d2, a3) : be2(x2, t2, y3, _2);
            v2.draw(n2, n2.gl.TRIANGLES, s2, o2, r2, ji2.backCCW, b2, f2, i2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, i2.paint, t2.transform.zoom, g2, t2.style.map.terrain && m2.centroidVertexBuffer);
          }
        }
        function sa2(t2, e2, i2, a2, s2, o2, r2) {
          const n2 = t2.context, l3 = n2.gl, h2 = i2.fbo;
          if (!h2) return;
          const c2 = t2.useProgram("hillshade"), u2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(e2);
          n2.activeTexture.set(l3.TEXTURE0), l3.bindTexture(l3.TEXTURE_2D, h2.colorAttachment.get()), c2.draw(n2, l3.TRIANGLES, s2, o2, r2, ji2.disabled, ((t3, e3, i3, a3) => {
            const s3 = i3.paint.get("hillshade-shadow-color"), o3 = i3.paint.get("hillshade-highlight-color"), r3 = i3.paint.get("hillshade-accent-color");
            let n3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i3.paint.get("hillshade-illumination-anchor") && (n3 -= t3.transform.angle);
            const l4 = !t3.options.moving;
            return { u_matrix: a3 ? a3.posMatrix : t3.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l4), u_image: 0, u_latrange: Re2(0, e3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), n3], u_shadow: s3, u_highlight: o3, u_accent: r3 };
          })(t2, i2, a2, u2 ? e2 : null), u2, a2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
        }
        function oa2(t2, i2, a2, s2, o2, r2) {
          const n2 = t2.context, l3 = n2.gl, h2 = i2.dem;
          if (h2 && h2.data) {
            const c2 = h2.dim, u2 = h2.stride, d2 = h2.getPixels();
            if (n2.activeTexture.set(l3.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(u2), i2.demTexture) {
              const t3 = i2.demTexture;
              t3.update(d2, { premultiply: false }), t3.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
            } else i2.demTexture = new b(n2, d2, l3.RGBA, { premultiply: false }), i2.demTexture.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
            n2.activeTexture.set(l3.TEXTURE0);
            let _2 = i2.fbo;
            if (!_2) {
              const t3 = new b(n2, { width: c2, height: c2, data: null }, l3.RGBA);
              t3.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), _2 = i2.fbo = n2.createFramebuffer(c2, c2, true, false), _2.colorAttachment.set(t3.texture);
            }
            n2.bindFramebuffer.set(_2.framebuffer), n2.viewport.set([0, 0, c2, c2]), t2.useProgram("hillshadePrepare").draw(n2, l3.TRIANGLES, s2, o2, r2, ji2.disabled, ((t3, i3) => {
              const a3 = i3.stride, s3 = e.H();
              return e.aP(s3, 0, e.X, -e.X, 0, 0, 1), e.J(s3, s3, [0, -e.X, 0]), { u_matrix: s3, u_image: 1, u_dimension: [a3, a3], u_zoom: t3.overscaledZ, u_unpack: i3.getUnpackVector() };
            })(i2.tileID, h2), null, a2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
          }
        }
        function ra2(t2, i2, a2, s2, r2, n2) {
          const l3 = s2.paint.get("raster-fade-duration");
          if (!n2 && l3 > 0) {
            const s3 = o.now(), n3 = (s3 - t2.timeAdded) / l3, h2 = i2 ? (s3 - i2.timeAdded) / l3 : -1, c2 = a2.getSource(), u2 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - u2) > Math.abs(t2.tileID.overscaledZ - u2), _2 = d2 && t2.refreshedUponExpiration ? 1 : e.ac(d2 ? n3 : 1 - h2, 0, 1);
            return t2.refreshedUponExpiration && n3 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const na2 = new e.aM(1, 0, 0, 1), la2 = new e.aM(0, 1, 0, 1), ha2 = new e.aM(0, 0, 1, 1), ca2 = new e.aM(1, 0, 1, 1), ua2 = new e.aM(0, 1, 1, 1);
        function da2(t2, e2, i2, a2) {
          pa2(t2, 0, e2 + i2 / 2, t2.transform.width, i2, a2);
        }
        function _a2(t2, e2, i2, a2) {
          pa2(t2, e2 - i2 / 2, 0, i2, t2.transform.height, a2);
        }
        function pa2(t2, e2, i2, a2, s2, o2) {
          const r2 = t2.context, n2 = r2.gl;
          n2.enable(n2.SCISSOR_TEST), n2.scissor(e2 * t2.pixelRatio, i2 * t2.pixelRatio, a2 * t2.pixelRatio, s2 * t2.pixelRatio), r2.clear({ color: o2 }), n2.disable(n2.SCISSOR_TEST);
        }
        function ma2(t2, i2, a2) {
          const s2 = t2.context, o2 = s2.gl, r2 = a2.posMatrix, n2 = t2.useProgram("debug"), l3 = Oi2.disabled, h2 = Ui2.disabled, c2 = t2.colorModeForRenderPass(), u2 = "$debug", d2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(a2);
          s2.activeTexture.set(o2.TEXTURE0);
          const _2 = i2.getTileByID(a2.key).latestRawTileData, p2 = Math.floor((_2 && _2.byteLength || 0) / 1024), m2 = i2.getTile(a2).tileSize, f2 = 512 / Math.min(m2, 512) * (a2.overscaledZ / t2.transform.zoom) * 0.5;
          let g2 = a2.canonical.toString();
          a2.overscaledZ !== a2.canonical.z && (g2 += " => ".concat(a2.overscaledZ)), function(t3, e2) {
            t3.initDebugOverlayCanvas();
            const i3 = t3.debugOverlayCanvas, a3 = t3.context.gl, s3 = t3.debugOverlayCanvas.getContext("2d");
            s3.clearRect(0, 0, i3.width, i3.height), s3.shadowColor = "white", s3.shadowBlur = 2, s3.lineWidth = 1.5, s3.strokeStyle = "white", s3.textBaseline = "top", s3.font = "bold 36px Open Sans, sans-serif", s3.fillText(e2, 5, 5), s3.strokeText(e2, 5, 5), t3.debugOverlayTexture.update(i3), t3.debugOverlayTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
          }(t2, "".concat(g2, " ").concat(p2, "kB")), n2.draw(s2, o2.TRIANGLES, l3, h2, Fi2.alphaBlended, ji2.disabled, ze(r2, e.aM.transparent, f2), null, u2, t2.debugBuffer, t2.quadTriangleIndexBuffer, t2.debugSegments), n2.draw(s2, o2.LINE_STRIP, l3, h2, c2, ji2.disabled, ze(r2, e.aM.red), d2, u2, t2.debugBuffer, t2.tileBorderIndexBuffer, t2.debugSegments);
        }
        function fa2(t2, e2, i2) {
          const a2 = t2.context, s2 = a2.gl, o2 = t2.colorModeForRenderPass(), r2 = new Oi2(s2.LEQUAL, Oi2.ReadWrite, t2.depthRangeFor3D), n2 = t2.useProgram("terrain"), l3 = e2.getTerrainMesh();
          a2.bindFramebuffer.set(null), a2.viewport.set([0, 0, t2.width, t2.height]);
          for (const h2 of i2) {
            const i3 = t2.renderToTexture.getTexture(h2), c2 = e2.getTerrainData(h2.tileID);
            a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, i3.texture);
            const u2 = t2.transform.calculatePosMatrix(h2.tileID.toUnwrapped()), d2 = e2.getMeshFrameDelta(t2.transform.zoom), _2 = t2.transform.calculateFogMatrix(h2.tileID.toUnwrapped()), p2 = ge2(u2, d2, _2, t2.style.sky, t2.transform.pitch);
            n2.draw(a2, s2.TRIANGLES, r2, Ui2.disabled, o2, ji2.backCCW, p2, c2, "terrain", l3.vertexBuffer, l3.indexBuffer, l3.segments);
          }
        }
        class ga2 {
          constructor(t2, e2, i2) {
            this.vertexBuffer = t2, this.indexBuffer = e2, this.segments = i2;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        class va2 {
          constructor(t2, i2) {
            this.context = new Bi2(t2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: e.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ut2.maxUnderzooming + ut2.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new he2();
          }
          resize(t2, e2, i2) {
            if (this.width = Math.floor(t2 * i2), this.height = Math.floor(e2 * i2), this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const t3 of this.style._order) this.style._layers[t3].resize();
          }
          setup() {
            const t2 = this.context, i2 = new e.aX();
            i2.emplaceBack(0, 0), i2.emplaceBack(e.X, 0), i2.emplaceBack(0, e.X), i2.emplaceBack(e.X, e.X), this.tileExtentBuffer = t2.createVertexBuffer(i2, _e2.members), this.tileExtentSegments = e.a0.simpleSegment(0, 0, 4, 2);
            const a2 = new e.aX();
            a2.emplaceBack(0, 0), a2.emplaceBack(e.X, 0), a2.emplaceBack(0, e.X), a2.emplaceBack(e.X, e.X), this.debugBuffer = t2.createVertexBuffer(a2, _e2.members), this.debugSegments = e.a0.simpleSegment(0, 0, 4, 5);
            const s2 = new e.$();
            s2.emplaceBack(0, 0, 0, 0), s2.emplaceBack(e.X, 0, e.X, 0), s2.emplaceBack(0, e.X, 0, e.X), s2.emplaceBack(e.X, e.X, e.X, e.X), this.rasterBoundsBuffer = t2.createVertexBuffer(s2, Y.members), this.rasterBoundsSegments = e.a0.simpleSegment(0, 0, 4, 2);
            const o2 = new e.aX();
            o2.emplaceBack(0, 0), o2.emplaceBack(1, 0), o2.emplaceBack(0, 1), o2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(o2, _e2.members), this.viewportSegments = e.a0.simpleSegment(0, 0, 4, 2);
            const r2 = new e.aZ();
            r2.emplaceBack(0), r2.emplaceBack(1), r2.emplaceBack(3), r2.emplaceBack(2), r2.emplaceBack(0), this.tileBorderIndexBuffer = t2.createIndexBuffer(r2);
            const n2 = new e.aY();
            n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(n2);
            const l3 = this.context.gl;
            this.stencilClearMode = new Ui2({ func: l3.ALWAYS, mask: 0 }, 0, 255, l3.ZERO, l3.ZERO, l3.ZERO);
          }
          clearStencil() {
            const t2 = this.context, i2 = t2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const a2 = e.H();
            e.aP(a2, 0, this.width, this.height, 0, 0, 1), e.K(a2, a2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, Oi2.disabled, this.stencilClearMode, Fi2.disabled, ji2.disabled, De2(a2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t2, e2) {
            if (this.currentStencilSource === t2.source || !t2.isTileClipped() || !e2 || !e2.length) return;
            this.currentStencilSource = t2.source;
            const i2 = this.context, a2 = i2.gl;
            this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(Fi2.disabled), i2.setDepthMode(Oi2.disabled);
            const s2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t3 of e2) {
              const e3 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, o2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t3);
              s2.draw(i2, a2.TRIANGLES, Oi2.disabled, new Ui2({ func: a2.ALWAYS, mask: 0 }, e3, 255, a2.KEEP, a2.KEEP, a2.REPLACE), Fi2.disabled, ji2.disabled, De2(t3.posMatrix), o2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t2 = this.nextStencilID++, e2 = this.context.gl;
            return new Ui2({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilModeForClipping(t2) {
            const e2 = this.context.gl;
            return new Ui2({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilConfigForOverlap(t2) {
            const e2 = this.context.gl, i2 = t2.sort((t3, e3) => e3.overscaledZ - t3.overscaledZ), a2 = i2[i2.length - 1].overscaledZ, s2 = i2[0].overscaledZ - a2 + 1;
            if (s2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + s2 > 256 && this.clearStencil();
              const t3 = {};
              for (let i3 = 0; i3 < s2; i3++) t3[i3 + a2] = new Ui2({ func: e2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
              return this.nextStencilID += s2, [t3, i2];
            }
            return [{ [a2]: Ui2.disabled }, i2];
          }
          colorModeForRenderPass() {
            const t2 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i2 = 1 / 8;
              return new Fi2([t2.CONSTANT_COLOR, t2.ONE], new e.aM(i2, i2, i2, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? Fi2.unblended : Fi2.alphaBlended;
          }
          depthModeForSublayer(t2, e2, i2) {
            if (!this.opaquePassEnabledForLayer()) return Oi2.disabled;
            const a2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
            return new Oi2(i2 || this.context.gl.LEQUAL, e2, [a2, a2]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t2, i2) {
            this.style = t2, this.options = i2, this.lineAtlas = t2.lineAtlas, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(o.now()), this.imageManager.beginFrame();
            const a2 = this.style._order, s2 = this.style.sourceCaches, r2 = {}, n2 = {}, l3 = {};
            for (const t3 in s2) {
              const e2 = s2[t3];
              e2.used && e2.prepare(this.context), r2[t3] = e2.getVisibleCoordinates(), n2[t3] = r2[t3].slice().reverse(), l3[t3] = e2.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let t3 = 0; t3 < a2.length; t3++) if (this.style._layers[a2[t3]].is3D()) {
              this.opaquePassCutoff = t3;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const t3 of a2) {
              const e2 = this.style._layers[t3];
              if (!e2.hasOffscreenPass() || e2.isHidden(this.transform.zoom)) continue;
              const i3 = n2[e2.source];
              ("custom" === e2.type || i3.length) && this.renderLayer(this, s2[e2.source], e2, i3);
            }
            if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? e.aM.black : e.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(t3, i3) {
              const a3 = t3.context, s3 = a3.gl, o2 = ((t4, e2, i4) => ({ u_sky_color: t4.properties.get("sky-color"), u_horizon_color: t4.properties.get("horizon-color"), u_horizon: (e2.height / 2 + e2.getHorizon()) * i4, u_sky_horizon_blend: t4.properties.get("sky-horizon-blend") * e2.height / 2 * i4 }))(i3, t3.style.map.transform, t3.pixelRatio), r3 = new Oi2(s3.LEQUAL, Oi2.ReadWrite, [0, 1]), n3 = Ui2.disabled, l4 = t3.colorModeForRenderPass(), h2 = t3.useProgram("sky");
              if (!i3.mesh) {
                const t4 = new e.aX();
                t4.emplaceBack(-1, -1), t4.emplaceBack(1, -1), t4.emplaceBack(1, 1), t4.emplaceBack(-1, 1);
                const s4 = new e.aY();
                s4.emplaceBack(0, 1, 2), s4.emplaceBack(0, 2, 3), i3.mesh = new ga2(a3.createVertexBuffer(t4, _e2.members), a3.createIndexBuffer(s4), e.a0.simpleSegment(0, 0, t4.length, s4.length));
              }
              h2.draw(a3, s3.TRIANGLES, r3, n3, l4, ji2.disabled, o2, void 0, "sky", i3.mesh.vertexBuffer, i3.mesh.indexBuffer, i3.mesh.segments);
            }(this, this.style.sky), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = a2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const t3 = this.style._layers[a2[this.currentLayer]], e2 = s2[t3.source], i3 = r2[t3.source];
              this._renderTileClippingMasks(t3, i3), this.renderLayer(this, e2, t3, i3);
            }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < a2.length; this.currentLayer++) {
              const t3 = this.style._layers[a2[this.currentLayer]], e2 = s2[t3.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(t3)) continue;
              const i3 = ("symbol" === t3.type ? l3 : n2)[t3.source];
              this._renderTileClippingMasks(t3, r2[t3.source]), this.renderLayer(this, e2, t3, i3);
            }
            if (this.options.showTileBoundaries) {
              const t3 = function(t4, e2) {
                let i3 = null;
                const a3 = Object.values(t4._layers).flatMap((i4) => i4.source && !i4.isHidden(e2) ? [t4.sourceCaches[i4.source]] : []), s3 = a3.filter((t5) => "vector" === t5.getSource().type), o2 = a3.filter((t5) => "vector" !== t5.getSource().type), r3 = (t5) => {
                  (!i3 || i3.getSource().maxzoom < t5.getSource().maxzoom) && (i3 = t5);
                };
                return s3.forEach((t5) => r3(t5)), i3 || o2.forEach((t5) => r3(t5)), i3;
              }(this.style, this.transform.zoom);
              t3 && function(t4, e2, i3) {
                for (let a3 = 0; a3 < i3.length; a3++) ma2(t4, e2, i3[a3]);
              }(this, t3, t3.getVisibleCoordinates());
            }
            this.options.showPadding && function(t3) {
              const e2 = t3.transform.padding;
              da2(t3, t3.transform.height - (e2.top || 0), 3, na2), da2(t3, e2.bottom || 0, 3, la2), _a2(t3, e2.left || 0, 3, ha2), _a2(t3, t3.transform.width - (e2.right || 0), 3, ca2);
              const i3 = t3.transform.centerPoint;
              !function(t4, e3, i4, a3) {
                pa2(t4, e3 - 1, i4 - 10, 2, 20, a3), pa2(t4, e3 - 10, i4 - 1, 20, 2, a3);
              }(t3, i3.x, t3.transform.height - i3.y, ua2);
            }(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(t2) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const i2 = this.terrainFacilitator.matrix, a2 = this.transform.modelViewProjectionMatrix;
            let s2 = this.terrainFacilitator.dirty;
            s2 || (s2 = t2 ? !e.a_(i2, a2) : !e.a$(i2, a2)), s2 || (s2 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), s2 && (e.b0(i2, a2), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(t3, i3) {
              const a3 = t3.context, s3 = a3.gl, o2 = Fi2.unblended, r2 = new Oi2(s3.LEQUAL, Oi2.ReadWrite, [0, 1]), n2 = i3.getTerrainMesh(), l3 = i3.sourceCache.getRenderableTiles(), h2 = t3.useProgram("terrainDepth");
              a3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), a3.viewport.set([0, 0, t3.width / devicePixelRatio, t3.height / devicePixelRatio]), a3.clear({ color: e.aM.transparent, depth: 1 });
              for (const e2 of l3) {
                const l4 = i3.getTerrainData(e2.tileID), c2 = { u_matrix: t3.transform.calculatePosMatrix(e2.tileID.toUnwrapped()), u_ele_delta: i3.getMeshFrameDelta(t3.transform.zoom) };
                h2.draw(a3, s3.TRIANGLES, r2, Ui2.disabled, o2, ji2.backCCW, c2, l4, "terrain", n2.vertexBuffer, n2.indexBuffer, n2.segments);
              }
              a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, t3.width, t3.height]);
            }(this, this.style.map.terrain), function(t3, i3) {
              const a3 = t3.context, s3 = a3.gl, o2 = Fi2.unblended, r2 = new Oi2(s3.LEQUAL, Oi2.ReadWrite, [0, 1]), n2 = i3.getTerrainMesh(), l3 = i3.getCoordsTexture(), h2 = i3.sourceCache.getRenderableTiles(), c2 = t3.useProgram("terrainCoords");
              a3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), a3.viewport.set([0, 0, t3.width / devicePixelRatio, t3.height / devicePixelRatio]), a3.clear({ color: e.aM.transparent, depth: 1 }), i3.coordsIndex = [];
              for (const e2 of h2) {
                const h3 = i3.getTerrainData(e2.tileID);
                a3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_2D, l3.texture);
                const u2 = { u_matrix: t3.transform.calculatePosMatrix(e2.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i3.getMeshFrameDelta(t3.transform.zoom) };
                c2.draw(a3, s3.TRIANGLES, r2, Ui2.disabled, o2, ji2.backCCW, u2, h3, "terrain", n2.vertexBuffer, n2.indexBuffer, n2.segments), i3.coordsIndex.push(e2.tileID.key);
              }
              a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, t3.width, t3.height]);
            }(this, this.style.map.terrain));
          }
          renderLayer(t2, i2, a2, s2) {
            if (!a2.isHidden(this.transform.zoom) && ("background" === a2.type || "custom" === a2.type || (s2 || []).length)) switch (this.id = a2.id, a2.type) {
              case "symbol":
                !function(t3, i3, a3, s3, o2) {
                  if ("translucent" !== t3.renderPass) return;
                  const r2 = Ui2.disabled, n2 = t3.colorModeForRenderPass();
                  (a3._unevaluatedLayout.hasValue("text-variable-anchor") || a3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(t4, i4, a4, s4, o3, r3, n3, l3, h2) {
                    const c2 = i4.transform, u2 = ie(), d2 = "map" === o3, _2 = "map" === r3;
                    for (const o4 of t4) {
                      const t5 = s4.getTile(o4), r4 = t5.getBucket(a4);
                      if (!r4 || !r4.text || !r4.text.segments.get().length) continue;
                      const p2 = e.ag(r4.textSizeData, c2.zoom), m2 = Bt2(t5, 1, i4.transform.zoom), f2 = gt2(o4.posMatrix, _2, d2, i4.transform, m2), g2 = "none" !== a4.layout.get("icon-text-fit") && r4.hasIconData();
                      if (p2) {
                        const e2 = Math.pow(2, c2.zoom - t5.tileID.overscaledZ), a5 = i4.style.map.terrain ? (t6, e3) => i4.style.map.terrain.getElevation(o4, t6, e3) : null, s5 = u2.translatePosition(c2, t5, n3, l3);
                        Wi2(r4, d2, _2, h2, c2, f2, o4.posMatrix, e2, p2, g2, u2, s5, o4.toUnwrapped(), a5);
                      }
                    }
                  }(s3, t3, a3, i3, a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), o2), 0 !== a3.paint.get("icon-opacity").constantOr(1) && Xi2(t3, i3, a3, s3, false, a3.paint.get("icon-translate"), a3.paint.get("icon-translate-anchor"), a3.layout.get("icon-rotation-alignment"), a3.layout.get("icon-pitch-alignment"), a3.layout.get("icon-keep-upright"), r2, n2), 0 !== a3.paint.get("text-opacity").constantOr(1) && Xi2(t3, i3, a3, s3, true, a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.layout.get("text-keep-upright"), r2, n2), i3.map.showCollisionBoxes && (qi2(t3, i3, a3, s3, true), qi2(t3, i3, a3, s3, false));
                }(t2, i2, a2, s2, this.style.placement.variableOffsets);
                break;
              case "circle":
                !function(t3, i3, a3, s3) {
                  if ("translucent" !== t3.renderPass) return;
                  const o2 = a3.paint.get("circle-opacity"), r2 = a3.paint.get("circle-stroke-width"), n2 = a3.paint.get("circle-stroke-opacity"), l3 = !a3.layout.get("circle-sort-key").isConstant();
                  if (0 === o2.constantOr(1) && (0 === r2.constantOr(1) || 0 === n2.constantOr(1))) return;
                  const h2 = t3.context, c2 = h2.gl, u2 = t3.depthModeForSublayer(0, Oi2.ReadOnly), d2 = Ui2.disabled, _2 = t3.colorModeForRenderPass(), p2 = [];
                  for (let o3 = 0; o3 < s3.length; o3++) {
                    const r3 = s3[o3], n3 = i3.getTile(r3), h3 = n3.getBucket(a3);
                    if (!h3) continue;
                    const c3 = h3.programConfigurations.get(a3.id), u3 = t3.useProgram("circle", c3), d3 = h3.layoutVertexBuffer, _3 = h3.indexBuffer, m2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(r3), f2 = { programConfiguration: c3, program: u3, layoutVertexBuffer: d3, indexBuffer: _3, uniformValues: Ce2(t3, r3, n3, a3), terrainData: m2 };
                    if (l3) {
                      const t4 = h3.segments.get();
                      for (const i4 of t4) p2.push({ segments: new e.a0([i4]), sortKey: i4.sortKey, state: f2 });
                    } else p2.push({ segments: h3.segments, sortKey: 0, state: f2 });
                  }
                  l3 && p2.sort((t4, e2) => t4.sortKey - e2.sortKey);
                  for (const e2 of p2) {
                    const { programConfiguration: i4, program: s4, layoutVertexBuffer: o3, indexBuffer: r3, uniformValues: n3, terrainData: l4 } = e2.state;
                    s4.draw(h2, c2.TRIANGLES, u2, d2, _2, ji2.disabled, n3, l4, a3.id, o3, r3, e2.segments, a3.paint, t3.transform.zoom, i4);
                  }
                }(t2, i2, a2, s2);
                break;
              case "heatmap":
                !function(t3, i3, a3, s3) {
                  if (0 === a3.paint.get("heatmap-opacity")) return;
                  const o2 = t3.context;
                  if (t3.style.map.terrain) {
                    for (const e2 of s3) {
                      const s4 = i3.getTile(e2);
                      i3.hasRenderableParent(e2) || ("offscreen" === t3.renderPass ? Ji2(t3, s4, a3, e2) : "translucent" === t3.renderPass && Yi2(t3, a3, e2));
                    }
                    o2.viewport.set([0, 0, t3.width, t3.height]);
                  } else "offscreen" === t3.renderPass ? function(t4, i4, a4, s4) {
                    const o3 = t4.context, r2 = o3.gl, n2 = Ui2.disabled, l3 = new Fi2([r2.ONE, r2.ONE], e.aM.transparent, [true, true, true, true]);
                    (function(t5, i5, a5) {
                      const s5 = t5.gl;
                      t5.activeTexture.set(s5.TEXTURE1), t5.viewport.set([0, 0, i5.width / 4, i5.height / 4]);
                      let o4 = a5.heatmapFbos.get(e.aU);
                      o4 ? (s5.bindTexture(s5.TEXTURE_2D, o4.colorAttachment.get()), t5.bindFramebuffer.set(o4.framebuffer)) : (o4 = Qi2(t5, i5.width / 4, i5.height / 4), a5.heatmapFbos.set(e.aU, o4));
                    })(o3, t4, a4), o3.clear({ color: e.aM.transparent });
                    for (let e2 = 0; e2 < s4.length; e2++) {
                      const h2 = s4[e2];
                      if (i4.hasRenderableParent(h2)) continue;
                      const c2 = i4.getTile(h2), u2 = c2.getBucket(a4);
                      if (!u2) continue;
                      const d2 = u2.programConfigurations.get(a4.id), _2 = t4.useProgram("heatmap", d2), { zoom: p2 } = t4.transform;
                      _2.draw(o3, r2.TRIANGLES, Oi2.disabled, n2, l3, ji2.disabled, Me2(h2.posMatrix, c2, p2, a4.paint.get("heatmap-intensity")), null, a4.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, a4.paint, t4.transform.zoom, d2);
                    }
                    o3.viewport.set([0, 0, t4.width, t4.height]);
                  }(t3, i3, a3, s3) : "translucent" === t3.renderPass && function(t4, i4) {
                    const a4 = t4.context, s4 = a4.gl;
                    a4.setColorMode(t4.colorModeForRenderPass());
                    const o3 = i4.heatmapFbos.get(e.aU);
                    o3 && (a4.activeTexture.set(s4.TEXTURE0), s4.bindTexture(s4.TEXTURE_2D, o3.colorAttachment.get()), a4.activeTexture.set(s4.TEXTURE1), ta2(a4, i4).bind(s4.LINEAR, s4.CLAMP_TO_EDGE), t4.useProgram("heatmapTexture").draw(a4, s4.TRIANGLES, Oi2.disabled, Ui2.disabled, t4.colorModeForRenderPass(), ji2.disabled, Ae2(t4, i4, 0, 1), null, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments, i4.paint, t4.transform.zoom));
                  }(t3, a3);
                }(t2, i2, a2, s2);
                break;
              case "line":
                !function(t3, i3, a3, s3) {
                  if ("translucent" !== t3.renderPass) return;
                  const o2 = a3.paint.get("line-opacity"), r2 = a3.paint.get("line-width");
                  if (0 === o2.constantOr(1) || 0 === r2.constantOr(1)) return;
                  const n2 = t3.depthModeForSublayer(0, Oi2.ReadOnly), l3 = t3.colorModeForRenderPass(), h2 = a3.paint.get("line-dasharray"), c2 = a3.paint.get("line-pattern"), u2 = c2.constantOr(1), d2 = a3.paint.get("line-gradient"), _2 = a3.getCrossfadeParameters(), p2 = u2 ? "linePattern" : h2 ? "lineSDF" : d2 ? "lineGradient" : "line", m2 = t3.context, f2 = m2.gl;
                  let g2 = true;
                  for (const o3 of s3) {
                    const s4 = i3.getTile(o3);
                    if (u2 && !s4.patternsLoaded()) continue;
                    const r3 = s4.getBucket(a3);
                    if (!r3) continue;
                    const v2 = r3.programConfigurations.get(a3.id), x2 = t3.context.program.get(), y3 = t3.useProgram(p2, v2), w2 = g2 || y3.program !== x2, T2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(o3), I2 = c2.constantOr(null);
                    if (I2 && s4.imageAtlas) {
                      const t4 = s4.imageAtlas, e2 = t4.patternPositions[I2.to.toString()], i4 = t4.patternPositions[I2.from.toString()];
                      e2 && i4 && v2.setConstantPatternPositions(e2, i4);
                    }
                    const E2 = T2 ? o3 : null, P2 = u2 ? Fe2(t3, s4, a3, _2, E2) : h2 ? Be2(t3, s4, a3, h2, _2, E2) : d2 ? Le2(t3, s4, a3, r3.lineClipsArray.length, E2) : ke(t3, s4, a3, E2);
                    if (u2) m2.activeTexture.set(f2.TEXTURE0), s4.imageAtlasTexture.bind(f2.LINEAR, f2.CLAMP_TO_EDGE), v2.updatePaintBuffers(_2);
                    else if (h2 && (w2 || t3.lineAtlas.dirty)) m2.activeTexture.set(f2.TEXTURE0), t3.lineAtlas.bind(m2);
                    else if (d2) {
                      const s5 = r3.gradients[a3.id];
                      let n3 = s5.texture;
                      if (a3.gradientVersion !== s5.version) {
                        let l4 = 256;
                        if (a3.stepInterpolant) {
                          const a4 = i3.getSource().maxzoom, s6 = o3.canonical.z === a4 ? Math.ceil(1 << t3.transform.maxZoom - o3.canonical.z) : 1;
                          l4 = e.ac(e.aV(r3.maxLineLength / e.X * 1024 * s6), 256, m2.maxTextureSize);
                        }
                        s5.gradient = e.aW({ expression: a3.gradientExpression(), evaluationKey: "lineProgress", resolution: l4, image: s5.gradient || void 0, clips: r3.lineClipsArray }), s5.texture ? s5.texture.update(s5.gradient) : s5.texture = new b(m2, s5.gradient, f2.RGBA), s5.version = a3.gradientVersion, n3 = s5.texture;
                      }
                      m2.activeTexture.set(f2.TEXTURE0), n3.bind(a3.stepInterpolant ? f2.NEAREST : f2.LINEAR, f2.CLAMP_TO_EDGE);
                    }
                    y3.draw(m2, f2.TRIANGLES, n2, t3.stencilModeForClipping(o3), l3, ji2.disabled, P2, T2, a3.id, r3.layoutVertexBuffer, r3.indexBuffer, r3.segments, a3.paint, t3.transform.zoom, v2, r3.layoutVertexBuffer2), g2 = false;
                  }
                }(t2, i2, a2, s2);
                break;
              case "fill":
                !function(t3, i3, a3, s3) {
                  const o2 = a3.paint.get("fill-color"), r2 = a3.paint.get("fill-opacity");
                  if (0 === r2.constantOr(1)) return;
                  const n2 = t3.colorModeForRenderPass(), l3 = a3.paint.get("fill-pattern"), h2 = t3.opaquePassEnabledForLayer() && !l3.constantOr(1) && 1 === o2.constantOr(e.aM.transparent).a && 1 === r2.constantOr(0) ? "opaque" : "translucent";
                  if (t3.renderPass === h2) {
                    const e2 = t3.depthModeForSublayer(1, "opaque" === t3.renderPass ? Oi2.ReadWrite : Oi2.ReadOnly);
                    ia2(t3, i3, a3, s3, e2, n2, false);
                  }
                  if ("translucent" === t3.renderPass && a3.paint.get("fill-antialias")) {
                    const e2 = t3.depthModeForSublayer(a3.getPaintProperty("fill-outline-color") ? 2 : 0, Oi2.ReadOnly);
                    ia2(t3, i3, a3, s3, e2, n2, true);
                  }
                }(t2, i2, a2, s2);
                break;
              case "fill-extrusion":
                !function(t3, e2, i3, a3) {
                  const s3 = i3.paint.get("fill-extrusion-opacity");
                  if (0 !== s3 && "translucent" === t3.renderPass) {
                    const o2 = new Oi2(t3.context.gl.LEQUAL, Oi2.ReadWrite, t3.depthRangeFor3D);
                    if (1 !== s3 || i3.paint.get("fill-extrusion-pattern").constantOr(1)) aa2(t3, e2, i3, a3, o2, Ui2.disabled, Fi2.disabled), aa2(t3, e2, i3, a3, o2, t3.stencilModeFor3D(), t3.colorModeForRenderPass());
                    else {
                      const s4 = t3.colorModeForRenderPass();
                      aa2(t3, e2, i3, a3, o2, Ui2.disabled, s4);
                    }
                  }
                }(t2, i2, a2, s2);
                break;
              case "hillshade":
                !function(t3, e2, i3, a3) {
                  if ("offscreen" !== t3.renderPass && "translucent" !== t3.renderPass) return;
                  const s3 = t3.context, o2 = t3.depthModeForSublayer(0, Oi2.ReadOnly), r2 = t3.colorModeForRenderPass(), [n2, l3] = "translucent" === t3.renderPass ? t3.stencilConfigForOverlap(a3) : [{}, a3];
                  for (const a4 of l3) {
                    const s4 = e2.getTile(a4);
                    void 0 !== s4.needsHillshadePrepare && s4.needsHillshadePrepare && "offscreen" === t3.renderPass ? oa2(t3, s4, i3, o2, Ui2.disabled, r2) : "translucent" === t3.renderPass && sa2(t3, a4, s4, i3, o2, n2[a4.overscaledZ], r2);
                  }
                  s3.viewport.set([0, 0, t3.width, t3.height]);
                }(t2, i2, a2, s2);
                break;
              case "raster":
                !function(t3, e2, i3, a3) {
                  if ("translucent" !== t3.renderPass) return;
                  if (0 === i3.paint.get("raster-opacity")) return;
                  if (!a3.length) return;
                  const s3 = t3.context, o2 = s3.gl, r2 = e2.getSource(), n2 = t3.useProgram("raster"), l3 = t3.colorModeForRenderPass(), [h2, c2] = r2 instanceof Q2 ? [{}, a3] : t3.stencilConfigForOverlap(a3), u2 = c2[c2.length - 1].overscaledZ, d2 = !t3.options.moving;
                  for (const a4 of c2) {
                    const c3 = t3.depthModeForSublayer(a4.overscaledZ - u2, 1 === i3.paint.get("raster-opacity") ? Oi2.ReadWrite : Oi2.ReadOnly, o2.LESS), _2 = e2.getTile(a4);
                    _2.registerFadeDuration(i3.paint.get("raster-fade-duration"));
                    const p2 = e2.findLoadedParent(a4, 0), m2 = e2.findLoadedSibling(a4), f2 = ra2(_2, p2 || m2 || null, e2, i3, t3.transform, t3.style.map.terrain);
                    let g2, v2;
                    const x2 = "nearest" === i3.paint.get("raster-resampling") ? o2.NEAREST : o2.LINEAR;
                    s3.activeTexture.set(o2.TEXTURE0), _2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), s3.activeTexture.set(o2.TEXTURE1), p2 ? (p2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), g2 = Math.pow(2, p2.tileID.overscaledZ - _2.tileID.overscaledZ), v2 = [_2.tileID.canonical.x * g2 % 1, _2.tileID.canonical.y * g2 % 1]) : _2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), _2.texture.useMipmap && s3.extTextureFilterAnisotropic && t3.transform.pitch > 20 && o2.texParameterf(o2.TEXTURE_2D, s3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s3.extTextureFilterAnisotropicMax);
                    const y3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(a4), b2 = y3 ? a4 : null, w2 = b2 ? b2.posMatrix : t3.transform.calculatePosMatrix(a4.toUnwrapped(), d2), T2 = Ue2(w2, v2 || [0, 0], g2 || 1, f2, i3);
                    r2 instanceof Q2 ? n2.draw(s3, o2.TRIANGLES, c3, Ui2.disabled, l3, ji2.disabled, T2, y3, i3.id, r2.boundsBuffer, t3.quadTriangleIndexBuffer, r2.boundsSegments) : n2.draw(s3, o2.TRIANGLES, c3, h2[a4.overscaledZ], l3, ji2.disabled, T2, y3, i3.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
                  }
                }(t2, i2, a2, s2);
                break;
              case "background":
                !function(t3, e2, i3, a3) {
                  const s3 = i3.paint.get("background-color"), o2 = i3.paint.get("background-opacity");
                  if (0 === o2) return;
                  const r2 = t3.context, n2 = r2.gl, l3 = t3.transform, h2 = l3.tileSize, c2 = i3.paint.get("background-pattern");
                  if (t3.isPatternMissing(c2)) return;
                  const u2 = !c2 && 1 === s3.a && 1 === o2 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                  if (t3.renderPass !== u2) return;
                  const d2 = Ui2.disabled, _2 = t3.depthModeForSublayer(0, "opaque" === u2 ? Oi2.ReadWrite : Oi2.ReadOnly), p2 = t3.colorModeForRenderPass(), m2 = t3.useProgram(c2 ? "backgroundPattern" : "background"), f2 = a3 || l3.coveringTiles({ tileSize: h2, terrain: t3.style.map.terrain });
                  c2 && (r2.activeTexture.set(n2.TEXTURE0), t3.imageManager.bind(t3.context));
                  const g2 = i3.getCrossfadeParameters();
                  for (const e3 of f2) {
                    const l4 = a3 ? e3.posMatrix : t3.transform.calculatePosMatrix(e3.toUnwrapped()), u3 = c2 ? He2(l4, o2, t3, c2, { tileID: e3, tileSize: h2 }, g2) : Ge2(l4, o2, s3), f3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e3);
                    m2.draw(r2, n2.TRIANGLES, _2, d2, p2, ji2.disabled, u3, f3, i3.id, t3.tileExtentBuffer, t3.quadTriangleIndexBuffer, t3.tileExtentSegments);
                  }
                }(t2, 0, a2, s2);
                break;
              case "custom":
                !function(t3, e2, i3) {
                  const a3 = t3.context, s3 = i3.implementation;
                  if ("offscreen" === t3.renderPass) {
                    const e3 = s3.prerender;
                    e3 && (t3.setCustomLayerDefaults(), a3.setColorMode(t3.colorModeForRenderPass()), e3.call(s3, a3.gl, t3.transform.customLayerMatrix()), a3.setDirty(), t3.setBaseState());
                  } else if ("translucent" === t3.renderPass) {
                    t3.setCustomLayerDefaults(), a3.setColorMode(t3.colorModeForRenderPass()), a3.setStencilMode(Ui2.disabled);
                    const e3 = "3d" === s3.renderingMode ? new Oi2(t3.context.gl.LEQUAL, Oi2.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, Oi2.ReadOnly);
                    a3.setDepthMode(e3), s3.render(a3.gl, t3.transform.customLayerMatrix(), { farZ: t3.transform.farZ, nearZ: t3.transform.nearZ, fov: t3.transform._fov, modelViewProjectionMatrix: t3.transform.modelViewProjectionMatrix, projectionMatrix: t3.transform.projectionMatrix }), a3.setDirty(), t3.setBaseState(), a3.bindFramebuffer.set(null);
                  }
                }(t2, 0, a2);
            }
          }
          translatePosMatrix(t2, i2, a2, s2, o2) {
            if (!a2[0] && !a2[1]) return t2;
            const r2 = o2 ? "map" === s2 ? this.transform.angle : 0 : "viewport" === s2 ? -this.transform.angle : 0;
            if (r2) {
              const t3 = Math.sin(r2), e2 = Math.cos(r2);
              a2 = [a2[0] * e2 - a2[1] * t3, a2[0] * t3 + a2[1] * e2];
            }
            const n2 = [o2 ? a2[0] : Bt2(i2, a2[0], this.transform.zoom), o2 ? a2[1] : Bt2(i2, a2[1], this.transform.zoom), 0], l3 = new Float32Array(16);
            return e.J(l3, t2, n2), l3;
          }
          saveTileTexture(t2) {
            const e2 = this._tileTextures[t2.size[0]];
            e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
          }
          getTileTexture(t2) {
            const e2 = this._tileTextures[t2];
            return e2 && e2.length > 0 ? e2.pop() : null;
          }
          isPatternMissing(t2) {
            if (!t2) return false;
            if (!t2.from || !t2.to) return true;
            const e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
            return !e2 || !i2;
          }
          useProgram(t2, e2) {
            this.cache = this.cache || {};
            const i2 = t2 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
            return this.cache[i2] || (this.cache[i2] = new xe2(this.context, pe[t2], e2, We2[t2], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i2];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t2 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new b(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: t2, drawingBufferHeight: e2 } = this.context.gl;
            return this.width !== t2 || this.height !== e2;
          }
        }
        class xa2 {
          constructor(t2, e2) {
            this.points = t2, this.planes = e2;
          }
          static fromInvProjectionMatrix(t2, i2, a2) {
            const s2 = Math.pow(2, a2), o2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((a3) => {
              const o3 = 1 / (a3 = e.af([], a3, t2))[3] / i2 * s2;
              return e.b1(a3, a3, [o3, o3, 1 / a3[3], o3]);
            }), r2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
              const e2 = function(t4, e3) {
                var i4 = e3[0], a4 = e3[1], s4 = e3[2], o3 = i4 * i4 + a4 * a4 + s4 * s4;
                return o3 > 0 && (o3 = 1 / Math.sqrt(o3)), t4[0] = e3[0] * o3, t4[1] = e3[1] * o3, t4[2] = e3[2] * o3, t4;
              }([], function(t4, e3, i4) {
                var a4 = e3[0], s4 = e3[1], o3 = e3[2], r3 = i4[0], n2 = i4[1], l3 = i4[2];
                return t4[0] = s4 * l3 - o3 * n2, t4[1] = o3 * r3 - a4 * l3, t4[2] = a4 * n2 - s4 * r3, t4;
              }([], g([], o2[t3[0]], o2[t3[1]]), g([], o2[t3[2]], o2[t3[1]]))), i3 = -((a3 = e2)[0] * (s3 = o2[t3[1]])[0] + a3[1] * s3[1] + a3[2] * s3[2]);
              var a3, s3;
              return e2.concat(i3);
            });
            return new xa2(o2, r2);
          }
        }
        class ya2 {
          constructor(t2, e2) {
            this.min = t2, this.max = e2, this.center = function(t3, e3, i2) {
              return t3[0] = 0.5 * e3[0], t3[1] = 0.5 * e3[1], t3[2] = 0.5 * e3[2], t3;
            }([], function(t3, e3, i2) {
              return t3[0] = e3[0] + i2[0], t3[1] = e3[1] + i2[1], t3[2] = e3[2] + i2[2], t3;
            }([], this.min, this.max));
          }
          quadrant(t2) {
            const e2 = [t2 % 2 == 0, t2 < 2], i2 = m(this.min), a2 = m(this.max);
            for (let t3 = 0; t3 < e2.length; t3++) i2[t3] = e2[t3] ? this.min[t3] : this.center[t3], a2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
            return a2[2] = this.max[2], new ya2(i2, a2);
          }
          distanceX(t2) {
            return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
          }
          distanceY(t2) {
            return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
          }
          intersects(t2) {
            const i2 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
            let a2 = true;
            for (let s2 = 0; s2 < t2.planes.length; s2++) {
              const o2 = t2.planes[s2];
              let r2 = 0;
              for (let t3 = 0; t3 < i2.length; t3++) e.b2(o2, i2[t3]) >= 0 && r2++;
              if (0 === r2) return 0;
              r2 !== i2.length && (a2 = false);
            }
            if (a2) return 2;
            for (let e2 = 0; e2 < 3; e2++) {
              let i3 = Number.MAX_VALUE, a3 = -Number.MAX_VALUE;
              for (let s2 = 0; s2 < t2.points.length; s2++) {
                const o2 = t2.points[s2][e2] - this.min[e2];
                i3 = Math.min(i3, o2), a3 = Math.max(a3, o2);
              }
              if (a3 < 0 || i3 > this.max[e2] - this.min[e2]) return 0;
            }
            return 1;
          }
        }
        class ba2 {
          constructor(t2 = 0, e2 = 0, i2 = 0, a2 = 0) {
            if (isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(a2) || a2 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t2, this.bottom = e2, this.left = i2, this.right = a2;
          }
          interpolate(t2, i2, a2) {
            return null != i2.top && null != t2.top && (this.top = e.y.number(t2.top, i2.top, a2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.y.number(t2.bottom, i2.bottom, a2)), null != i2.left && null != t2.left && (this.left = e.y.number(t2.left, i2.left, a2)), null != i2.right && null != t2.right && (this.right = e.y.number(t2.right, i2.right, a2)), this;
          }
          getCenter(t2, i2) {
            const a2 = e.ac((this.left + t2 - this.right) / 2, 0, t2), s2 = e.ac((this.top + i2 - this.bottom) / 2, 0, i2);
            return new e.P(a2, s2);
          }
          equals(t2) {
            return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
          }
          clone() {
            return new ba2(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        const wa2 = 85.051129;
        class Ta2 {
          constructor(t2, i2, a2, s2, o2) {
            this.tileSize = 512, this._renderWorldCopies = void 0 === o2 || !!o2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == a2 ? 0 : a2, this._maxPitch = null == s2 ? 60 : s2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new e.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new ba2(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
          }
          clone() {
            const t2 = new Ta2(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return t2.apply(this), t2;
          }
          apply(t2) {
            this.tileSize = t2.tileSize, this.latRange = t2.latRange, this.lngRange = t2.lngRange, this.width = t2.width, this.height = t2.height, this._center = t2._center, this._elevation = t2._elevation, this.minElevationForCurrentTile = t2.minElevationForCurrentTile, this.zoom = t2.zoom, this.angle = t2.angle, this._fov = t2._fov, this._pitch = t2._pitch, this._unmodified = t2._unmodified, this._edgeInsets = t2._edgeInsets.clone(), this._calcMatrices();
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t2) {
            this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t2) {
            this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t2) {
            this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t2) {
            this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          set renderWorldCopies(t2) {
            void 0 === t2 ? t2 = true : null === t2 && (t2 = false), this._renderWorldCopies = t2;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e.P(this.width, this.height);
          }
          get bearing() {
            return -this.angle / Math.PI * 180;
          }
          set bearing(t2) {
            const i2 = -e.b3(t2, -180, 180) * Math.PI / 180;
            this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = function() {
              var t3 = new e.A(4);
              return e.A != Float32Array && (t3[1] = 0, t3[2] = 0), t3[0] = 1, t3[3] = 1, t3;
            }(), function(t3, e2, i3) {
              var a2 = e2[0], s2 = e2[1], o2 = e2[2], r2 = e2[3], n2 = Math.sin(i3), l3 = Math.cos(i3);
              t3[0] = a2 * l3 + o2 * n2, t3[1] = s2 * l3 + r2 * n2, t3[2] = a2 * -n2 + o2 * l3, t3[3] = s2 * -n2 + r2 * l3;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t2) {
            const i2 = e.ac(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(t2) {
            t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t2) {
            const e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
            this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.tileZoom = Math.max(0, Math.floor(e2)), this.scale = this.zoomScale(e2), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          set center(t2) {
            t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(t2) {
            t2 !== this._elevation && (this._elevation = t2, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t2) {
            this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          isPaddingEqual(t2) {
            return this._edgeInsets.equals(t2);
          }
          interpolatePadding(t2, e2, i2) {
            this._unmodified = false, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t2) {
            const e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
            return Math.max(0, e2);
          }
          getVisibleUnwrappedCoordinates(t2) {
            const i2 = [new e.b4(0, t2)];
            if (this._renderWorldCopies) {
              const a2 = this.pointCoordinate(new e.P(0, 0)), s2 = this.pointCoordinate(new e.P(this.width, 0)), o2 = this.pointCoordinate(new e.P(this.width, this.height)), r2 = this.pointCoordinate(new e.P(0, this.height)), n2 = Math.floor(Math.min(a2.x, s2.x, o2.x, r2.x)), l3 = Math.floor(Math.max(a2.x, s2.x, o2.x, r2.x)), h2 = 1;
              for (let a3 = n2 - h2; a3 <= l3 + h2; a3++) 0 !== a3 && i2.push(new e.b4(a3, t2));
            }
            return i2;
          }
          coveringTiles(t2) {
            var i2, a2;
            let s2 = this.coveringZoomLevel(t2);
            const o2 = s2;
            if (void 0 !== t2.minzoom && s2 < t2.minzoom) return [];
            void 0 !== t2.maxzoom && s2 > t2.maxzoom && (s2 = t2.maxzoom);
            const r2 = this.pointCoordinate(this.getCameraPoint()), n2 = e.Z.fromLngLat(this.center), l3 = Math.pow(2, s2), h2 = [l3 * r2.x, l3 * r2.y, 0], c2 = [l3 * n2.x, l3 * n2.y, 0], u2 = xa2.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, s2);
            let d2 = t2.minzoom || 0;
            !t2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d2 = s2);
            const _2 = t2.terrain ? 2 / Math.min(this.tileSize, t2.tileSize) * this.tileSize : 3, p2 = (t3) => ({ aabb: new ya2([t3 * l3, 0, 0], [(t3 + 1) * l3, l3, 0]), zoom: 0, x: 0, y: 0, wrap: t3, fullyVisible: false }), m2 = [], f2 = [], g2 = s2, x2 = t2.reparseOverscaled ? o2 : s2;
            if (this._renderWorldCopies) for (let t3 = 1; t3 <= 3; t3++) m2.push(p2(-t3)), m2.push(p2(t3));
            for (m2.push(p2(0)); m2.length > 0; ) {
              const s3 = m2.pop(), o3 = s3.x, r3 = s3.y;
              let n3 = s3.fullyVisible;
              if (!n3) {
                const t3 = s3.aabb.intersects(u2);
                if (0 === t3) continue;
                n3 = 2 === t3;
              }
              const l4 = t2.terrain ? h2 : c2, p3 = s3.aabb.distanceX(l4), y3 = s3.aabb.distanceY(l4), b2 = Math.max(Math.abs(p3), Math.abs(y3));
              if (s3.zoom === g2 || b2 > _2 + (1 << g2 - s3.zoom) - 2 && s3.zoom >= d2) {
                const t3 = g2 - s3.zoom, i3 = h2[0] - 0.5 - (o3 << t3), a3 = h2[1] - 0.5 - (r3 << t3);
                f2.push({ tileID: new e.S(s3.zoom === g2 ? x2 : s3.zoom, s3.wrap, s3.zoom, o3, r3), distanceSq: v([c2[0] - 0.5 - o3, c2[1] - 0.5 - r3]), tileDistanceToCamera: Math.sqrt(i3 * i3 + a3 * a3) });
              } else for (let l5 = 0; l5 < 4; l5++) {
                const h3 = (o3 << 1) + l5 % 2, c3 = (r3 << 1) + (l5 >> 1), u3 = s3.zoom + 1;
                let d3 = s3.aabb.quadrant(l5);
                if (t2.terrain) {
                  const o4 = new e.S(u3, s3.wrap, u3, h3, c3), r4 = t2.terrain.getMinMaxElevation(o4), n4 = null !== (i2 = r4.minElevation) && void 0 !== i2 ? i2 : this.elevation, l6 = null !== (a2 = r4.maxElevation) && void 0 !== a2 ? a2 : this.elevation;
                  d3 = new ya2([d3.min[0], d3.min[1], n4], [d3.max[0], d3.max[1], l6]);
                }
                m2.push({ aabb: d3, zoom: u3, x: h3, y: c3, wrap: s3.wrap, fullyVisible: n3 });
              }
            }
            return f2.sort((t3, e2) => t3.distanceSq - e2.distanceSq).map((t3) => t3.tileID);
          }
          resize(t2, e2) {
            this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t2) {
            return Math.pow(2, t2);
          }
          scaleZoom(t2) {
            return Math.log(t2) / Math.LN2;
          }
          project(t2) {
            const i2 = e.ac(t2.lat, -85.051129, wa2);
            return new e.P(e.O(t2.lng) * this.worldSize, e.Q(i2) * this.worldSize);
          }
          unproject(t2) {
            return new e.Z(t2.x / this.worldSize, t2.y / this.worldSize).toLngLat();
          }
          get point() {
            return this.project(this.center);
          }
          getCameraPosition() {
            return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
          }
          recalculateZoom(t2) {
            const i2 = this.elevation, a2 = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, s2 = this.pointLocation(this.centerPoint, t2), o2 = t2.getElevationForLngLatZoom(s2, this.tileZoom);
            if (!(this.elevation - o2)) return;
            const r2 = a2 + i2 - o2, n2 = Math.cos(this._pitch) * this.cameraToCenterDistance / r2 / e.b5(1, s2.lat), l3 = this.scaleZoom(n2 / this.tileSize);
            this._elevation = o2, this._center = s2, this.zoom = l3;
          }
          setLocationAtPoint(t2, i2) {
            const a2 = this.pointCoordinate(i2), s2 = this.pointCoordinate(this.centerPoint), o2 = this.locationCoordinate(t2), r2 = new e.Z(o2.x - (a2.x - s2.x), o2.y - (a2.y - s2.y));
            this.center = this.coordinateLocation(r2), this._renderWorldCopies && (this.center = this.center.wrap());
          }
          locationPoint(t2, e2) {
            return e2 ? this.coordinatePoint(this.locationCoordinate(t2), e2.getElevationForLngLatZoom(t2, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t2));
          }
          pointLocation(t2, e2) {
            return this.coordinateLocation(this.pointCoordinate(t2, e2));
          }
          locationCoordinate(t2) {
            return e.Z.fromLngLat(t2);
          }
          coordinateLocation(t2) {
            return t2 && t2.toLngLat();
          }
          pointCoordinate(t2, i2) {
            if (i2) {
              const e2 = i2.pointCoordinate(t2);
              if (null != e2) return e2;
            }
            const a2 = [t2.x, t2.y, 0, 1], s2 = [t2.x, t2.y, 1, 1];
            e.af(a2, a2, this.pixelMatrixInverse), e.af(s2, s2, this.pixelMatrixInverse);
            const o2 = a2[3], r2 = s2[3], n2 = a2[1] / o2, l3 = s2[1] / r2, h2 = a2[2] / o2, c2 = s2[2] / r2, u2 = h2 === c2 ? 0 : (0 - h2) / (c2 - h2);
            return new e.Z(e.y.number(a2[0] / o2, s2[0] / r2, u2) / this.worldSize, e.y.number(n2, l3, u2) / this.worldSize);
          }
          coordinatePoint(t2, i2 = 0, a2 = this.pixelMatrix) {
            const s2 = [t2.x * this.worldSize, t2.y * this.worldSize, i2, 1];
            return e.af(s2, s2, a2), new e.P(s2[0] / s2[3], s2[1] / s2[3]);
          }
          getBounds() {
            const t2 = Math.max(0, this.height / 2 - this.getHorizon());
            return new H().extend(this.pointLocation(new e.P(0, t2))).extend(this.pointLocation(new e.P(this.width, t2))).extend(this.pointLocation(new e.P(this.width, this.height))).extend(this.pointLocation(new e.P(0, this.height)));
          }
          getMaxBounds() {
            return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new H([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }
          getHorizon() {
            return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
          }
          setMaxBounds(t2) {
            t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, wa2]);
          }
          calculateTileMatrix(t2) {
            const i2 = t2.canonical, a2 = this.worldSize / this.zoomScale(i2.z), s2 = i2.x + Math.pow(2, i2.z) * t2.wrap, o2 = e.an(new Float64Array(16));
            return e.J(o2, o2, [s2 * a2, i2.y * a2, 0]), e.K(o2, o2, [a2 / e.X, a2 / e.X, 1]), o2;
          }
          calculatePosMatrix(t2, i2 = false) {
            const a2 = t2.key, s2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (s2[a2]) return s2[a2];
            const o2 = this.calculateTileMatrix(t2);
            return e.L(o2, i2 ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, o2), s2[a2] = new Float32Array(o2), s2[a2];
          }
          calculateFogMatrix(t2) {
            const i2 = t2.key, a2 = this._fogMatrixCache;
            if (a2[i2]) return a2[i2];
            const s2 = this.calculateTileMatrix(t2);
            return e.L(s2, this.fogMatrix, s2), a2[i2] = new Float32Array(s2), a2[i2];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          getConstrained(t2, i2) {
            i2 = e.ac(+i2, this.minZoom, this.maxZoom);
            const a2 = { center: new e.N(t2.lng, t2.lat), zoom: i2 };
            let s2 = this.lngRange;
            if (!this._renderWorldCopies && null === s2) {
              const t3 = 180 - 1e-10;
              s2 = [-t3, t3];
            }
            const o2 = this.tileSize * this.zoomScale(a2.zoom);
            let r2 = 0, n2 = o2, l3 = 0, h2 = o2, c2 = 0, u2 = 0;
            const { x: d2, y: _2 } = this.size;
            if (this.latRange) {
              const t3 = this.latRange;
              r2 = e.Q(t3[1]) * o2, n2 = e.Q(t3[0]) * o2, n2 - r2 < _2 && (c2 = _2 / (n2 - r2));
            }
            s2 && (l3 = e.b3(e.O(s2[0]) * o2, 0, o2), h2 = e.b3(e.O(s2[1]) * o2, 0, o2), h2 < l3 && (h2 += o2), h2 - l3 < d2 && (u2 = d2 / (h2 - l3)));
            const { x: p2, y: m2 } = this.project.call({ worldSize: o2 }, t2);
            let f2, g2;
            const v2 = Math.max(u2 || 0, c2 || 0);
            if (v2) {
              const t3 = new e.P(u2 ? (h2 + l3) / 2 : p2, c2 ? (n2 + r2) / 2 : m2);
              return a2.center = this.unproject.call({ worldSize: o2 }, t3).wrap(), a2.zoom += this.scaleZoom(v2), a2;
            }
            if (this.latRange) {
              const t3 = _2 / 2;
              m2 - t3 < r2 && (g2 = r2 + t3), m2 + t3 > n2 && (g2 = n2 - t3);
            }
            if (s2) {
              const t3 = (l3 + h2) / 2;
              let i3 = p2;
              this._renderWorldCopies && (i3 = e.b3(p2, t3 - o2 / 2, t3 + o2 / 2));
              const a3 = d2 / 2;
              i3 - a3 < l3 && (f2 = l3 + a3), i3 + a3 > h2 && (f2 = h2 - a3);
            }
            if (void 0 !== f2 || void 0 !== g2) {
              const t3 = new e.P(null != f2 ? f2 : p2, null != g2 ? g2 : m2);
              a2.center = this.unproject.call({ worldSize: o2 }, t3).wrap();
            }
            return a2;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining) return;
            this._constraining = true;
            const t2 = this._unmodified, { center: e2, zoom: i2 } = this.getConstrained(this.center, this.zoom);
            this.center = e2, this.zoom = i2, this._unmodified = t2, this._constraining = false;
          }
          _calcMatrices() {
            if (!this.height) return;
            const t2 = this.centerOffset, i2 = this.point.x, a2 = this.point.y;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = e.b5(1, this.center.lat) * this.worldSize;
            let s2 = e.an(new Float64Array(16));
            e.K(s2, s2, [this.width / 2, -this.height / 2, 1]), e.J(s2, s2, [1, -1, 0]), this.labelPlaneMatrix = s2, s2 = e.an(new Float64Array(16)), e.K(s2, s2, [1, -1, 1]), e.J(s2, s2, [-1, -1, 0]), e.K(s2, s2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = s2;
            const o2 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r2 = Math.min(this.elevation, this.minElevationForCurrentTile), n2 = o2 - r2 * this._pixelPerMeter / Math.cos(this._pitch), l3 = r2 < 0 ? n2 : o2, h2 = Math.PI / 2 + this._pitch, c2 = this._fov * (0.5 + t2.y / this.height), u2 = Math.sin(c2) * l3 / Math.sin(e.ac(Math.PI - h2 - c2, 0.01, Math.PI - 0.01)), d2 = this.getHorizon(), _2 = 2 * Math.atan(d2 / this.cameraToCenterDistance) * (0.5 + t2.y / (2 * d2)), p2 = Math.sin(_2) * l3 / Math.sin(e.ac(Math.PI - h2 - _2, 0.01, Math.PI - 0.01)), m2 = Math.min(u2, p2);
            this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * m2 + l3), this.nearZ = this.height / 50, s2 = new Float64Array(16), e.b6(s2, this._fov, this.width / this.height, this.nearZ, this.farZ), s2[8] = 2 * -t2.x / this.width, s2[9] = 2 * t2.y / this.height, this.projectionMatrix = e.ae(s2), e.K(s2, s2, [1, -1, 1]), e.J(s2, s2, [0, 0, -this.cameraToCenterDistance]), e.b7(s2, s2, this._pitch), e.ad(s2, s2, this.angle), e.J(s2, s2, [-i2, -a2, 0]), this.mercatorMatrix = e.K([], s2, [this.worldSize, this.worldSize, this.worldSize]), e.K(s2, s2, [1, 1, this._pixelPerMeter]), this.pixelMatrix = e.L(new Float64Array(16), this.labelPlaneMatrix, s2), e.J(s2, s2, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = s2, this.invModelViewProjectionMatrix = e.as([], s2), this.fogMatrix = new Float64Array(16), e.b6(this.fogMatrix, this._fov, this.width / this.height, o2, this.farZ), this.fogMatrix[8] = 2 * -t2.x / this.width, this.fogMatrix[9] = 2 * t2.y / this.height, e.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), e.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), e.b7(this.fogMatrix, this.fogMatrix, this._pitch), e.ad(this.fogMatrix, this.fogMatrix, this.angle), e.J(this.fogMatrix, this.fogMatrix, [-i2, -a2, 0]), e.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), e.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = e.L(new Float64Array(16), this.labelPlaneMatrix, s2);
            const f2 = this.width % 2 / 2, g2 = this.height % 2 / 2, v2 = Math.cos(this.angle), x2 = Math.sin(this.angle), y3 = i2 - Math.round(i2) + v2 * f2 + x2 * g2, b2 = a2 - Math.round(a2) + v2 * g2 + x2 * f2, w2 = new Float64Array(s2);
            if (e.J(w2, w2, [y3 > 0.5 ? y3 - 1 : y3, b2 > 0.5 ? b2 - 1 : b2, 0]), this.alignedModelViewProjectionMatrix = w2, s2 = e.as(new Float64Array(16), this.pixelMatrix), !s2) throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = s2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
          }
          maxPitchScaleFactor() {
            if (!this.pixelMatrixInverse) return 1;
            const t2 = this.pointCoordinate(new e.P(0, 0)), i2 = [t2.x * this.worldSize, t2.y * this.worldSize, 0, 1];
            return e.af(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
          }
          getCameraPoint() {
            const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e.P(0, t2));
          }
          getCameraQueryGeometry(t2) {
            const i2 = this.getCameraPoint();
            if (1 === t2.length) return [t2[0], i2];
            {
              let a2 = i2.x, s2 = i2.y, o2 = i2.x, r2 = i2.y;
              for (const e2 of t2) a2 = Math.min(a2, e2.x), s2 = Math.min(s2, e2.y), o2 = Math.max(o2, e2.x), r2 = Math.max(r2, e2.y);
              return [new e.P(a2, s2), new e.P(o2, s2), new e.P(o2, r2), new e.P(a2, r2), new e.P(a2, s2)];
            }
          }
          lngLatToCameraDepth(t2, i2) {
            const a2 = this.locationCoordinate(t2), s2 = [a2.x * this.worldSize, a2.y * this.worldSize, i2, 1];
            return e.af(s2, s2, this.modelViewProjectionMatrix), s2[2] / s2[3];
          }
        }
        function Ia2(t2, e2) {
          let i2, a2 = false, s2 = null, o2 = null;
          const r2 = () => {
            s2 = null, a2 && (t2.apply(o2, i2), s2 = setTimeout(r2, e2), a2 = false);
          };
          return (...t3) => (a2 = true, o2 = this, i2 = t3, s2 || r2(), s2);
        }
        class Ea2 {
          constructor(t2) {
            this._getCurrentHash = () => {
              const t3 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let e2;
                return t3.split("&").map((t4) => t4.split("=")).forEach((t4) => {
                  t4[0] === this._hashName && (e2 = t4);
                }), (e2 && e2[1] || "").split("/");
              }
              return t3.split("/");
            }, this._onHashChange = () => {
              const t3 = this._getCurrentHash();
              if (t3.length >= 3 && !t3.some((t4) => isNaN(t4))) {
                const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t3[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+t3[2], +t3[1]], zoom: +t3[0], bearing: e2, pitch: +(t3[4] || 0) }), true;
              }
              return false;
            }, this._updateHashUnthrottled = () => {
              const t3 = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, t3);
            }, this._removeHash = () => {
              const t3 = this._getCurrentHash();
              if (0 === t3.length) return;
              const e2 = t3.join("/");
              let i2 = e2;
              i2.split("&").length > 0 && (i2 = i2.split("&")[0]), this._hashName && (i2 = "".concat(this._hashName, "=").concat(e2));
              let a2 = window.location.hash.replace(i2, "");
              a2.startsWith("#&") ? a2 = a2.slice(0, 1) + a2.slice(2) : "#" === a2 && (a2 = "");
              let s2 = window.location.href.replace(/(#.+)?$/, a2);
              s2 = s2.replace("&&", "&"), window.history.replaceState(window.history.state, null, s2);
            }, this._updateHash = Ia2(this._updateHashUnthrottled, 300), this._hashName = t2 && encodeURIComponent(t2);
          }
          addTo(t2) {
            return this._map = t2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(t2) {
            const e2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, a2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), s2 = Math.pow(10, a2), o2 = Math.round(e2.lng * s2) / s2, r2 = Math.round(e2.lat * s2) / s2, n2 = this._map.getBearing(), l3 = this._map.getPitch();
            let h2 = "";
            if (h2 += t2 ? "/".concat(o2, "/").concat(r2, "/").concat(i2) : "".concat(i2, "/").concat(r2, "/").concat(o2), (n2 || l3) && (h2 += "/" + Math.round(10 * n2) / 10), l3 && (h2 += "/".concat(Math.round(l3))), this._hashName) {
              const t3 = this._hashName;
              let e3 = false;
              const i3 = window.location.hash.slice(1).split("&").map((i4) => {
                const a3 = i4.split("=")[0];
                return a3 === t3 ? (e3 = true, "".concat(a3, "=").concat(h2)) : i4;
              }).filter((t4) => t4);
              return e3 || i3.push("".concat(t3, "=").concat(h2)), "#".concat(i3.join("&"));
            }
            return "#".concat(h2);
          }
        }
        const Pa2 = { linearity: 0.3, easing: e.b8(0, 0, 0.3, 1) }, Ca2 = e.e({ deceleration: 2500, maxSpeed: 1400 }, Pa2), Sa2 = e.e({ deceleration: 20, maxSpeed: 1400 }, Pa2), za2 = e.e({ deceleration: 1e3, maxSpeed: 360 }, Pa2), Da2 = e.e({ deceleration: 1e3, maxSpeed: 90 }, Pa2);
        class Ma2 {
          constructor(t2) {
            this._map = t2, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o.now(), settings: t2 });
          }
          _drainInertiaBuffer() {
            const t2 = this._inertiaBuffer, e2 = o.now();
            for (; t2.length > 0 && e2 - t2[0].time > 160; ) t2.shift();
          }
          _onMoveEnd(t2) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: t3 } of this._inertiaBuffer) i2.zoom += t3.zoomDelta || 0, i2.bearing += t3.bearingDelta || 0, i2.pitch += t3.pitchDelta || 0, t3.panDelta && i2.pan._add(t3.panDelta), t3.around && (i2.around = t3.around), t3.pinchAround && (i2.pinchAround = t3.pinchAround);
            const a2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
            if (i2.pan.mag()) {
              const o2 = Ra2(i2.pan.mag(), a2, e.e({}, Ca2, t2 || {}));
              s2.offset = i2.pan.mult(o2.amount / i2.pan.mag()), s2.center = this._map.transform.center, Aa2(s2, o2);
            }
            if (i2.zoom) {
              const t3 = Ra2(i2.zoom, a2, Sa2);
              s2.zoom = this._map.transform.zoom + t3.amount, Aa2(s2, t3);
            }
            if (i2.bearing) {
              const t3 = Ra2(i2.bearing, a2, za2);
              s2.bearing = this._map.transform.bearing + e.ac(t3.amount, -179, 179), Aa2(s2, t3);
            }
            if (i2.pitch) {
              const t3 = Ra2(i2.pitch, a2, Da2);
              s2.pitch = this._map.transform.pitch + t3.amount, Aa2(s2, t3);
            }
            if (s2.zoom || s2.bearing) {
              const t3 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
              s2.around = t3 ? this._map.unproject(t3) : this._map.getCenter();
            }
            return this.clear(), e.e(s2, { noMoveStart: true });
          }
        }
        function Aa2(t2, e2) {
          (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
        }
        function Ra2(t2, i2, a2) {
          const { maxSpeed: s2, linearity: o2, deceleration: r2 } = a2, n2 = e.ac(t2 * o2 / (i2 / 1e3), -s2, s2), l3 = Math.abs(n2) / (r2 * o2);
          return { easing: a2.easing, duration: 1e3 * l3, amount: n2 * (l3 / 2) };
        }
        class ka2 extends e.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, a2, s2 = {}) {
            const o2 = r.mousePos(i2.getCanvas(), a2), n2 = i2.unproject(o2);
            super(t2, e.e({ point: o2, lngLat: n2, originalEvent: a2 }, s2)), this._defaultPrevented = false, this.target = i2;
          }
        }
        class La2 extends e.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, a2) {
            const s2 = "touchend" === t2 ? a2.changedTouches : a2.touches, o2 = r.touchPos(i2.getCanvasContainer(), s2), n2 = o2.map((t3) => i2.unproject(t3)), l3 = o2.reduce((t3, e2, i3, a3) => t3.add(e2.div(a3.length)), new e.P(0, 0));
            super(t2, { points: o2, point: l3, lngLats: n2, lngLat: i2.unproject(l3), originalEvent: a2 }), this._defaultPrevented = false;
          }
        }
        class Fa2 extends e.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, e2, i2) {
            super(t2, { originalEvent: i2 }), this._defaultPrevented = false;
          }
        }
        class Ba2 {
          constructor(t2, e2) {
            this._map = t2, this._clickTolerance = e2.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t2) {
            return this._firePreventable(new Fa2(t2.type, this._map, t2));
          }
          mousedown(t2, e2) {
            return this._mousedownPos = e2, this._firePreventable(new ka2(t2.type, this._map, t2));
          }
          mouseup(t2) {
            this._map.fire(new ka2(t2.type, this._map, t2));
          }
          click(t2, e2) {
            this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new ka2(t2.type, this._map, t2));
          }
          dblclick(t2) {
            return this._firePreventable(new ka2(t2.type, this._map, t2));
          }
          mouseover(t2) {
            this._map.fire(new ka2(t2.type, this._map, t2));
          }
          mouseout(t2) {
            this._map.fire(new ka2(t2.type, this._map, t2));
          }
          touchstart(t2) {
            return this._firePreventable(new La2(t2.type, this._map, t2));
          }
          touchmove(t2) {
            this._map.fire(new La2(t2.type, this._map, t2));
          }
          touchend(t2) {
            this._map.fire(new La2(t2.type, this._map, t2));
          }
          touchcancel(t2) {
            this._map.fire(new La2(t2.type, this._map, t2));
          }
          _firePreventable(t2) {
            if (this._map.fire(t2), t2.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Oa2 {
          constructor(t2) {
            this._map = t2;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(t2) {
            this._map.fire(new ka2(t2.type, this._map, t2));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ka2("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t2) {
            this._delayContextMenu ? this._contextMenuEvent = t2 : this._ignoreContextMenu || this._map.fire(new ka2(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Na2 {
          constructor(t2) {
            this._map = t2;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(t2) {
            return this.transform.pointLocation(e.P.convert(t2), this._map.terrain);
          }
        }
        class Ua2 {
          constructor(t2, e2) {
            this._map = t2, this._tr = new Na2(t2), this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(t2, e2) {
            this.isEnabled() && t2.shiftKey && 0 === t2.button && (r.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
          }
          mousemoveWindow(t2, e2) {
            if (!this._active) return;
            const i2 = e2;
            if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance) return;
            const a2 = this._startPos;
            this._lastPos = i2, this._box || (this._box = r.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t2));
            const s2 = Math.min(a2.x, i2.x), o2 = Math.max(a2.x, i2.x), n2 = Math.min(a2.y, i2.y), l3 = Math.max(a2.y, i2.y);
            r.setTransform(this._box, "translate(".concat(s2, "px,").concat(n2, "px)")), this._box.style.width = o2 - s2 + "px", this._box.style.height = l3 - n2 + "px";
          }
          mouseupWindow(t2, i2) {
            if (!this._active) return;
            if (0 !== t2.button) return;
            const a2 = this._startPos, s2 = i2;
            if (this.reset(), r.suppressClick(), a2.x !== s2.x || a2.y !== s2.y) return this._map.fire(new e.k("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (t3) => t3.fitScreenCoordinates(a2, s2, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", t2);
          }
          keydown(t2) {
            this._active && 27 === t2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t2));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (r.remove(this._box), this._box = null), r.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t2, i2) {
            return this._map.fire(new e.k(t2, { originalEvent: i2 }));
          }
        }
        function ja2(t2, e2) {
          if (t2.length !== e2.length) throw new Error("The number of touches and points are not equal - touches ".concat(t2.length, ", points ").concat(e2.length));
          const i2 = {};
          for (let a2 = 0; a2 < t2.length; a2++) i2[t2[a2].identifier] = e2[a2];
          return i2;
        }
        class Za2 {
          constructor(t2) {
            this.reset(), this.numTouches = t2.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(t2, i2, a2) {
            (this.centroid || a2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = t2.timeStamp), a2.length === this.numTouches && (this.centroid = function(t3) {
              const i3 = new e.P(0, 0);
              for (const e2 of t3) i3._add(e2);
              return i3.div(t3.length);
            }(i2), this.touches = ja2(a2, i2)));
          }
          touchmove(t2, e2, i2) {
            if (this.aborted || !this.centroid) return;
            const a2 = ja2(i2, e2);
            for (const t3 in this.touches) {
              const e3 = a2[t3];
              (!e3 || e3.dist(this.touches[t3]) > 30) && (this.aborted = true);
            }
          }
          touchend(t2, e2, i2) {
            if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
              const t3 = !this.aborted && this.centroid;
              if (this.reset(), t3) return t3;
            }
          }
        }
        class qa2 {
          constructor(t2) {
            this.singleTap = new Za2(t2), this.numTaps = t2.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t2, e2, i2) {
            this.singleTap.touchstart(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            this.singleTap.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            const a2 = this.singleTap.touchend(t2, e2, i2);
            if (a2) {
              const e3 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(a2) < 30;
              if (e3 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = a2, this.count === this.numTaps) return this.reset(), a2;
            }
          }
        }
        class Va2 {
          constructor(t2) {
            this._tr = new Na2(t2), this._zoomIn = new qa2({ numTouches: 1, numTaps: 2 }), this._zoomOut = new qa2({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t2, e2, i2) {
            this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            const a2 = this._zoomIn.touchend(t2, e2, i2), s2 = this._zoomOut.touchend(t2, e2, i2), o2 = this._tr;
            return a2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom + 1, around: o2.unproject(a2) }, { originalEvent: t2 }) }) : s2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom - 1, around: o2.unproject(s2) }, { originalEvent: t2 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ga2 {
          constructor(t2) {
            this._enabled = !!t2.enable, this._moveStateManager = t2.moveStateManager, this._clickTolerance = t2.clickTolerance || 1, this._moveFunction = t2.move, this._activateOnStart = !!t2.activateOnStart, t2.assignEvents(this), this.reset();
          }
          reset(t2) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t2);
          }
          _move(...t2) {
            const e2 = this._moveFunction(...t2);
            if (e2.bearingDelta || e2.pitchDelta || e2.around || e2.panDelta) return this._active = true, e2;
          }
          dragStart(t2, e2) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t2) && (this._moveStateManager.startMove(t2), this._lastPoint = e2.length ? e2[0] : e2, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(t2, e2) {
            if (!this.isEnabled()) return;
            const i2 = this._lastPoint;
            if (!i2) return;
            if (t2.preventDefault(), !this._moveStateManager.isValidMoveEvent(t2)) return void this.reset(t2);
            const a2 = e2.length ? e2[0] : e2;
            return !this._moved && a2.dist(i2) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = a2, this._move(i2, a2));
          }
          dragEnd(t2) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t2) && (this._moved && r.suppressClick(), this.reset(t2));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Ha2 = { 0: 1, 2: 2 };
        class Wa2 {
          constructor(t2) {
            this._correctEvent = t2.checkCorrectEvent;
          }
          startMove(t2) {
            const e2 = r.mouseButton(t2);
            this._eventButton = e2;
          }
          endMove(t2) {
            delete this._eventButton;
          }
          isValidStartEvent(t2) {
            return this._correctEvent(t2);
          }
          isValidMoveEvent(t2) {
            return !function(t3, e2) {
              const i2 = Ha2[e2];
              return void 0 === t3.buttons || (t3.buttons & i2) !== i2;
            }(t2, this._eventButton);
          }
          isValidEndEvent(t2) {
            return r.mouseButton(t2) === this._eventButton;
          }
        }
        class $a2 {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t2) {
            return 1 === t2.targetTouches.length;
          }
          _isSameTouchEvent(t2) {
            return t2.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t2) {
            this._firstTouch = t2.targetTouches[0].identifier;
          }
          endMove(t2) {
            delete this._firstTouch;
          }
          isValidStartEvent(t2) {
            return this._isOneFingerTouch(t2);
          }
          isValidMoveEvent(t2) {
            return this._isOneFingerTouch(t2) && this._isSameTouchEvent(t2);
          }
          isValidEndEvent(t2) {
            return this._isOneFingerTouch(t2) && this._isSameTouchEvent(t2);
          }
        }
        const Xa2 = (t2) => {
          t2.mousedown = t2.dragStart, t2.mousemoveWindow = t2.dragMove, t2.mouseup = t2.dragEnd, t2.contextmenu = (t3) => {
            t3.preventDefault();
          };
        }, Ka2 = ({ enable: t2, clickTolerance: e2, bearingDegreesPerPixelMoved: i2 = 0.8 }) => {
          const a2 = new Wa2({ checkCorrectEvent: (t3) => 0 === r.mouseButton(t3) && t3.ctrlKey || 2 === r.mouseButton(t3) });
          return new Ga2({ clickTolerance: e2, move: (t3, e3) => ({ bearingDelta: (e3.x - t3.x) * i2 }), moveStateManager: a2, enable: t2, assignEvents: Xa2 });
        }, Ja2 = ({ enable: t2, clickTolerance: e2, pitchDegreesPerPixelMoved: i2 = -0.5 }) => {
          const a2 = new Wa2({ checkCorrectEvent: (t3) => 0 === r.mouseButton(t3) && t3.ctrlKey || 2 === r.mouseButton(t3) });
          return new Ga2({ clickTolerance: e2, move: (t3, e3) => ({ pitchDelta: (e3.y - t3.y) * i2 }), moveStateManager: a2, enable: t2, assignEvents: Xa2 });
        };
        class Ya2 {
          constructor(t2, e2) {
            this._clickTolerance = t2.clickTolerance || 1, this._map = e2, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e.P(0, 0);
          }
          _shouldBePrevented(t2) {
            return t2 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(t2, e2, i2) {
            return this._calculateTransform(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            if (this._active) {
              if (!this._shouldBePrevented(i2.length)) return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t2);
            }
          }
          touchend(t2, e2, i2) {
            this._calculateTransform(t2, e2, i2), this._active && this._shouldBePrevented(i2.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t2, i2, a2) {
            a2.length > 0 && (this._active = true);
            const s2 = ja2(a2, i2), o2 = new e.P(0, 0), r2 = new e.P(0, 0);
            let n2 = 0;
            for (const t3 in s2) {
              const e2 = s2[t3], i3 = this._touches[t3];
              i3 && (o2._add(e2), r2._add(e2.sub(i3)), n2++, s2[t3] = e2);
            }
            if (this._touches = s2, this._shouldBePrevented(n2) || !r2.mag()) return;
            const l3 = r2.div(n2);
            return this._sum._add(l3), this._sum.mag() < this._clickTolerance ? void 0 : { around: o2.div(n2), panDelta: l3 };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Qa2 {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(t2, e2, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
          }
          touchmove(t2, e2, i2) {
            if (!this._firstTwoTouches) return;
            t2.preventDefault();
            const [a2, s2] = this._firstTwoTouches, o2 = ts2(i2, e2, a2), r2 = ts2(i2, e2, s2);
            if (!o2 || !r2) return;
            const n2 = this._aroundCenter ? null : o2.add(r2).div(2);
            return this._move([o2, r2], n2, t2);
          }
          touchend(t2, e2, i2) {
            if (!this._firstTwoTouches) return;
            const [a2, s2] = this._firstTwoTouches, o2 = ts2(i2, e2, a2), n2 = ts2(i2, e2, s2);
            o2 && n2 || (this._active && r.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t2) {
            this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function ts2(t2, e2, i2) {
          for (let a2 = 0; a2 < t2.length; a2++) if (t2[a2].identifier === i2) return e2[a2];
        }
        function es2(t2, e2) {
          return Math.log(t2 / e2) / Math.LN2;
        }
        class is2 extends Qa2 {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t2) {
            this._startDistance = this._distance = t2[0].dist(t2[1]);
          }
          _move(t2, e2) {
            const i2 = this._distance;
            if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(es2(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: es2(this._distance, i2), pinchAround: e2 };
          }
        }
        function as2(t2, e2) {
          return 180 * t2.angleWith(e2) / Math.PI;
        }
        class ss2 extends Qa2 {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t2) {
            this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
          }
          _move(t2, e2, i2) {
            const a2 = this._vector;
            if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: as2(this._vector, a2), pinchAround: e2 };
          }
          _isBelowThreshold(t2) {
            this._minDiameter = Math.min(this._minDiameter, t2.mag());
            const e2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = as2(t2, this._startVector);
            return Math.abs(i2) < e2;
          }
        }
        function os2(t2) {
          return Math.abs(t2.y) > Math.abs(t2.x);
        }
        class rs2 extends Qa2 {
          constructor(t2) {
            super(), this._currentTouchCount = 0, this._map = t2;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t2, e2, i2) {
            super.touchstart(t2, e2, i2), this._currentTouchCount = i2.length;
          }
          _start(t2) {
            this._lastPoints = t2, os2(t2[0].sub(t2[1])) && (this._valid = false);
          }
          _move(t2, e2, i2) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const a2 = t2[0].sub(this._lastPoints[0]), s2 = t2[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(a2, s2, i2.timeStamp), this._valid ? (this._lastPoints = t2, this._active = true, { pitchDelta: (a2.y + s2.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t2, e2, i2) {
            if (void 0 !== this._valid) return this._valid;
            const a2 = t2.mag() >= 2, s2 = e2.mag() >= 2;
            if (!a2 && !s2) return;
            if (!a2 || !s2) return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            const o2 = t2.y > 0 == e2.y > 0;
            return os2(t2) && os2(e2) && o2;
          }
        }
        const ns2 = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class ls2 {
          constructor(t2) {
            this._tr = new Na2(t2);
            const e2 = ns2;
            this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(t2) {
            if (t2.altKey || t2.ctrlKey || t2.metaKey) return;
            let e2 = 0, i2 = 0, a2 = 0, s2 = 0, o2 = 0;
            switch (t2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                e2 = -1;
                break;
              case 37:
                t2.shiftKey ? i2 = -1 : (t2.preventDefault(), s2 = -1);
                break;
              case 39:
                t2.shiftKey ? i2 = 1 : (t2.preventDefault(), s2 = 1);
                break;
              case 38:
                t2.shiftKey ? a2 = 1 : (t2.preventDefault(), o2 = -1);
                break;
              case 40:
                t2.shiftKey ? a2 = -1 : (t2.preventDefault(), o2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i2 = 0, a2 = 0), { cameraAnimation: (r2) => {
              const n2 = this._tr;
              r2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: hs2, zoom: e2 ? Math.round(n2.zoom) + e2 * (t2.shiftKey ? 2 : 1) : n2.zoom, bearing: n2.bearing + i2 * this._bearingStep, pitch: n2.pitch + a2 * this._pitchStep, offset: [-s2 * this._panStep, -o2 * this._panStep], center: n2.center }, { originalEvent: t2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function hs2(t2) {
          return t2 * (2 - t2);
        }
        const cs2 = 4.000244140625;
        class us2 {
          constructor(t2, e2) {
            this._onTimeout = (t3) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t3);
            }, this._map = t2, this._tr = new Na2(t2), this._triggerRenderFrame = e2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
          }
          setZoomRate(t2) {
            this._defaultZoomRate = t2;
          }
          setWheelZoomRate(t2) {
            this._wheelZoomRate = t2;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t2) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(t2) {
            return !!this._map.cooperativeGestures.isEnabled() && !(t2.ctrlKey || this._map.cooperativeGestures.isBypassed(t2));
          }
          wheel(t2) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(t2)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t2);
            let e2 = t2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
            const i2 = o.now(), a2 = i2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = i2, 0 !== e2 && e2 % cs2 == 0 ? this._type = "wheel" : 0 !== e2 && Math.abs(e2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = e2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(a2 * e2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, e2 += this._lastValue)), t2.shiftKey && e2 && (e2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= e2, this._active || this._start(t2)), t2.preventDefault();
          }
          _start(t2) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i2 = r.mousePos(this._map.getCanvas(), t2), a2 = this._tr;
            this._around = i2.y > a2.transform.height / 2 - a2.transform.getHorizon() ? e.N.convert(this._aroundCenter ? a2.center : a2.unproject(i2)) : e.N.convert(a2.center), this._aroundPoint = a2.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId) return;
            if (this._frameId = null, !this.isActive()) return;
            const t2 = this._tr.transform;
            if (0 !== this._delta) {
              const e2 = "wheel" === this._type && Math.abs(this._delta) > cs2 ? this._wheelZoomRate : this._defaultZoomRate;
              let i3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
              this._delta < 0 && 0 !== i3 && (i3 = 1 / i3);
              const a3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : t2.scale;
              this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(a3 * i3))), "wheel" === this._type && (this._startZoom = t2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i2 = "number" == typeof this._targetZoom ? this._targetZoom : t2.zoom, a2 = this._startZoom, s2 = this._easing;
            let r2, n2 = false;
            const l3 = o.now() - this._lastWheelEventTime;
            if ("wheel" === this._type && a2 && s2 && l3) {
              const t3 = Math.min(l3 / 200, 1), o2 = s2(t3);
              r2 = e.y.number(a2, i2, o2), t3 < 1 ? this._frameId || (this._frameId = true) : n2 = true;
            } else r2 = i2, n2 = true;
            return this._active = true, n2 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !n2, zoomDelta: r2 - t2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t2) {
            let i2 = e.b9;
            if (this._prevEase) {
              const t3 = this._prevEase, a2 = (o.now() - t3.start) / t3.duration, s2 = t3.easing(a2 + 0.01) - t3.easing(a2), r2 = 0.27 / Math.sqrt(s2 * s2 + 1e-4) * 0.01, n2 = Math.sqrt(0.0729 - r2 * r2);
              i2 = e.b8(r2, n2, 0.25, 1);
            }
            return this._prevEase = { start: o.now(), duration: t2, easing: i2 }, i2;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class ds2 {
          constructor(t2, e2) {
            this._clickZoom = t2, this._tapZoom = e2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class _s2 {
          constructor(t2) {
            this._tr = new Na2(t2), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(t2, e2) {
            return t2.preventDefault(), { cameraAnimation: (i2) => {
              i2.easeTo({ duration: 300, zoom: this._tr.zoom + (t2.shiftKey ? -1 : 1), around: this._tr.unproject(e2) }, { originalEvent: t2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ps2 {
          constructor() {
            this._tap = new qa2({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(t2, e2, i2) {
            if (!this._swipePoint) if (this._tapTime) {
              const a2 = e2[0], s2 = t2.timeStamp - this._tapTime < 500, o2 = this._tapPoint.dist(a2) < 30;
              s2 && o2 ? i2.length > 0 && (this._swipePoint = a2, this._swipeTouch = i2[0].identifier) : this.reset();
            } else this._tap.touchstart(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch) return;
                const a2 = e2[0], s2 = a2.y - this._swipePoint.y;
                return this._swipePoint = a2, t2.preventDefault(), this._active = true, { zoomDelta: s2 / 128 };
              }
            } else this._tap.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            if (this._tapTime) this._swipePoint && 0 === i2.length && this.reset();
            else {
              const a2 = this._tap.touchend(t2, e2, i2);
              a2 && (this._tapTime = t2.timeStamp, this._tapPoint = a2);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ms2 {
          constructor(t2, e2, i2) {
            this._el = t2, this._mousePan = e2, this._touchPan = i2;
          }
          enable(t2) {
            this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class fs2 {
          constructor(t2, e2, i2) {
            this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class gs2 {
          constructor(t2, e2, i2, a2) {
            this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = a2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(t2) {
            this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class vs2 {
          constructor(t2, e2) {
            this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = t2, this._options = e2, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const t2 = this._map.getCanvasContainer();
            t2.classList.add("maplibregl-cooperative-gestures"), this._container = r.create("div", "maplibregl-cooperative-gesture-screen", t2);
            let e2 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            "metaKey" === this._bypassKey && (e2 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const i2 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), a2 = document.createElement("div");
            a2.className = "maplibregl-desktop-message", a2.textContent = e2, this._container.appendChild(a2);
            const s2 = document.createElement("div");
            s2.className = "maplibregl-mobile-message", s2.textContent = i2, this._container.appendChild(s2), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (r.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(t2) {
            return t2[this._bypassKey];
          }
          notifyGestureBlocked(t2, i2) {
            this._enabled && (this._map.fire(new e.k("cooperativegestureprevented", { gestureType: t2, originalEvent: i2 })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const xs2 = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;
        class ys2 extends e.k {
        }
        function bs2(t2) {
          return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
        }
        class ws2 {
          constructor(t2, e2) {
            this.handleWindowEvent = (t3) => {
              this.handleEvent(t3, "".concat(t3.type, "Window"));
            }, this.handleEvent = (t3, e3) => {
              if ("blur" === t3.type) return void this.stop(true);
              this._updatingCamera = true;
              const i3 = "renderFrame" === t3.type ? void 0 : t3, a2 = { needsRenderFrame: false }, s2 = {}, o2 = {}, n2 = t3.touches, l3 = n2 ? this._getMapTouches(n2) : void 0, h2 = l3 ? r.touchPos(this._map.getCanvas(), l3) : r.mousePos(this._map.getCanvas(), t3);
              for (const { handlerName: r2, handler: n3, allowed: c3 } of this._handlers) {
                if (!n3.isEnabled()) continue;
                let u3;
                this._blockedByActive(o2, c3, r2) ? n3.reset() : n3[e3 || t3.type] && (u3 = n3[e3 || t3.type](t3, h2, l3), this.mergeHandlerResult(a2, s2, u3, r2, i3), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n3.isActive()) && (o2[r2] = n3);
              }
              const c2 = {};
              for (const t4 in this._previousActiveHandlers) o2[t4] || (c2[t4] = i3);
              this._previousActiveHandlers = o2, (Object.keys(c2).length || bs2(a2)) && (this._changes.push([a2, s2, c2]), this._triggerRenderFrame()), (Object.keys(o2).length || bs2(a2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: u2 } = a2;
              u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
            }, this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ma2(t2), this._bearingSnap = e2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e2);
            const i2 = this._el;
            this._listeners = [[i2, "touchstart", { passive: true }], [i2, "touchmove", { passive: false }], [i2, "touchend", void 0], [i2, "touchcancel", void 0], [i2, "mousedown", void 0], [i2, "mousemove", void 0], [i2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [i2, "mouseover", void 0], [i2, "mouseout", void 0], [i2, "dblclick", void 0], [i2, "click", void 0], [i2, "keydown", { capture: false }], [i2, "keyup", void 0], [i2, "wheel", { passive: false }], [i2, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [t3, e3, i3] of this._listeners) r.addEventListener(t3, e3, t3 === document ? this.handleWindowEvent : this.handleEvent, i3);
          }
          destroy() {
            for (const [t2, e2, i2] of this._listeners) r.removeEventListener(t2, e2, t2 === document ? this.handleWindowEvent : this.handleEvent, i2);
          }
          _addDefaultHandlers(t2) {
            const e2 = this._map, i2 = e2.getCanvasContainer();
            this._add("mapEvent", new Ba2(e2, t2));
            const a2 = e2.boxZoom = new Ua2(e2, t2);
            this._add("boxZoom", a2), t2.interactive && t2.boxZoom && a2.enable();
            const s2 = e2.cooperativeGestures = new vs2(e2, t2.cooperativeGestures);
            this._add("cooperativeGestures", s2), t2.cooperativeGestures && s2.enable();
            const o2 = new Va2(e2), n2 = new _s2(e2);
            e2.doubleClickZoom = new ds2(n2, o2), this._add("tapZoom", o2), this._add("clickZoom", n2), t2.interactive && t2.doubleClickZoom && e2.doubleClickZoom.enable();
            const l3 = new ps2();
            this._add("tapDragZoom", l3);
            const h2 = e2.touchPitch = new rs2(e2);
            this._add("touchPitch", h2), t2.interactive && t2.touchPitch && e2.touchPitch.enable(t2.touchPitch);
            const c2 = Ka2(t2), u2 = Ja2(t2);
            e2.dragRotate = new fs2(t2, c2, u2), this._add("mouseRotate", c2, ["mousePitch"]), this._add("mousePitch", u2, ["mouseRotate"]), t2.interactive && t2.dragRotate && e2.dragRotate.enable();
            const d2 = (({ enable: t3, clickTolerance: e3 }) => {
              const i3 = new Wa2({ checkCorrectEvent: (t4) => 0 === r.mouseButton(t4) && !t4.ctrlKey });
              return new Ga2({ clickTolerance: e3, move: (t4, e4) => ({ around: e4, panDelta: e4.sub(t4) }), activateOnStart: true, moveStateManager: i3, enable: t3, assignEvents: Xa2 });
            })(t2), _2 = new Ya2(t2, e2);
            e2.dragPan = new ms2(i2, d2, _2), this._add("mousePan", d2), this._add("touchPan", _2, ["touchZoom", "touchRotate"]), t2.interactive && t2.dragPan && e2.dragPan.enable(t2.dragPan);
            const p2 = new ss2(), m2 = new is2();
            e2.touchZoomRotate = new gs2(i2, m2, p2, l3), this._add("touchRotate", p2, ["touchPan", "touchZoom"]), this._add("touchZoom", m2, ["touchPan", "touchRotate"]), t2.interactive && t2.touchZoomRotate && e2.touchZoomRotate.enable(t2.touchZoomRotate);
            const f2 = e2.scrollZoom = new us2(e2, () => this._triggerRenderFrame());
            this._add("scrollZoom", f2, ["mousePan"]), t2.interactive && t2.scrollZoom && e2.scrollZoom.enable(t2.scrollZoom);
            const g2 = e2.keyboard = new ls2(e2);
            this._add("keyboard", g2), t2.interactive && t2.keyboard && e2.keyboard.enable(), this._add("blockableMapEvent", new Oa2(e2));
          }
          _add(t2, e2, i2) {
            this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
          }
          stop(t2) {
            if (!this._updatingCamera) {
              for (const { handler: t3 } of this._handlers) t3.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t2 } of this._handlers) if (t2.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(xs2(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(t2, e2, i2) {
            for (const a2 in t2) if (a2 !== i2 && (!e2 || e2.indexOf(a2) < 0)) return true;
            return false;
          }
          _getMapTouches(t2) {
            const e2 = [];
            for (const i2 of t2) this._el.contains(i2.target) && e2.push(i2);
            return e2;
          }
          mergeHandlerResult(t2, i2, a2, s2, o2) {
            if (!a2) return;
            e.e(t2, a2);
            const r2 = { handlerName: s2, originalEvent: a2.originalEvent || o2 };
            void 0 !== a2.zoomDelta && (i2.zoom = r2), void 0 !== a2.panDelta && (i2.drag = r2), void 0 !== a2.pitchDelta && (i2.pitch = r2), void 0 !== a2.bearingDelta && (i2.rotate = r2);
          }
          _applyChanges() {
            const t2 = {}, i2 = {}, a2 = {};
            for (const [s2, o2, r2] of this._changes) s2.panDelta && (t2.panDelta = (t2.panDelta || new e.P(0, 0))._add(s2.panDelta)), s2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + s2.pitchDelta), void 0 !== s2.around && (t2.around = s2.around), void 0 !== s2.pinchAround && (t2.pinchAround = s2.pinchAround), s2.noInertia && (t2.noInertia = s2.noInertia), e.e(i2, o2), e.e(a2, r2);
            this._updateMapTransform(t2, i2, a2), this._changes = [];
          }
          _updateMapTransform(t2, e2, i2) {
            const a2 = this._map, s2 = a2._getTransformForUpdate(), o2 = a2.terrain;
            if (!(bs2(t2) || o2 && this._terrainMovement)) return this._fireEvents(e2, i2, true);
            let { panDelta: r2, zoomDelta: n2, bearingDelta: l3, pitchDelta: h2, around: c2, pinchAround: u2 } = t2;
            void 0 !== u2 && (c2 = u2), a2._stop(true), c2 = c2 || a2.transform.centerPoint;
            const d2 = s2.pointLocation(r2 ? c2.sub(r2) : c2);
            l3 && (s2.bearing += l3), h2 && (s2.pitch += h2), n2 && (s2.zoom += n2), o2 ? this._terrainMovement || !e2.drag && !e2.zoom ? e2.drag && this._terrainMovement ? s2.center = s2.pointLocation(s2.centerPoint.sub(r2)) : s2.setLocationAtPoint(d2, c2) : (this._terrainMovement = true, this._map._elevationFreeze = true, s2.setLocationAtPoint(d2, c2)) : s2.setLocationAtPoint(d2, c2), a2._applyUpdatedTransform(s2), this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(e2, i2, true);
          }
          _fireEvents(t2, i2, a2) {
            const s2 = xs2(this._eventsInProgress), r2 = xs2(t2), n2 = {};
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._eventsInProgress[e2] || (n2["".concat(e2, "start")] = i3), this._eventsInProgress[e2] = t2[e2];
            }
            !s2 && r2 && this._fireEvent("movestart", r2.originalEvent);
            for (const t3 in n2) this._fireEvent(t3, n2[t3]);
            r2 && this._fireEvent("move", r2.originalEvent);
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._fireEvent(e2, i3);
            }
            const l3 = {};
            let h2;
            for (const t3 in this._eventsInProgress) {
              const { handlerName: e2, originalEvent: a3 } = this._eventsInProgress[t3];
              this._handlersById[e2].isActive() || (delete this._eventsInProgress[t3], h2 = i2[e2] || a3, l3["".concat(t3, "end")] = h2);
            }
            for (const t3 in l3) this._fireEvent(t3, l3[t3]);
            const c2 = xs2(this._eventsInProgress), u2 = (s2 || r2) && !c2;
            if (u2 && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const t3 = this._map._getTransformForUpdate();
              t3.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(t3);
            }
            if (a2 && u2) {
              this._updatingCamera = true;
              const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t4) => 0 !== t4 && -this._bearingSnap < t4 && t4 < this._bearingSnap;
              !t3 || !t3.essential && o.prefersReducedMotion ? (this._map.fire(new e.k("moveend", { originalEvent: h2 })), i3(this._map.getBearing()) && this._map.resetNorth()) : (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), t3.freezeElevation = true, this._map.easeTo(t3, { originalEvent: h2 })), this._updatingCamera = false;
            }
          }
          _fireEvent(t2, i2) {
            this._map.fire(new e.k(t2, i2 ? { originalEvent: i2 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
              delete this._frameId, this.handleEvent(new ys2("renderFrame", { timeStamp: t2 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class Ts2 extends e.E {
          constructor(t2, e2) {
            super(), this._renderFrameCallback = () => {
              const t3 = Math.min((o.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(t3)), t3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = e2.bearingSnap, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          getCenter() {
            return new e.N(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t2, e2) {
            return this.jumpTo({ center: t2 }, e2);
          }
          panBy(t2, i2, a2) {
            return t2 = e.P.convert(t2).mult(-1), this.panTo(this.transform.center, e.e({ offset: t2 }, i2), a2);
          }
          panTo(t2, i2, a2) {
            return this.easeTo(e.e({ center: t2 }, i2), a2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t2, e2) {
            return this.jumpTo({ zoom: t2 }, e2), this;
          }
          zoomTo(t2, i2, a2) {
            return this.easeTo(e.e({ zoom: t2 }, i2), a2);
          }
          zoomIn(t2, e2) {
            return this.zoomTo(this.getZoom() + 1, t2, e2), this;
          }
          zoomOut(t2, e2) {
            return this.zoomTo(this.getZoom() - 1, t2, e2), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t2, e2) {
            return this.jumpTo({ bearing: t2 }, e2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t2, e2) {
            return this.jumpTo({ padding: t2 }, e2), this;
          }
          rotateTo(t2, i2, a2) {
            return this.easeTo(e.e({ bearing: t2 }, i2), a2);
          }
          resetNorth(t2, i2) {
            return this.rotateTo(0, e.e({ duration: 1e3 }, t2), i2), this;
          }
          resetNorthPitch(t2, i2) {
            return this.easeTo(e.e({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
          }
          snapToNorth(t2, e2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t2, e2) {
            return this.jumpTo({ pitch: t2 }, e2), this;
          }
          cameraForBounds(t2, e2) {
            t2 = H.convert(t2).adjustAntiMeridian();
            const i2 = e2 && e2.bearing || 0;
            return this._cameraForBoxAndBearing(t2.getNorthWest(), t2.getSouthEast(), i2, e2);
          }
          _cameraForBoxAndBearing(t2, i2, a2, s2) {
            const o2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (s2 = e.e({ padding: o2, offset: [0, 0], maxZoom: this.transform.maxZoom }, s2)).padding) {
              const t3 = s2.padding;
              s2.padding = { top: t3, bottom: t3, right: t3, left: t3 };
            }
            s2.padding = e.e(o2, s2.padding);
            const r2 = this.transform, n2 = r2.padding, l3 = new H(t2, i2), h2 = r2.project(l3.getNorthWest()), c2 = r2.project(l3.getNorthEast()), u2 = r2.project(l3.getSouthEast()), d2 = r2.project(l3.getSouthWest()), _2 = e.ba(-a2), p2 = h2.rotate(_2), m2 = c2.rotate(_2), f2 = u2.rotate(_2), g2 = d2.rotate(_2), v2 = new e.P(Math.max(p2.x, m2.x, g2.x, f2.x), Math.max(p2.y, m2.y, g2.y, f2.y)), x2 = new e.P(Math.min(p2.x, m2.x, g2.x, f2.x), Math.min(p2.y, m2.y, g2.y, f2.y)), y3 = v2.sub(x2), b2 = (r2.width - (n2.left + n2.right + s2.padding.left + s2.padding.right)) / y3.x, w2 = (r2.height - (n2.top + n2.bottom + s2.padding.top + s2.padding.bottom)) / y3.y;
            if (w2 < 0 || b2 < 0) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            const T2 = Math.min(r2.scaleZoom(r2.scale * Math.min(b2, w2)), s2.maxZoom), I2 = e.P.convert(s2.offset), E2 = new e.P((s2.padding.left - s2.padding.right) / 2, (s2.padding.top - s2.padding.bottom) / 2).rotate(e.ba(a2)), P2 = I2.add(E2).mult(r2.scale / r2.zoomScale(T2));
            return { center: r2.unproject(h2.add(u2).div(2).sub(P2)), zoom: T2, bearing: a2 };
          }
          fitBounds(t2, e2, i2) {
            return this._fitInternal(this.cameraForBounds(t2, e2), e2, i2);
          }
          fitScreenCoordinates(t2, i2, a2, s2, o2) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(e.P.convert(t2)), this.transform.pointLocation(e.P.convert(i2)), a2, s2), s2, o2);
          }
          _fitInternal(t2, i2, a2) {
            return t2 ? (delete (i2 = e.e(t2, i2)).padding, i2.linear ? this.easeTo(i2, a2) : this.flyTo(i2, a2)) : this;
          }
          jumpTo(t2, i2) {
            this.stop();
            const a2 = this._getTransformForUpdate();
            let s2 = false, o2 = false, r2 = false;
            return "zoom" in t2 && a2.zoom !== +t2.zoom && (s2 = true, a2.zoom = +t2.zoom), void 0 !== t2.center && (a2.center = e.N.convert(t2.center)), "bearing" in t2 && a2.bearing !== +t2.bearing && (o2 = true, a2.bearing = +t2.bearing), "pitch" in t2 && a2.pitch !== +t2.pitch && (r2 = true, a2.pitch = +t2.pitch), null == t2.padding || a2.isPaddingEqual(t2.padding) || (a2.padding = t2.padding), this._applyUpdatedTransform(a2), this.fire(new e.k("movestart", i2)).fire(new e.k("move", i2)), s2 && this.fire(new e.k("zoomstart", i2)).fire(new e.k("zoom", i2)).fire(new e.k("zoomend", i2)), o2 && this.fire(new e.k("rotatestart", i2)).fire(new e.k("rotate", i2)).fire(new e.k("rotateend", i2)), r2 && this.fire(new e.k("pitchstart", i2)).fire(new e.k("pitch", i2)).fire(new e.k("pitchend", i2)), this.fire(new e.k("moveend", i2));
          }
          calculateCameraOptionsFromTo(t2, i2, a2, s2 = 0) {
            const o2 = e.Z.fromLngLat(t2, i2), r2 = e.Z.fromLngLat(a2, s2), n2 = r2.x - o2.x, l3 = r2.y - o2.y, h2 = r2.z - o2.z, c2 = Math.hypot(n2, l3, h2);
            if (0 === c2) throw new Error("Can't calculate camera options with same From and To");
            const u2 = Math.hypot(n2, l3), d2 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / c2 / this.transform.tileSize), _2 = 180 * Math.atan2(n2, -l3) / Math.PI;
            let p2 = 180 * Math.acos(u2 / c2) / Math.PI;
            return p2 = h2 < 0 ? 90 - p2 : 90 + p2, { center: r2.toLngLat(), zoom: d2, pitch: p2, bearing: _2 };
          }
          easeTo(t2, i2) {
            var a2;
            this._stop(false, t2.easeId), (false === (t2 = e.e({ offset: [0, 0], duration: 500, easing: e.b9 }, t2)).animate || !t2.essential && o.prefersReducedMotion) && (t2.duration = 0);
            const s2 = this._getTransformForUpdate(), r2 = s2.zoom, n2 = s2.bearing, l3 = s2.pitch, h2 = s2.padding, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, u2 = "pitch" in t2 ? +t2.pitch : l3, d2 = "padding" in t2 ? t2.padding : s2.padding, _2 = e.P.convert(t2.offset);
            let p2 = s2.centerPoint.add(_2);
            const m2 = s2.pointLocation(p2), { center: f2, zoom: g2 } = s2.getConstrained(e.N.convert(t2.center || m2), null !== (a2 = t2.zoom) && void 0 !== a2 ? a2 : r2);
            this._normalizeCenter(f2, s2);
            const v2 = s2.project(m2), x2 = s2.project(f2).sub(v2), y3 = s2.zoomScale(g2 - r2);
            let b2, w2;
            t2.around && (b2 = e.N.convert(t2.around), w2 = s2.locationPoint(b2));
            const T2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || g2 !== r2, this._rotating = this._rotating || n2 !== c2, this._pitching = this._pitching || u2 !== l3, this._padding = !s2.isPaddingEqual(d2), this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, T2), this.terrain && this._prepareElevation(f2), this._ease((a3) => {
              if (this._zooming && (s2.zoom = e.y.number(r2, g2, a3)), this._rotating && (s2.bearing = e.y.number(n2, c2, a3)), this._pitching && (s2.pitch = e.y.number(l3, u2, a3)), this._padding && (s2.interpolatePadding(h2, d2, a3), p2 = s2.centerPoint.add(_2)), this.terrain && !t2.freezeElevation && this._updateElevation(a3), b2) s2.setLocationAtPoint(b2, w2);
              else {
                const t3 = s2.zoomScale(s2.zoom - r2), e2 = g2 > r2 ? Math.min(2, y3) : Math.max(0.5, y3), i3 = Math.pow(e2, 1 - a3), o2 = s2.unproject(v2.add(x2.mult(a3 * i3)).mult(t3));
                s2.setLocationAtPoint(s2.renderWorldCopies ? o2.wrap() : o2, p2);
              }
              this._applyUpdatedTransform(s2), this._fireMoveEvents(i2);
            }, (e2) => {
              this.terrain && t2.freezeElevation && this._finalizeElevation(), this._afterEase(i2, e2);
            }, t2), this;
          }
          _prepareEase(t2, i2, a2 = {}) {
            this._moving = true, i2 || a2.moving || this.fire(new e.k("movestart", t2)), this._zooming && !a2.zooming && this.fire(new e.k("zoomstart", t2)), this._rotating && !a2.rotating && this.fire(new e.k("rotatestart", t2)), this._pitching && !a2.pitching && this.fire(new e.k("pitchstart", t2));
          }
          _prepareElevation(t2) {
            this._elevationCenter = t2, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t2, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(t2) {
            this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            const i2 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (t2 < 1 && i2 !== this._elevationTarget) {
              const e2 = this._elevationTarget - this._elevationStart;
              this._elevationStart += t2 * (e2 - (i2 - (e2 * t2 + this._elevationStart)) / (1 - t2)), this._elevationTarget = i2;
            }
            this.transform.elevation = e.y.number(this._elevationStart, this._elevationTarget, t2);
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(t2) {
            const e2 = t2.getCameraPosition(), i2 = this.terrain.getElevationForLngLatZoom(e2.lngLat, t2.zoom);
            if (e2.altitude < i2) {
              const a2 = this.calculateCameraOptionsFromTo(e2.lngLat, i2, t2.center, t2.elevation);
              return { pitch: a2.pitch, zoom: a2.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(t2) {
            const e2 = [];
            if (this.terrain && e2.push((t3) => this._elevateCameraIfInsideTerrain(t3)), this.transformCameraUpdate && e2.push((t3) => this.transformCameraUpdate(t3)), !e2.length) return;
            const i2 = t2.clone();
            for (const t3 of e2) {
              const e3 = i2.clone(), { center: a2, zoom: s2, pitch: o2, bearing: r2, elevation: n2 } = t3(e3);
              a2 && (e3.center = a2), void 0 !== s2 && (e3.zoom = s2), void 0 !== o2 && (e3.pitch = o2), void 0 !== r2 && (e3.bearing = r2), void 0 !== n2 && (e3.elevation = n2), i2.apply(e3);
            }
            this.transform.apply(i2);
          }
          _fireMoveEvents(t2) {
            this.fire(new e.k("move", t2)), this._zooming && this.fire(new e.k("zoom", t2)), this._rotating && this.fire(new e.k("rotate", t2)), this._pitching && this.fire(new e.k("pitch", t2));
          }
          _afterEase(t2, i2) {
            if (this._easeId && i2 && this._easeId === i2) return;
            delete this._easeId;
            const a2 = this._zooming, s2 = this._rotating, o2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, a2 && this.fire(new e.k("zoomend", t2)), s2 && this.fire(new e.k("rotateend", t2)), o2 && this.fire(new e.k("pitchend", t2)), this.fire(new e.k("moveend", t2));
          }
          flyTo(t2, i2) {
            var a2;
            if (!t2.essential && o.prefersReducedMotion) {
              const a3 = e.M(t2, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(a3, i2);
            }
            this.stop(), t2 = e.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.b9 }, t2);
            const s2 = this._getTransformForUpdate(), r2 = s2.zoom, n2 = s2.bearing, l3 = s2.pitch, h2 = s2.padding, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, u2 = "pitch" in t2 ? +t2.pitch : l3, d2 = "padding" in t2 ? t2.padding : s2.padding, _2 = e.P.convert(t2.offset);
            let p2 = s2.centerPoint.add(_2);
            const m2 = s2.pointLocation(p2), { center: f2, zoom: g2 } = s2.getConstrained(e.N.convert(t2.center || m2), null !== (a2 = t2.zoom) && void 0 !== a2 ? a2 : r2);
            this._normalizeCenter(f2, s2);
            const v2 = s2.zoomScale(g2 - r2), x2 = s2.project(m2), y3 = s2.project(f2).sub(x2);
            let b2 = t2.curve;
            const w2 = Math.max(s2.width, s2.height), T2 = w2 / v2, I2 = y3.mag();
            if ("minZoom" in t2) {
              const i3 = e.ac(Math.min(t2.minZoom, r2, g2), s2.minZoom, s2.maxZoom), a3 = w2 / s2.zoomScale(i3 - r2);
              b2 = Math.sqrt(a3 / I2 * 2);
            }
            const E2 = b2 * b2;
            function P2(t3) {
              const e2 = (T2 * T2 - w2 * w2 + (t3 ? -1 : 1) * E2 * E2 * I2 * I2) / (2 * (t3 ? T2 : w2) * E2 * I2);
              return Math.log(Math.sqrt(e2 * e2 + 1) - e2);
            }
            function C3(t3) {
              return (Math.exp(t3) - Math.exp(-t3)) / 2;
            }
            function S2(t3) {
              return (Math.exp(t3) + Math.exp(-t3)) / 2;
            }
            const z3 = P2(false);
            let D2 = function(t3) {
              return S2(z3) / S2(z3 + b2 * t3);
            }, M3 = function(t3) {
              return w2 * ((S2(z3) * (C3(e2 = z3 + b2 * t3) / S2(e2)) - C3(z3)) / E2) / I2;
              var e2;
            }, A3 = (P2(true) - z3) / b2;
            if (Math.abs(I2) < 1e-6 || !isFinite(A3)) {
              if (Math.abs(w2 - T2) < 1e-6) return this.easeTo(t2, i2);
              const e2 = T2 < w2 ? -1 : 1;
              A3 = Math.abs(Math.log(T2 / w2)) / b2, M3 = () => 0, D2 = (t3) => Math.exp(e2 * b2 * t3);
            }
            return t2.duration = "duration" in t2 ? +t2.duration : 1e3 * A3 / ("screenSpeed" in t2 ? +t2.screenSpeed / b2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0), this._zooming = true, this._rotating = n2 !== c2, this._pitching = u2 !== l3, this._padding = !s2.isPaddingEqual(d2), this._prepareEase(i2, false), this.terrain && this._prepareElevation(f2), this._ease((a3) => {
              const o2 = a3 * A3, m3 = 1 / D2(o2);
              s2.zoom = 1 === a3 ? g2 : r2 + s2.scaleZoom(m3), this._rotating && (s2.bearing = e.y.number(n2, c2, a3)), this._pitching && (s2.pitch = e.y.number(l3, u2, a3)), this._padding && (s2.interpolatePadding(h2, d2, a3), p2 = s2.centerPoint.add(_2)), this.terrain && !t2.freezeElevation && this._updateElevation(a3);
              const v3 = 1 === a3 ? f2 : s2.unproject(x2.add(y3.mult(M3(o2))).mult(m3));
              s2.setLocationAtPoint(s2.renderWorldCopies ? v3.wrap() : v3, p2), this._applyUpdatedTransform(s2), this._fireMoveEvents(i2);
            }, () => {
              this.terrain && t2.freezeElevation && this._finalizeElevation(), this._afterEase(i2);
            }, t2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t2, e2) {
            var i2;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const t3 = this._onEaseEnd;
              delete this._onEaseEnd, t3.call(this, e2);
            }
            return t2 || null === (i2 = this.handlers) || void 0 === i2 || i2.stop(false), this;
          }
          _ease(t2, e2, i2) {
            false === i2.animate || 0 === i2.duration ? (t2(1), e2()) : (this._easeStart = o.now(), this._easeOptions = i2, this._onEaseFrame = t2, this._onEaseEnd = e2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(t2, i2) {
            t2 = e.b3(t2, -180, 180);
            const a2 = Math.abs(t2 - i2);
            return Math.abs(t2 - 360 - i2) < a2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < a2 && (t2 += 360), t2;
          }
          _normalizeCenter(t2, e2) {
            if (!e2.renderWorldCopies || e2.lngRange) return;
            const i2 = t2.lng - e2.center.lng;
            t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
          }
          queryTerrainElevation(t2) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(e.N.convert(t2), this.transform.tileZoom) - this.transform.elevation : null;
          }
        }
        const Is2 = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Es2 {
          constructor(t2 = Is2) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (t3) => {
              !t3 || "metadata" !== t3.sourceDataType && "visibility" !== t3.sourceDataType && "style" !== t3.dataType && "terrain" !== t3.type || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = t2;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t2) {
            return this._map = t2, this._compact = this.options.compact, this._container = r.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = r.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = r.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t2, e2) {
            const i2 = this._map._getUIString("AttributionControl.".concat(e2));
            t2.title = i2, t2.setAttribute("aria-label", i2);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let t2 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => "string" != typeof t3 ? "" : t3)) : "string" == typeof this.options.customAttribution && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const t3 = this._map.style.stylesheet;
              this.styleOwner = t3.owner, this.styleId = t3.id;
            }
            const e2 = this._map.style.sourceCaches;
            for (const i3 in e2) {
              const a2 = e2[i3];
              if (a2.used || a2.usedForTerrain) {
                const e3 = a2.getSource();
                e3.attribution && t2.indexOf(e3.attribution) < 0 && t2.push(e3.attribution);
              }
            }
            t2 = t2.filter((t3) => String(t3).trim()), t2.sort((t3, e3) => t3.length - e3.length), t2 = t2.filter((e3, i3) => {
              for (let a2 = i3 + 1; a2 < t2.length; a2++) if (t2[a2].indexOf(e3) >= 0) return false;
              return true;
            });
            const i2 = t2.join(" | ");
            i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Ps2 {
          constructor(t2 = {}) {
            this._updateCompact = () => {
              const t3 = this._container.children;
              if (t3.length) {
                const e2 = t3[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e2.classList.add("maplibregl-compact") : e2.classList.remove("maplibregl-compact");
              }
            }, this.options = t2;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t2) {
            this._map = t2, this._compact = this.options && this.options.compact, this._container = r.create("div", "maplibregl-ctrl");
            const e2 = r.create("a", "maplibregl-ctrl-logo");
            return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Cs2 {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(t2) {
            const e2 = ++this._id;
            return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
          }
          remove(t2) {
            const e2 = this._currentlyRunning, i2 = e2 ? this._queue.concat(e2) : this._queue;
            for (const e3 of i2) if (e3.id === t2) return void (e3.cancelled = true);
          }
          run(t2 = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const e2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i2 of e2) if (!i2.cancelled && (i2.callback(t2), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var Ss2 = e.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class zs2 extends e.E {
          constructor(t2) {
            super(), this.sourceCache = t2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t2.usedForTerrain = true, t2.tileSize = this.tileSize * 2 ** this.deltaZoom;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(t2, i2) {
            this.sourceCache.update(t2, i2), this._renderableTilesKeys = [];
            const a2 = {};
            for (const s2 of t2.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2 })) a2[s2.key] = true, this._renderableTilesKeys.push(s2.key), this._tiles[s2.key] || (s2.posMatrix = new Float64Array(16), e.aP(s2.posMatrix, 0, e.X, 0, e.X, 0, 1), this._tiles[s2.key] = new lt2(s2, this.tileSize));
            for (const t3 in this._tiles) a2[t3] || delete this._tiles[t3];
          }
          freeRtt(t2) {
            for (const e2 in this._tiles) {
              const i2 = this._tiles[e2];
              (!t2 || i2.tileID.equals(t2) || i2.tileID.isChildOf(t2) || t2.isChildOf(i2.tileID)) && (i2.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((t2) => this.getTileByID(t2));
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          getTerrainCoords(t2) {
            const i2 = {};
            for (const a2 of this._renderableTilesKeys) {
              const s2 = this._tiles[a2].tileID;
              if (s2.canonical.equals(t2.canonical)) {
                const s3 = t2.clone();
                s3.posMatrix = new Float64Array(16), e.aP(s3.posMatrix, 0, e.X, 0, e.X, 0, 1), i2[a2] = s3;
              } else if (s2.canonical.isChildOf(t2.canonical)) {
                const o2 = t2.clone();
                o2.posMatrix = new Float64Array(16);
                const r2 = s2.canonical.z - t2.canonical.z, n2 = s2.canonical.x - (s2.canonical.x >> r2 << r2), l3 = s2.canonical.y - (s2.canonical.y >> r2 << r2), h2 = e.X >> r2;
                e.aP(o2.posMatrix, 0, h2, 0, h2, 0, 1), e.J(o2.posMatrix, o2.posMatrix, [-n2 * h2, -l3 * h2, 0]), i2[a2] = o2;
              } else if (t2.canonical.isChildOf(s2.canonical)) {
                const o2 = t2.clone();
                o2.posMatrix = new Float64Array(16);
                const r2 = t2.canonical.z - s2.canonical.z, n2 = t2.canonical.x - (t2.canonical.x >> r2 << r2), l3 = t2.canonical.y - (t2.canonical.y >> r2 << r2), h2 = e.X >> r2;
                e.aP(o2.posMatrix, 0, e.X, 0, e.X, 0, 1), e.J(o2.posMatrix, o2.posMatrix, [n2 * h2, l3 * h2, 0]), e.K(o2.posMatrix, o2.posMatrix, [1 / 2 ** r2, 1 / 2 ** r2, 0]), i2[a2] = o2;
              }
            }
            return i2;
          }
          getSourceTile(t2, e2) {
            const i2 = this.sourceCache._source;
            let a2 = t2.overscaledZ - this.deltaZoom;
            if (a2 > i2.maxzoom && (a2 = i2.maxzoom), a2 < i2.minzoom) return null;
            this._sourceTileCache[t2.key] || (this._sourceTileCache[t2.key] = t2.scaledTo(a2).key);
            let s2 = this.sourceCache.getTileByID(this._sourceTileCache[t2.key]);
            if ((!s2 || !s2.dem) && e2) for (; a2 >= i2.minzoom && (!s2 || !s2.dem); ) s2 = this.sourceCache.getTileByID(t2.scaledTo(a2--).key);
            return s2;
          }
          tilesAfterTime(t2 = Date.now()) {
            return Object.values(this._tiles).filter((e2) => e2.timeAdded >= t2);
          }
        }
        class Ds2 {
          constructor(t2, e2, i2) {
            this.painter = t2, this.sourceCache = new zs2(e2), this.options = i2, this.exaggeration = "number" == typeof i2.exaggeration ? i2.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(t2, i2, a2, s2 = e.X) {
            var o2;
            if (!(i2 >= 0 && i2 < s2 && a2 >= 0 && a2 < s2)) return 0;
            const r2 = this.getTerrainData(t2), n2 = null === (o2 = r2.tile) || void 0 === o2 ? void 0 : o2.dem;
            if (!n2) return 0;
            const l3 = function(t3, e2, i3) {
              var a3 = e2[0], s3 = e2[1];
              return t3[0] = i3[0] * a3 + i3[4] * s3 + i3[12], t3[1] = i3[1] * a3 + i3[5] * s3 + i3[13], t3;
            }([], [i2 / s2 * e.X, a2 / s2 * e.X], r2.u_terrain_matrix), h2 = [l3[0] * n2.dim, l3[1] * n2.dim], c2 = Math.floor(h2[0]), u2 = Math.floor(h2[1]), d2 = h2[0] - c2, _2 = h2[1] - u2;
            return n2.get(c2, u2) * (1 - d2) * (1 - _2) + n2.get(c2 + 1, u2) * d2 * (1 - _2) + n2.get(c2, u2 + 1) * (1 - d2) * _2 + n2.get(c2 + 1, u2 + 1) * d2 * _2;
          }
          getElevationForLngLatZoom(t2, i2) {
            if (!e.bb(i2, t2.wrap())) return 0;
            const { tileID: a2, mercatorX: s2, mercatorY: o2 } = this._getOverscaledTileIDFromLngLatZoom(t2, i2);
            return this.getElevation(a2, s2 % e.X, o2 % e.X, e.X);
          }
          getElevation(t2, i2, a2, s2 = e.X) {
            return this.getDEMElevation(t2, i2, a2, s2) * this.exaggeration;
          }
          getTerrainData(t2) {
            if (!this._emptyDemTexture) {
              const t3 = this.painter.context, i3 = new e.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new b(t3, i3, t3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new b(t3, new e.R({ width: 1, height: 1 }), t3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = e.an([]);
            }
            const i2 = this.sourceCache.getSourceTile(t2, true);
            if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
              const t3 = this.painter.context;
              i2.demTexture = this.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new b(t3, i2.dem.getPixels(), t3.gl.RGBA, { premultiply: false }), i2.demTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
            }
            const a2 = i2 && i2 + i2.tileID.key + t2.key;
            if (a2 && !this._demMatrixCache[a2]) {
              const a3 = this.sourceCache.sourceCache._source.maxzoom;
              let s2 = t2.canonical.z - i2.tileID.canonical.z;
              t2.overscaledZ > t2.canonical.z && (t2.canonical.z >= a3 ? s2 = t2.canonical.z - a3 : e.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const o2 = t2.canonical.x - (t2.canonical.x >> s2 << s2), r2 = t2.canonical.y - (t2.canonical.y >> s2 << s2), n2 = e.bc(new Float64Array(16), [1 / (e.X << s2), 1 / (e.X << s2), 0]);
              e.J(n2, n2, [o2 * e.X, r2 * e.X, 0]), this._demMatrixCache[t2.key] = { matrix: n2, coord: t2 };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: a2 ? this._demMatrixCache[t2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
          }
          getFramebuffer(t2) {
            const e2 = this.painter, i2 = e2.width / devicePixelRatio, a2 = e2.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === i2 && this._fbo.height === a2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new b(e2.context, { width: i2, height: a2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new b(e2.context, { width: i2, height: a2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i2, a2, true, false), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i2, a2))), this._fbo.colorAttachment.set("coords" === t2 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const t2 = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let t3 = 0, e2 = 0; t3 < this._coordsTextureSize; t3++) for (let a3 = 0; a3 < this._coordsTextureSize; a3++, e2 += 4) i2[e2 + 0] = 255 & a3, i2[e2 + 1] = 255 & t3, i2[e2 + 2] = a3 >> 8 << 4 | t3 >> 8, i2[e2 + 3] = 0;
            const a2 = new e.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), s2 = new b(t2, a2, t2.gl.RGBA, { premultiply: false });
            return s2.bind(t2.gl.NEAREST, t2.gl.CLAMP_TO_EDGE), this._coordsTexture = s2, s2;
          }
          pointCoordinate(t2) {
            this.painter.maybeDrawDepthAndCoords(true);
            const i2 = new Uint8Array(4), a2 = this.painter.context, s2 = a2.gl, o2 = Math.round(t2.x * this.painter.pixelRatio / devicePixelRatio), r2 = Math.round(t2.y * this.painter.pixelRatio / devicePixelRatio), n2 = Math.round(this.painter.height / devicePixelRatio);
            a2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), s2.readPixels(o2, n2 - r2 - 1, 1, 1, s2.RGBA, s2.UNSIGNED_BYTE, i2), a2.bindFramebuffer.set(null);
            const l3 = i2[0] + (i2[2] >> 4 << 8), h2 = i2[1] + ((15 & i2[2]) << 8), c2 = this.coordsIndex[255 - i2[3]], u2 = c2 && this.sourceCache.getTileByID(c2);
            if (!u2) return null;
            const d2 = this._coordsTextureSize, _2 = (1 << u2.tileID.canonical.z) * d2;
            return new e.Z((u2.tileID.canonical.x * d2 + l3) / _2 + u2.tileID.wrap, (u2.tileID.canonical.y * d2 + h2) / _2, this.getElevation(u2.tileID, l3, h2, d2));
          }
          depthAtPoint(t2) {
            const e2 = new Uint8Array(4), i2 = this.painter.context, a2 = i2.gl;
            return i2.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), a2.readPixels(t2.x, this.painter.height / devicePixelRatio - t2.y - 1, 1, 1, a2.RGBA, a2.UNSIGNED_BYTE, e2), i2.bindFramebuffer.set(null), (e2[0] / 16777216 + e2[1] / 65536 + e2[2] / 256 + e2[3]) / 256;
          }
          getTerrainMesh() {
            if (this._mesh) return this._mesh;
            const t2 = this.painter.context, i2 = new e.bd(), a2 = new e.aY(), s2 = this.meshSize, o2 = e.X / s2, r2 = s2 * s2;
            for (let t3 = 0; t3 <= s2; t3++) for (let e2 = 0; e2 <= s2; e2++) i2.emplaceBack(e2 * o2, t3 * o2, 0);
            for (let t3 = 0; t3 < r2; t3 += s2 + 1) for (let e2 = 0; e2 < s2; e2++) a2.emplaceBack(e2 + t3, s2 + e2 + t3 + 1, s2 + e2 + t3 + 2), a2.emplaceBack(e2 + t3, s2 + e2 + t3 + 2, e2 + t3 + 1);
            const n2 = i2.length, l3 = n2 + 2 * (s2 + 1);
            for (const t3 of [0, 1]) for (let a3 = 0; a3 <= s2; a3++) for (const s3 of [0, 1]) i2.emplaceBack(a3 * o2, t3 * e.X, s3);
            for (let t3 = 0; t3 < 2 * s2; t3 += 2) a2.emplaceBack(l3 + t3, l3 + t3 + 1, l3 + t3 + 3), a2.emplaceBack(l3 + t3, l3 + t3 + 3, l3 + t3 + 2), a2.emplaceBack(n2 + t3, n2 + t3 + 3, n2 + t3 + 1), a2.emplaceBack(n2 + t3, n2 + t3 + 2, n2 + t3 + 3);
            const h2 = i2.length, c2 = h2 + 2 * (s2 + 1);
            for (const t3 of [0, 1]) for (let a3 = 0; a3 <= s2; a3++) for (const s3 of [0, 1]) i2.emplaceBack(t3 * e.X, a3 * o2, s3);
            for (let t3 = 0; t3 < 2 * s2; t3 += 2) a2.emplaceBack(h2 + t3, h2 + t3 + 1, h2 + t3 + 3), a2.emplaceBack(h2 + t3, h2 + t3 + 3, h2 + t3 + 2), a2.emplaceBack(c2 + t3, c2 + t3 + 3, c2 + t3 + 1), a2.emplaceBack(c2 + t3, c2 + t3 + 2, c2 + t3 + 3);
            return this._mesh = new ga2(t2.createVertexBuffer(i2, Ss2.members), t2.createIndexBuffer(a2), e.a0.simpleSegment(0, 0, i2.length, a2.length)), this._mesh;
          }
          getMeshFrameDelta(t2) {
            return 2 * Math.PI * e.be / Math.pow(2, t2) / 5;
          }
          getMinTileElevationForLngLatZoom(t2, e2) {
            var i2;
            const { tileID: a2 } = this._getOverscaledTileIDFromLngLatZoom(t2, e2);
            return null !== (i2 = this.getMinMaxElevation(a2).minElevation) && void 0 !== i2 ? i2 : 0;
          }
          getMinMaxElevation(t2) {
            const e2 = this.getTerrainData(t2).tile, i2 = { minElevation: null, maxElevation: null };
            return e2 && e2.dem && (i2.minElevation = e2.dem.min * this.exaggeration, i2.maxElevation = e2.dem.max * this.exaggeration), i2;
          }
          _getOverscaledTileIDFromLngLatZoom(t2, i2) {
            const a2 = e.Z.fromLngLat(t2.wrap()), s2 = (1 << i2) * e.X, o2 = a2.x * s2, r2 = a2.y * s2, n2 = Math.floor(o2 / e.X), l3 = Math.floor(r2 / e.X);
            return { tileID: new e.S(i2, 0, i2, n2, l3), mercatorX: o2, mercatorY: r2 };
          }
        }
        class Ms2 {
          constructor(t2, e2, i2) {
            this._context = t2, this._size = e2, this._tileSize = i2, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const t2 of this._objects) t2.texture.destroy(), t2.fbo.destroy();
          }
          _createObject(t2) {
            const e2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i2 = new b(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return i2.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e2.colorAttachment.set(i2.texture), { id: t2, fbo: e2, texture: i2, stamp: -1, inUse: false };
          }
          getObjectForId(t2) {
            return this._objects[t2];
          }
          useObject(t2) {
            t2.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e2) => t2.id !== e2), this._recentlyUsed.push(t2.id);
          }
          stampObject(t2) {
            t2.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const t3 of this._recentlyUsed) if (!this._objects[t3].inUse) return this._objects[t3];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const t2 = this._createObject(this._objects.length);
            return this._objects.push(t2), t2;
          }
          freeObject(t2) {
            t2.inUse = false;
          }
          freeAllObjects() {
            for (const t2 of this._objects) this.freeObject(t2);
          }
          isFull() {
            return !(this._objects.length < this._size) && false === this._objects.some((t2) => !t2.inUse);
          }
        }
        const As2 = { background: true, fill: true, line: true, raster: true, hillshade: true };
        class Rs2 {
          constructor(t2, e2) {
            this.painter = t2, this.terrain = e2, this.pool = new Ms2(t2.context, 30, e2.sourceCache.tileSize * e2.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t2) {
            return this.pool.getObjectForId(t2.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t2, e2) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t2._order.filter((i2) => !t2._layers[i2].isHidden(e2)), this._coordsDescendingInv = {};
            for (const e3 in t2.sourceCaches) {
              this._coordsDescendingInv[e3] = {};
              const i2 = t2.sourceCaches[e3].getVisibleCoordinates();
              for (const t3 of i2) {
                const i3 = this.terrain.sourceCache.getTerrainCoords(t3);
                for (const t4 in i3) this._coordsDescendingInv[e3][t4] || (this._coordsDescendingInv[e3][t4] = []), this._coordsDescendingInv[e3][t4].push(i3[t4]);
              }
            }
            this._coordsDescendingInvStr = {};
            for (const e3 of t2._order) {
              const i2 = t2._layers[e3], a2 = i2.source;
              if (As2[i2.type] && !this._coordsDescendingInvStr[a2]) {
                this._coordsDescendingInvStr[a2] = {};
                for (const t3 in this._coordsDescendingInv[a2]) this._coordsDescendingInvStr[a2][t3] = this._coordsDescendingInv[a2][t3].map((t4) => t4.key).sort().join();
              }
            }
            for (const t3 of this._renderableTiles) for (const e3 in this._coordsDescendingInvStr) {
              const i2 = this._coordsDescendingInvStr[e3][t3.tileID.key];
              i2 && i2 !== t3.rttCoords[e3] && (t3.rtt = []);
            }
          }
          renderLayer(t2) {
            if (t2.isHidden(this.painter.transform.zoom)) return false;
            const i2 = t2.type, a2 = this.painter, s2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t2.id;
            if (As2[i2] && (this._prevType && As2[this._prevType] || this._stacks.push([]), this._prevType = i2, this._stacks[this._stacks.length - 1].push(t2.id), !s2)) return true;
            if (As2[this._prevType] || As2[i2] && s2) {
              this._prevType = i2;
              const t3 = this._stacks.length - 1, s3 = this._stacks[t3] || [];
              for (const i3 of this._renderableTiles) {
                if (this.pool.isFull() && (fa2(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i3), i3.rtt[t3]) {
                  const e2 = this.pool.getObjectForId(i3.rtt[t3].id);
                  if (e2.stamp === i3.rtt[t3].stamp) {
                    this.pool.useObject(e2);
                    continue;
                  }
                }
                const o2 = this.pool.getOrCreateFreeObject();
                this.pool.useObject(o2), this.pool.stampObject(o2), i3.rtt[t3] = { id: o2.id, stamp: o2.stamp }, a2.context.bindFramebuffer.set(o2.fbo.framebuffer), a2.context.clear({ color: e.aM.transparent, stencil: 0 }), a2.currentStencilSource = void 0;
                for (let t4 = 0; t4 < s3.length; t4++) {
                  const e2 = a2.style._layers[s3[t4]], r2 = e2.source ? this._coordsDescendingInv[e2.source][i3.tileID.key] : [i3.tileID];
                  a2.context.viewport.set([0, 0, o2.fbo.width, o2.fbo.height]), a2._renderTileClippingMasks(e2, r2), a2.renderLayer(a2, a2.style.sourceCaches[e2.source], e2, r2), e2.source && (i3.rttCoords[e2.source] = this._coordsDescendingInvStr[e2.source][i3.tileID.key]);
                }
              }
              return fa2(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), As2[i2];
            }
            return false;
          }
        }
        const ks2 = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Ls2 = i, Fs2 = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Is2, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, refreshExpiredTiles: true, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: e.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true }, Bs2 = (t2) => {
          t2.touchstart = t2.dragStart, t2.touchmoveWindow = t2.dragMove, t2.touchend = t2.dragEnd;
        }, Os2 = { showCompass: true, showZoom: true, visualizePitch: false };
        class Ns2 {
          constructor(t2, i2, a2 = false) {
            this.mousedown = (t3) => {
              this.startMouse(e.e({}, t3, { ctrlKey: true, preventDefault: () => t3.preventDefault() }), r.mousePos(this.element, t3)), r.addEventListener(window, "mousemove", this.mousemove), r.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (t3) => {
              this.moveMouse(t3, r.mousePos(this.element, t3));
            }, this.mouseup = (t3) => {
              this.mouseRotate.dragEnd(t3), this.mousePitch && this.mousePitch.dragEnd(t3), this.offTemp();
            }, this.touchstart = (t3) => {
              1 !== t3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = r.touchPos(this.element, t3.targetTouches)[0], this.startTouch(t3, this._startPos), r.addEventListener(window, "touchmove", this.touchmove, { passive: false }), r.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (t3) => {
              1 !== t3.targetTouches.length ? this.reset() : (this._lastPos = r.touchPos(this.element, t3.targetTouches)[0], this.moveTouch(t3, this._lastPos));
            }, this.touchend = (t3) => {
              0 === t3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10;
            const s2 = t2.dragRotate._mouseRotate.getClickTolerance(), o2 = t2.dragRotate._mousePitch.getClickTolerance();
            this.element = i2, this.mouseRotate = Ka2({ clickTolerance: s2, enable: true }), this.touchRotate = (({ enable: t3, clickTolerance: e2, bearingDegreesPerPixelMoved: i3 = 0.8 }) => {
              const a3 = new $a2();
              return new Ga2({ clickTolerance: e2, move: (t4, e3) => ({ bearingDelta: (e3.x - t4.x) * i3 }), moveStateManager: a3, enable: t3, assignEvents: Bs2 });
            })({ clickTolerance: s2, enable: true }), this.map = t2, a2 && (this.mousePitch = Ja2({ clickTolerance: o2, enable: true }), this.touchPitch = (({ enable: t3, clickTolerance: e2, pitchDegreesPerPixelMoved: i3 = -0.5 }) => {
              const a3 = new $a2();
              return new Ga2({ clickTolerance: e2, move: (t4, e3) => ({ pitchDelta: (e3.y - t4.y) * i3 }), moveStateManager: a3, enable: t3, assignEvents: Bs2 });
            })({ clickTolerance: o2, enable: true })), r.addEventListener(i2, "mousedown", this.mousedown), r.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), r.addEventListener(i2, "touchcancel", this.reset);
          }
          startMouse(t2, e2) {
            this.mouseRotate.dragStart(t2, e2), this.mousePitch && this.mousePitch.dragStart(t2, e2), r.disableDrag();
          }
          startTouch(t2, e2) {
            this.touchRotate.dragStart(t2, e2), this.touchPitch && this.touchPitch.dragStart(t2, e2), r.disableDrag();
          }
          moveMouse(t2, e2) {
            const i2 = this.map, { bearingDelta: a2 } = this.mouseRotate.dragMove(t2, e2) || {};
            if (a2 && i2.setBearing(i2.getBearing() + a2), this.mousePitch) {
              const { pitchDelta: a3 } = this.mousePitch.dragMove(t2, e2) || {};
              a3 && i2.setPitch(i2.getPitch() + a3);
            }
          }
          moveTouch(t2, e2) {
            const i2 = this.map, { bearingDelta: a2 } = this.touchRotate.dragMove(t2, e2) || {};
            if (a2 && i2.setBearing(i2.getBearing() + a2), this.touchPitch) {
              const { pitchDelta: a3 } = this.touchPitch.dragMove(t2, e2) || {};
              a3 && i2.setPitch(i2.getPitch() + a3);
            }
          }
          off() {
            const t2 = this.element;
            r.removeEventListener(t2, "mousedown", this.mousedown), r.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), r.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), r.removeEventListener(window, "touchend", this.touchend), r.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            r.enableDrag(), r.removeEventListener(window, "mousemove", this.mousemove), r.removeEventListener(window, "mouseup", this.mouseup), r.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), r.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Us2;
        function js2(t2, i2, a2) {
          const s2 = new e.N(t2.lng, t2.lat);
          if (t2 = new e.N(t2.lng, t2.lat), i2) {
            const s3 = new e.N(t2.lng - 360, t2.lat), o2 = new e.N(t2.lng + 360, t2.lat), r2 = a2.locationPoint(t2).distSqr(i2);
            a2.locationPoint(s3).distSqr(i2) < r2 ? t2 = s3 : a2.locationPoint(o2).distSqr(i2) < r2 && (t2 = o2);
          }
          for (; Math.abs(t2.lng - a2.center.lng) > 180; ) {
            const e2 = a2.locationPoint(t2);
            if (e2.x >= 0 && e2.y >= 0 && e2.x <= a2.width && e2.y <= a2.height) break;
            t2.lng > a2.center.lng ? t2.lng -= 360 : t2.lng += 360;
          }
          return t2.lng !== s2.lng && a2.locationPoint(t2).y > a2.height / 2 - a2.getHorizon() ? t2 : s2;
        }
        const Zs2 = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function qs2(t2, e2, i2) {
          const a2 = t2.classList;
          for (const t3 in Zs2) a2.remove("maplibregl-".concat(i2, "-anchor-").concat(t3));
          a2.add("maplibregl-".concat(i2, "-anchor-").concat(e2));
        }
        class Vs2 extends e.E {
          constructor(t2) {
            if (super(), this._onKeyPress = (t3) => {
              const e2 = t3.code, i2 = t3.charCode || t3.keyCode;
              "Space" !== e2 && "Enter" !== e2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
            }, this._onMapClick = (t3) => {
              const e2 = t3.originalEvent.target, i2 = this._element;
              this._popup && (e2 === i2 || i2.contains(e2)) && this.togglePopup();
            }, this._update = (t3) => {
              var e2;
              if (!this._map) return;
              const i2 = this._map.loaded() && !this._map.isMoving();
              ("terrain" === (null == t3 ? void 0 : t3.type) || "render" === (null == t3 ? void 0 : t3.type) && !i2) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? js2(this._lngLat, this._flatPos, this._map.transform) : null === (e2 = this._lngLat) || void 0 === e2 ? void 0 : e2.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
              let a2 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? a2 = "rotateZ(".concat(this._rotation, "deg)") : "map" === this._rotationAlignment && (a2 = "rotateZ(".concat(this._rotation - this._map.getBearing(), "deg)"));
              let s2 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? s2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (s2 = "rotateX(".concat(this._map.getPitch(), "deg)")), this._subpixelPositioning || t3 && "moveend" !== t3.type || (this._pos = this._pos.round()), r.setTransform(this._element, "".concat(Zs2[this._anchor], " translate(").concat(this._pos.x, "px, ").concat(this._pos.y, "px) ").concat(s2, " ").concat(a2)), o.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(t3 && "moveend" === t3.type);
              }).catch(() => {
              });
            }, this._onMove = (t3) => {
              if (!this._isDragging) {
                const e2 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = t3.point.dist(this._pointerdownPos) >= e2;
              }
              this._isDragging && (this._pos = t3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.k("dragstart"))), this.fire(new e.k("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new e.k("dragend")), this._state = "inactive";
            }, this._addDragHandler = (t3) => {
              this._element.contains(t3.originalEvent.target) && (t3.preventDefault(), this._positionDelta = t3.point.sub(this._pos).add(this._offset), this._pointerdownPos = t3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._subpixelPositioning = t2 && t2.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && "auto" !== t2.pitchAlignment ? t2.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(null == t2 ? void 0 : t2.opacity, null == t2 ? void 0 : t2.opacityWhenCovered), t2 && t2.element) this._element = t2.element, this._offset = e.P.convert(t2 && t2.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = r.create("div");
              const i2 = r.createNS("http://www.w3.org/2000/svg", "svg"), a2 = 41, s2 = 27;
              i2.setAttributeNS(null, "display", "block"), i2.setAttributeNS(null, "height", "".concat(a2, "px")), i2.setAttributeNS(null, "width", "".concat(s2, "px")), i2.setAttributeNS(null, "viewBox", "0 0 ".concat(s2, " ").concat(a2));
              const o2 = r.createNS("http://www.w3.org/2000/svg", "g");
              o2.setAttributeNS(null, "stroke", "none"), o2.setAttributeNS(null, "stroke-width", "1"), o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "fill-rule", "evenodd");
              const n2 = r.createNS("http://www.w3.org/2000/svg", "g");
              n2.setAttributeNS(null, "fill-rule", "nonzero");
              const l3 = r.createNS("http://www.w3.org/2000/svg", "g");
              l3.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l3.setAttributeNS(null, "fill", "#000000");
              const h2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const t3 of h2) {
                const e2 = r.createNS("http://www.w3.org/2000/svg", "ellipse");
                e2.setAttributeNS(null, "opacity", "0.04"), e2.setAttributeNS(null, "cx", "10.5"), e2.setAttributeNS(null, "cy", "5.80029008"), e2.setAttributeNS(null, "rx", t3.rx), e2.setAttributeNS(null, "ry", t3.ry), l3.appendChild(e2);
              }
              const c2 = r.createNS("http://www.w3.org/2000/svg", "g");
              c2.setAttributeNS(null, "fill", this._color);
              const u2 = r.createNS("http://www.w3.org/2000/svg", "path");
              u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c2.appendChild(u2);
              const d2 = r.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
              const _2 = r.createNS("http://www.w3.org/2000/svg", "path");
              _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
              const p2 = r.createNS("http://www.w3.org/2000/svg", "g");
              p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
              const m2 = r.createNS("http://www.w3.org/2000/svg", "g");
              m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const f2 = r.createNS("http://www.w3.org/2000/svg", "circle");
              f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
              const g2 = r.createNS("http://www.w3.org/2000/svg", "circle");
              g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), n2.appendChild(l3), n2.appendChild(c2), n2.appendChild(d2), n2.appendChild(p2), n2.appendChild(m2), i2.appendChild(n2), i2.setAttributeNS(null, "height", a2 * this._scale + "px"), i2.setAttributeNS(null, "width", s2 * this._scale + "px"), this._element.appendChild(i2), this._offset = e.P.convert(t2 && t2.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t3) => {
              t3.preventDefault();
            }), this._element.addEventListener("mousedown", (t3) => {
              t3.preventDefault();
            }), qs2(this._element, this._anchor, "marker"), t2 && t2.className) for (const e2 of t2.className.split(" ")) this._element.classList.add(e2);
            this._popup = null;
          }
          addTo(t2) {
            return this.remove(), this._map = t2, this._element.setAttribute("aria-label", t2._getUIString("Marker.Title")), t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), t2.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), r.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            return this._lngLat = e.N.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
              if (!("offset" in t2.options)) {
                const e2 = 38.1, i2 = 13.5, a2 = Math.abs(i2) / Math.SQRT2;
                t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e2], "bottom-left": [a2, -1 * (e2 - i2 + a2)], "bottom-right": [-a2, -1 * (e2 - i2 + a2)], left: [i2, -1 * (e2 - i2)], right: [-i2, -1 * (e2 - i2)] } : this._offset;
              }
              this._popup = t2, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(t2) {
            return this._subpixelPositioning = t2, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t2 = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : t2 ? (t2.isOpen() ? t2.remove() : (t2.setLngLat(this._lngLat), t2.addTo(this._map)), this) : this;
          }
          _updateOpacity(t2 = false) {
            var i2, a2;
            if (!(null === (i2 = this._map) || void 0 === i2 ? void 0 : i2.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
            if (t2) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const s2 = this._map, o2 = s2.terrain.depthAtPoint(this._pos), r2 = s2.terrain.getElevationForLngLatZoom(this._lngLat, s2.transform.tileZoom);
            if (s2.transform.lngLatToCameraDepth(this._lngLat, r2) - o2 < 6e-3) return void (this._element.style.opacity = this._opacity);
            const n2 = -this._offset.y / s2.transform._pixelPerMeter, l3 = Math.sin(s2.getPitch() * Math.PI / 180) * n2, h2 = s2.terrain.depthAtPoint(new e.P(this._pos.x, this._pos.y - this._offset.y)), c2 = s2.transform.lngLatToCameraDepth(this._lngLat, r2 + l3) - h2 > 6e-3;
            (null === (a2 = this._popup) || void 0 === a2 ? void 0 : a2.isOpen()) && c2 && this._popup.remove(), this._element.style.opacity = c2 ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t2) {
            return this._offset = e.P.convert(t2), this._update(), this;
          }
          addClassName(t2) {
            this._element.classList.add(t2);
          }
          removeClassName(t2) {
            this._element.classList.remove(t2);
          }
          toggleClassName(t2) {
            return this._element.classList.toggle(t2);
          }
          setDraggable(t2) {
            return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t2) {
            return this._rotation = t2 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t2) {
            return this._rotationAlignment = t2 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t2) {
            return this._pitchAlignment = t2 && "auto" !== t2 ? t2 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(t2, e2) {
            return void 0 === t2 && void 0 === e2 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== t2 && (this._opacity = t2), void 0 !== e2 && (this._opacityWhenCovered = e2), this._map && this._updateOpacity(true), this;
          }
        }
        const Gs2 = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let Hs2 = 0, Ws2 = false;
        const $s2 = { maxWidth: 100, unit: "metric" };
        function Xs2(t2, e2, i2) {
          const a2 = i2 && i2.maxWidth || 100, s2 = t2._container.clientHeight / 2, o2 = t2.unproject([0, s2]), r2 = t2.unproject([a2, s2]), n2 = o2.distanceTo(r2);
          if (i2 && "imperial" === i2.unit) {
            const i3 = 3.2808 * n2;
            i3 > 5280 ? Ks2(e2, a2, i3 / 5280, t2._getUIString("ScaleControl.Miles")) : Ks2(e2, a2, i3, t2._getUIString("ScaleControl.Feet"));
          } else i2 && "nautical" === i2.unit ? Ks2(e2, a2, n2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1e3 ? Ks2(e2, a2, n2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : Ks2(e2, a2, n2, t2._getUIString("ScaleControl.Meters"));
        }
        function Ks2(t2, e2, i2, a2) {
          const s2 = function(t3) {
            const e3 = Math.pow(10, "".concat(Math.floor(t3)).length - 1);
            let i3 = t3 / e3;
            return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
              const e4 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
              return Math.round(t4 * e4) / e4;
            }(i3), e3 * i3;
          }(i2);
          t2.style.width = e2 * (s2 / i2) + "px", t2.innerHTML = "".concat(s2, "&nbsp;").concat(a2);
        }
        const Js2 = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false }, Ys2 = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Qs2(t2) {
          if (t2) {
            if ("number" == typeof t2) {
              const i2 = Math.round(Math.abs(t2) / Math.SQRT2);
              return { center: new e.P(0, 0), top: new e.P(0, t2), "top-left": new e.P(i2, i2), "top-right": new e.P(-i2, i2), bottom: new e.P(0, -t2), "bottom-left": new e.P(i2, -i2), "bottom-right": new e.P(-i2, -i2), left: new e.P(t2, 0), right: new e.P(-t2, 0) };
            }
            if (t2 instanceof e.P || Array.isArray(t2)) {
              const i2 = e.P.convert(t2);
              return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
            }
            return { center: e.P.convert(t2.center || [0, 0]), top: e.P.convert(t2.top || [0, 0]), "top-left": e.P.convert(t2["top-left"] || [0, 0]), "top-right": e.P.convert(t2["top-right"] || [0, 0]), bottom: e.P.convert(t2.bottom || [0, 0]), "bottom-left": e.P.convert(t2["bottom-left"] || [0, 0]), "bottom-right": e.P.convert(t2["bottom-right"] || [0, 0]), left: e.P.convert(t2.left || [0, 0]), right: e.P.convert(t2.right || [0, 0]) };
          }
          return Qs2(new e.P(0, 0));
        }
        const to2 = i;
        t.AJAXError = e.bh, t.Evented = e.E, t.LngLat = e.N, t.MercatorCoordinate = e.Z, t.Point = e.P, t.addProtocol = e.bi, t.config = e.a, t.removeProtocol = e.bj, t.AttributionControl = Es2, t.BoxZoomHandler = Ua2, t.CanvasSource = et2, t.CooperativeGesturesHandler = vs2, t.DoubleClickZoomHandler = ds2, t.DragPanHandler = ms2, t.DragRotateHandler = fs2, t.EdgeInsets = ba2, t.FullscreenControl = class extends e.E {
          constructor(t2 = {}) {
            super(), this._onFullscreenChange = () => {
              var t3;
              let e2 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; null === (t3 = null == e2 ? void 0 : e2.shadowRoot) || void 0 === t3 ? void 0 : t3.fullscreenElement; ) e2 = e2.shadowRoot.fullscreenElement;
              e2 === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, t2 && t2.container && (t2.container instanceof HTMLElement ? this._container = t2.container : e.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(t2) {
            return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            r.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const t2 = this._fullscreenButton = r.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            r.create("span", "maplibregl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const t2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new e.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new e.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, t.GeoJSONSource = J2, t.GeolocateControl = class extends e.E {
          constructor(t2) {
            super(), this._onSuccess = (t3) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t3)) return this._setErrorState(), this.fire(new e.k("outofmaxbounds", t3)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = t3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error("Unexpected watchState ".concat(this._watchState));
                }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new e.k("geolocate", t3)), this._finish();
              }
            }, this._updateCamera = (t3) => {
              const i2 = new e.N(t3.coords.longitude, t3.coords.latitude), a2 = t3.coords.accuracy, s2 = this._map.getBearing(), o2 = e.e({ bearing: s2 }, this.options.fitBoundsOptions), r2 = H.fromLngLat(i2, a2);
              this._map.fitBounds(r2, o2, { geolocateSource: true });
            }, this._updateMarker = (t3) => {
              if (t3) {
                const i2 = new e.N(t3.coords.longitude, t3.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (t3) => {
              if (this._map) {
                if (this.options.trackUserLocation) if (1 === t3.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === t3.code && Ws2) return;
                  this._setErrorState();
                }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new e.k("error", t3)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this._geolocateButton = r.create("button", "maplibregl-ctrl-geolocate", this._container), r.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (t3) => {
              if (this._map) {
                if (false === t3) {
                  e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
                } else {
                  const t4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = r.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Vs2({ element: this._dotElement }), this._circleElement = r.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Vs2({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t4) => {
                  t4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t4.originalEvent && "resize" === t4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new e.k("trackuserlocationend")), this.fire(new e.k("userlocationlostfocus")));
                });
              }
            }, this.options = e.e({}, Gs2, t2);
          }
          onAdd(t2) {
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
              return e._(this, arguments, void 0, function* (t3 = false) {
                if (void 0 !== Us2 && !t3) return Us2;
                if (void 0 === window.navigator.permissions) return Us2 = !!window.navigator.geolocation, Us2;
                try {
                  const t4 = yield window.navigator.permissions.query({ name: "geolocation" });
                  Us2 = "denied" !== t4.state;
                } catch (t4) {
                  Us2 = !!window.navigator.geolocation;
                }
                return Us2;
              });
            }().then((t3) => this._finishSetupUI(t3)), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), r.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Hs2 = 0, Ws2 = false;
          }
          _isOutOfMapMaxBounds(t2) {
            const e2 = this._map.getMaxBounds(), i2 = t2.coords;
            return e2 && (i2.longitude < e2.getWest() || i2.longitude > e2.getEast() || i2.latitude < e2.getSouth() || i2.latitude > e2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error("Unexpected watchState ".concat(this._watchState));
            }
          }
          _updateCircleRadius() {
            const t2 = this._map.getBounds(), e2 = t2.getSouthEast(), i2 = t2.getNorthEast(), a2 = e2.distanceTo(i2), s2 = Math.ceil(this._accuracy / (a2 / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = "".concat(s2, "px"), this._circleElement.style.height = "".concat(s2, "px");
          }
          trigger() {
            if (!this._setup) return e.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e.k("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Hs2--, Ws2 = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new e.k("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.k("trackuserlocationstart")), this.fire(new e.k("userlocationfocus"));
                  break;
                default:
                  throw new Error("Unexpected watchState ".concat(this._watchState));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error("Unexpected watchState ".concat(this._watchState));
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let t2;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Hs2++, Hs2 > 1 ? (t2 = { maximumAge: 6e5, timeout: 0 }, Ws2 = true) : (t2 = this.options.positionOptions, Ws2 = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, t.Hash = Ea2, t.ImageSource = Q2, t.KeyboardHandler = ls2, t.LngLatBounds = H, t.LogoControl = Ps2, t.Map = class extends Ts2 {
          constructor(t2) {
            e.bf.mark(e.bg.create);
            const i2 = Object.assign(Object.assign({}, Fs2), t2);
            if (null != i2.minZoom && null != i2.maxZoom && i2.minZoom > i2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != i2.minPitch && null != i2.maxPitch && i2.minPitch > i2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != i2.minPitch && i2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (null != i2.maxPitch && i2.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (super(new Ta2(i2.minZoom, i2.maxZoom, i2.minPitch, i2.maxPitch, i2.renderWorldCopies), { bearingSnap: i2.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Cs2(), this._controls = [], this._mapId = e.a4(), this._contextLost = (t3) => {
              t3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new e.k("webglcontextlost", { originalEvent: t3 }));
            }, this._contextRestored = (t3) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new e.k("webglcontextrestored", { originalEvent: t3 }));
            }, this._onMapScroll = (t3) => {
              if (t3.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = i2.interactive, this._maxTileCacheSize = i2.maxTileCacheSize, this._maxTileCacheZoomLevels = i2.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = true === i2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = true === i2.preserveDrawingBuffer, this._antialias = true === i2.antialias, this._trackResize = true === i2.trackResize, this._bearingSnap = i2.bearingSnap, this._refreshExpiredTiles = true === i2.refreshExpiredTiles, this._fadeDuration = i2.fadeDuration, this._crossSourceCollisions = true === i2.crossSourceCollisions, this._collectResourceTiming = true === i2.collectResourceTiming, this._locale = Object.assign(Object.assign({}, ks2), i2.locale), this._clickTolerance = i2.clickTolerance, this._overridePixelRatio = i2.pixelRatio, this._maxCanvasSize = i2.maxCanvasSize, this.transformCameraUpdate = i2.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = true === i2.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = _.addThrottleControl(() => this.isMoving()), this._requestManager = new p(i2.transformRequest), "string" == typeof i2.container) {
              if (this._container = document.getElementById(i2.container), !this._container) throw new Error("Container '".concat(i2.container, "' not found."));
            } else {
              if (!(i2.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = i2.container;
            }
            if (i2.maxBounds && this.setMaxBounds(i2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)).on("moveend", () => this._update(false)).on("zoom", () => this._update(true)).on("terrain", () => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            }).once("idle", () => {
              this._idleTriggered = true;
            }), "undefined" != typeof window) {
              addEventListener("online", this._onWindowOnline, false);
              let t3 = false;
              const e2 = Ia2((t4) => {
                this._trackResize && !this._removed && (this.resize(t4), this.redraw());
              }, 50);
              this._resizeObserver = new ResizeObserver((i3) => {
                t3 ? e2(i3) : t3 = true;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new ws2(this, i2), this._hash = i2.hash && new Ea2("string" == typeof i2.hash && i2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: i2.center, zoom: i2.zoom, bearing: i2.bearing, pitch: i2.pitch }), i2.bounds && (this.resize(), this.fitBounds(i2.bounds, e.e({}, i2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = i2.localIdeographFontFamily, this._validateStyle = i2.validateStyle, i2.style && this.setStyle(i2.style, { localIdeographFontFamily: i2.localIdeographFontFamily }), i2.attributionControl && this.addControl(new Es2("boolean" == typeof i2.attributionControl ? void 0 : i2.attributionControl)), i2.maplibreLogo && this.addControl(new Ps2(), i2.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (t3) => {
              this._update("style" === t3.dataType), this.fire(new e.k("".concat(t3.dataType, "data"), t3));
            }), this.on("dataloading", (t3) => {
              this.fire(new e.k("".concat(t3.dataType, "dataloading"), t3));
            }), this.on("dataabort", (t3) => {
              this.fire(new e.k("sourcedataabort", t3));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t2, i2) {
            if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd) return this.fire(new e.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a2 = t2.onAdd(this);
            this._controls.push(t2);
            const s2 = this._controlPositions[i2];
            return -1 !== i2.indexOf("bottom") ? s2.insertBefore(a2, s2.firstChild) : s2.appendChild(a2), this;
          }
          removeControl(t2) {
            if (!t2 || !t2.onRemove) return this.fire(new e.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i2 = this._controls.indexOf(t2);
            return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
          }
          hasControl(t2) {
            return this._controls.indexOf(t2) > -1;
          }
          calculateCameraOptionsFromTo(t2, e2, i2, a2) {
            return null == a2 && this.terrain && (a2 = this.terrain.getElevationForLngLatZoom(i2, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t2, e2, i2, a2);
          }
          resize(t2) {
            var i2;
            const a2 = this._containerDimensions(), s2 = a2[0], o2 = a2[1], r2 = this._getClampedPixelRatio(s2, o2);
            if (this._resizeCanvas(s2, o2, r2), this.painter.resize(s2, o2, r2), this.painter.overLimit()) {
              const t3 = this.painter.context.gl;
              this._maxCanvasSize = [t3.drawingBufferWidth, t3.drawingBufferHeight];
              const e2 = this._getClampedPixelRatio(s2, o2);
              this._resizeCanvas(s2, o2, e2), this.painter.resize(s2, o2, e2);
            }
            this.transform.resize(s2, o2), null === (i2 = this._requestedCameraState) || void 0 === i2 || i2.resize(s2, o2);
            const n2 = !this._moving;
            return n2 && (this.stop(), this.fire(new e.k("movestart", t2)).fire(new e.k("move", t2))), this.fire(new e.k("resize", t2)), n2 && this.fire(new e.k("moveend", t2)), this;
          }
          _getClampedPixelRatio(t2, e2) {
            const { 0: i2, 1: a2 } = this._maxCanvasSize, s2 = this.getPixelRatio(), o2 = t2 * s2, r2 = e2 * s2;
            return Math.min(o2 > i2 ? i2 / o2 : 1, r2 > a2 ? a2 / r2 : 1) * s2;
          }
          getPixelRatio() {
            var t2;
            return null !== (t2 = this._overridePixelRatio) && void 0 !== t2 ? t2 : devicePixelRatio;
          }
          setPixelRatio(t2) {
            this._overridePixelRatio = t2, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(t2) {
            return this.transform.setMaxBounds(H.convert(t2)), this._update();
          }
          setMinZoom(t2) {
            if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom) return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t2) {
            if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom) return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t2) {
            if ((t2 = null == t2 ? 0 : t2) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (t2 >= 0 && t2 <= this.transform.maxPitch) return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t2) {
            if ((t2 = null == t2 ? 60 : t2) > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (t2 >= this.transform.minPitch) return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(t2) {
            return this.transform.renderWorldCopies = t2, this._update();
          }
          project(t2) {
            return this.transform.locationPoint(e.N.convert(t2), this.style && this.terrain);
          }
          unproject(t2) {
            return this.transform.pointLocation(e.P.convert(t2), this.terrain);
          }
          isMoving() {
            var t2;
            return this._moving || (null === (t2 = this.handlers) || void 0 === t2 ? void 0 : t2.isMoving());
          }
          isZooming() {
            var t2;
            return this._zooming || (null === (t2 = this.handlers) || void 0 === t2 ? void 0 : t2.isZooming());
          }
          isRotating() {
            var t2;
            return this._rotating || (null === (t2 = this.handlers) || void 0 === t2 ? void 0 : t2.isRotating());
          }
          _createDelegatedListener(t2, e2, i2) {
            if ("mouseenter" === t2 || "mouseover" === t2) {
              let a2 = false;
              const s2 = (s3) => {
                const o2 = e2.filter((t3) => this.getLayer(t3)), r2 = 0 !== o2.length ? this.queryRenderedFeatures(s3.point, { layers: o2 }) : [];
                r2.length ? a2 || (a2 = true, i2.call(this, new ka2(t2, this, s3.originalEvent, { features: r2 }))) : a2 = false;
              };
              return { layers: e2, listener: i2, delegates: { mousemove: s2, mouseout: () => {
                a2 = false;
              } } };
            }
            if ("mouseleave" === t2 || "mouseout" === t2) {
              let a2 = false;
              const s2 = (s3) => {
                const o3 = e2.filter((t3) => this.getLayer(t3));
                (0 !== o3.length ? this.queryRenderedFeatures(s3.point, { layers: o3 }) : []).length ? a2 = true : a2 && (a2 = false, i2.call(this, new ka2(t2, this, s3.originalEvent)));
              }, o2 = (e3) => {
                a2 && (a2 = false, i2.call(this, new ka2(t2, this, e3.originalEvent)));
              };
              return { layers: e2, listener: i2, delegates: { mousemove: s2, mouseout: o2 } };
            }
            {
              const a2 = (t3) => {
                const a3 = e2.filter((t4) => this.getLayer(t4)), s2 = 0 !== a3.length ? this.queryRenderedFeatures(t3.point, { layers: a3 }) : [];
                s2.length && (t3.features = s2, i2.call(this, t3), delete t3.features);
              };
              return { layers: e2, listener: i2, delegates: { [t2]: a2 } };
            }
          }
          _saveDelegatedListener(t2, e2) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(e2);
          }
          _removeDelegatedListener(t2, e2, i2) {
            if (!this._delegatedListeners || !this._delegatedListeners[t2]) return;
            const a2 = this._delegatedListeners[t2];
            for (let t3 = 0; t3 < a2.length; t3++) {
              const s2 = a2[t3];
              if (s2.listener === i2 && s2.layers.length === e2.length && s2.layers.every((t4) => e2.includes(t4))) {
                for (const t4 in s2.delegates) this.off(t4, s2.delegates[t4]);
                return void a2.splice(t3, 1);
              }
            }
          }
          on(t2, e2, i2) {
            if (void 0 === i2) return super.on(t2, e2);
            const a2 = this._createDelegatedListener(t2, "string" == typeof e2 ? [e2] : e2, i2);
            this._saveDelegatedListener(t2, a2);
            for (const t3 in a2.delegates) this.on(t3, a2.delegates[t3]);
            return this;
          }
          once(t2, e2, i2) {
            if (void 0 === i2) return super.once(t2, e2);
            const a2 = "string" == typeof e2 ? [e2] : e2, s2 = this._createDelegatedListener(t2, a2, i2);
            for (const e3 in s2.delegates) {
              const o2 = s2.delegates[e3];
              s2.delegates[e3] = (...e4) => {
                this._removeDelegatedListener(t2, a2, i2), o2(...e4);
              };
            }
            this._saveDelegatedListener(t2, s2);
            for (const t3 in s2.delegates) this.once(t3, s2.delegates[t3]);
            return this;
          }
          off(t2, e2, i2) {
            return void 0 === i2 ? super.off(t2, e2) : (this._removeDelegatedListener(t2, "string" == typeof e2 ? [e2] : e2, i2), this);
          }
          queryRenderedFeatures(t2, i2) {
            if (!this.style) return [];
            let a2;
            const s2 = t2 instanceof e.P || Array.isArray(t2), o2 = s2 ? t2 : [[0, 0], [this.transform.width, this.transform.height]];
            if (i2 = i2 || (s2 ? {} : t2) || {}, o2 instanceof e.P || "number" == typeof o2[0]) a2 = [e.P.convert(o2)];
            else {
              const t3 = e.P.convert(o2[0]), i3 = e.P.convert(o2[1]);
              a2 = [t3, new e.P(i3.x, t3.y), i3, new e.P(t3.x, i3.y), t3];
            }
            return this.style.queryRenderedFeatures(a2, i2, this.transform);
          }
          querySourceFeatures(t2, e2) {
            return this.style.querySourceFeatures(t2, e2);
          }
          setStyle(t2, i2) {
            return false !== (i2 = e.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(t2, i2));
          }
          setTransformRequest(t2) {
            return this._requestManager.setTransformRequest(t2), this;
          }
          _getUIString(t2) {
            const e2 = this._locale[t2];
            if (null == e2) throw new Error("Missing UI string '".concat(t2, "'"));
            return e2;
          }
          _updateStyle(t2, e2) {
            if (e2.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(t2, e2));
            const i2 = this.style && e2.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!t2)), t2 ? (this.style = new de2(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t2 ? this.style.loadURL(t2, e2, i2) : this.style.loadJSON(t2, e2, i2), this) : (delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new de2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(t2, i2) {
            if ("string" == typeof t2) {
              const a2 = this._requestManager.transformRequest(t2, "Style");
              e.h(a2, new AbortController()).then((t3) => {
                this._updateDiff(t3.data, i2);
              }).catch((t3) => {
                t3 && this.fire(new e.j(t3));
              });
            } else "object" == typeof t2 && this._updateDiff(t2, i2);
          }
          _updateDiff(t2, i2) {
            try {
              this.style.setState(t2, i2) && this._update(true);
            } catch (a2) {
              e.w("Unable to perform style diff: ".concat(a2.message || a2.error || a2, ".  Rebuilding the style from scratch.")), this._updateStyle(t2, i2);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : e.w("There is no style added to the map.");
          }
          addSource(t2, e2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
          }
          isSourceLoaded(t2) {
            const i2 = this.style && this.style.sourceCaches[t2];
            if (void 0 !== i2) return i2.loaded();
            this.fire(new e.j(new Error("There is no source with ID '".concat(t2, "'"))));
          }
          setTerrain(t2) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), t2) {
              const i2 = this.style.sourceCaches[t2.source];
              if (!i2) throw new Error("cannot load terrain, because there exists no source with ID: ".concat(t2.source));
              null === this.terrain && i2.reload();
              for (const i3 in this.style._layers) {
                const a2 = this.style._layers[i3];
                "hillshade" === a2.type && a2.source === t2.source && e.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new Ds2(this.painter, i2, t2), this.painter.renderToTexture = new Rs2(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (e2) => {
                "style" === e2.dataType ? this.terrain.sourceCache.freeRtt() : "source" === e2.dataType && e2.tile && (e2.sourceId !== t2.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(e2.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
            return this.fire(new e.k("terrain", { terrain: t2 })), this;
          }
          getTerrain() {
            var t2, e2;
            return null !== (e2 = null === (t2 = this.terrain) || void 0 === t2 ? void 0 : t2.options) && void 0 !== e2 ? e2 : null;
          }
          areTilesLoaded() {
            const t2 = this.style && this.style.sourceCaches;
            for (const e2 in t2) {
              const i2 = t2[e2]._tiles;
              for (const t3 in i2) {
                const e3 = i2[t3];
                if ("loaded" !== e3.state && "errored" !== e3.state) return false;
              }
            }
            return true;
          }
          removeSource(t2) {
            return this.style.removeSource(t2), this._update(true);
          }
          getSource(t2) {
            return this.style.getSource(t2);
          }
          addImage(t2, i2, a2 = {}) {
            const { pixelRatio: s2 = 1, sdf: r2 = false, stretchX: n2, stretchY: l3, content: h2, textFitWidth: c2, textFitHeight: u2 } = a2;
            if (this._lazyInitEmptyStyle(), !(i2 instanceof HTMLImageElement || e.b(i2))) {
              if (void 0 === i2.width || void 0 === i2.height) return this.fire(new e.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: a3, height: o2, data: d2 } = i2, _2 = i2;
                return this.style.addImage(t2, { data: new e.R({ width: a3, height: o2 }, new Uint8Array(d2)), pixelRatio: s2, stretchX: n2, stretchY: l3, content: h2, textFitWidth: c2, textFitHeight: u2, sdf: r2, version: 0, userImage: _2 }), _2.onAdd && _2.onAdd(this, t2), this;
              }
            }
            {
              const { width: a3, height: d2, data: _2 } = o.getImageData(i2);
              this.style.addImage(t2, { data: new e.R({ width: a3, height: d2 }, _2), pixelRatio: s2, stretchX: n2, stretchY: l3, content: h2, textFitWidth: c2, textFitHeight: u2, sdf: r2, version: 0 });
            }
          }
          updateImage(t2, i2) {
            const a2 = this.style.getImage(t2);
            if (!a2) return this.fire(new e.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const s2 = i2 instanceof HTMLImageElement || e.b(i2) ? o.getImageData(i2) : i2, { width: r2, height: n2, data: l3 } = s2;
            if (void 0 === r2 || void 0 === n2) return this.fire(new e.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (r2 !== a2.data.width || n2 !== a2.data.height) return this.fire(new e.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const h2 = !(i2 instanceof HTMLImageElement || e.b(i2));
            return a2.data.replace(l3, h2), this.style.updateImage(t2, a2), this;
          }
          getImage(t2) {
            return this.style.getImage(t2);
          }
          hasImage(t2) {
            return t2 ? !!this.style.getImage(t2) : (this.fire(new e.j(new Error("Missing required image id"))), false);
          }
          removeImage(t2) {
            this.style.removeImage(t2);
          }
          loadImage(t2) {
            return _.getImage(this._requestManager.transformRequest(t2, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(t2, e2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
          }
          moveLayer(t2, e2) {
            return this.style.moveLayer(t2, e2), this._update(true);
          }
          removeLayer(t2) {
            return this.style.removeLayer(t2), this._update(true);
          }
          getLayer(t2) {
            return this.style.getLayer(t2);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(t2, e2, i2) {
            return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
          }
          setFilter(t2, e2, i2 = {}) {
            return this.style.setFilter(t2, e2, i2), this._update(true);
          }
          getFilter(t2) {
            return this.style.getFilter(t2);
          }
          setPaintProperty(t2, e2, i2, a2 = {}) {
            return this.style.setPaintProperty(t2, e2, i2, a2), this._update(true);
          }
          getPaintProperty(t2, e2) {
            return this.style.getPaintProperty(t2, e2);
          }
          setLayoutProperty(t2, e2, i2, a2 = {}) {
            return this.style.setLayoutProperty(t2, e2, i2, a2), this._update(true);
          }
          getLayoutProperty(t2, e2) {
            return this.style.getLayoutProperty(t2, e2);
          }
          setGlyphs(t2, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(t2, e2), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(t2, e2, i2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(t2, e2, i2, (t3) => {
              t3 || this._update(true);
            }), this;
          }
          removeSprite(t2) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(t2), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(t2, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(t2, e2, (t3) => {
              t3 || this._update(true);
            }), this;
          }
          setLight(t2, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(t2) {
            return this._lazyInitEmptyStyle(), this.style.setSky(t2), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(t2, e2) {
            return this.style.setFeatureState(t2, e2), this._update();
          }
          removeFeatureState(t2, e2) {
            return this.style.removeFeatureState(t2, e2), this._update();
          }
          getFeatureState(t2) {
            return this.style.getFeatureState(t2);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let t2 = 0, e2 = 0;
            return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
          }
          _setupContainer() {
            const t2 = this._container;
            t2.classList.add("maplibregl-map");
            const e2 = this._canvasContainer = r.create("div", "maplibregl-canvas-container", t2);
            this._interactive && e2.classList.add("maplibregl-interactive"), this._canvas = r.create("canvas", "maplibregl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const i2 = this._containerDimensions(), a2 = this._getClampedPixelRatio(i2[0], i2[1]);
            this._resizeCanvas(i2[0], i2[1], a2);
            const s2 = this._controlContainer = r.create("div", "maplibregl-control-container", t2), o2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
              o2[t3] = r.create("div", "maplibregl-ctrl-".concat(t3, " "), s2);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t2, e2, i2) {
            this._canvas.width = Math.floor(i2 * t2), this._canvas.height = Math.floor(i2 * e2), this._canvas.style.width = "".concat(t2, "px"), this._canvas.style.height = "".concat(e2, "px");
          }
          _setupPainter() {
            const t2 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
            let e2 = null;
            this._canvas.addEventListener("webglcontextcreationerror", (i3) => {
              e2 = { requestedAttributes: t2 }, i3 && (e2.statusMessage = i3.statusMessage, e2.type = i3.type);
            }, { once: true });
            const i2 = this._canvas.getContext("webgl2", t2) || this._canvas.getContext("webgl", t2);
            if (!i2) {
              const t3 = "Failed to initialize WebGL";
              throw e2 ? (e2.message = t3, new Error(JSON.stringify(e2))) : new Error(t3);
            }
            this.painter = new va2(i2, this.transform), n.testSupport(i2);
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(t2) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(t2) {
            return this._update(), this._renderTaskQueue.add(t2);
          }
          _cancelRenderFrame(t2) {
            this._renderTaskQueue.remove(t2);
          }
          _render(t2) {
            const i2 = this._idleTriggered ? this._fadeDuration : 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t2), this._removed) return;
            let a2 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t3 = this.transform.zoom, s3 = o.now();
              this.style.zoomHistory.update(t3, s3);
              const r2 = new e.z(t3, { now: s3, fadeDuration: i2, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), n2 = r2.crossFadingFactor();
              1 === n2 && n2 === this._crossFadingFactor || (a2 = true, this._crossFadingFactor = n2), this.style.update(r2);
            }
            this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i2, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i2, showPadding: this.showPadding }), this.fire(new e.k("render")), this.loaded() && !this._loaded && (this._loaded = true, e.bf.mark(e.bg.load), this.fire(new e.k("load"))), this.style && (this.style.hasTransitions() || a2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const s2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return s2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new e.k("idle")), !this._loaded || this._fullyLoaded || s2 || (this._fullyLoaded = true, e.bf.mark(e.bg.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var t2;
            this._hash && this._hash.remove();
            for (const t3 of this._controls) t3.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), _.removeThrottleControl(this._imageQueueHandle), null === (t2 = this._resizeObserver) || void 0 === t2 || t2.disconnect();
            const i2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (null == i2 ? void 0 : i2.loseContext) && i2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), r.remove(this._canvasContainer), r.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), e.bf.clearMetrics(), this._removed = true, this.fire(new e.k("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), o.frameAsync(this._frameRequest).then((t2) => {
              e.bf.frame(t2), this._frameRequest = null, this._render(t2);
            }).catch(() => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(t2) {
            this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(t2) {
            this._showPadding !== t2 && (this._showPadding = t2, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(t2) {
            this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(t2) {
            this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(t2) {
            this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(t2) {
            this._vertices = t2, this._update();
          }
          get version() {
            return Ls2;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
        }, t.MapMouseEvent = ka2, t.MapTouchEvent = La2, t.MapWheelEvent = Fa2, t.Marker = Vs2, t.NavigationControl = class {
          constructor(t2) {
            this._updateZoomButtons = () => {
              const t3 = this._map.getZoom(), e2 = t3 === this._map.getMaxZoom(), i2 = t3 === this._map.getMinZoom();
              this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
            }, this._rotateCompassArrow = () => {
              const t3 = this.options.visualizePitch ? "scale(".concat(1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5), ") rotateX(").concat(this._map.transform.pitch, "deg) rotateZ(").concat(this._map.transform.angle * (180 / Math.PI), "deg)") : "rotate(".concat(this._map.transform.angle * (180 / Math.PI), "deg)");
              this._compassIcon.style.transform = t3;
            }, this._setButtonTitle = (t3, e2) => {
              const i2 = this._map._getUIString("NavigationControl.".concat(e2));
              t3.title = i2, t3.setAttribute("aria-label", i2);
            }, this.options = e.e({}, Os2, t2), this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t3) => this._map.zoomIn({}, { originalEvent: t3 })), r.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t3) => this._map.zoomOut({}, { originalEvent: t3 })), r.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t3) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t3 }) : this._map.resetNorth({}, { originalEvent: t3 });
            }), this._compassIcon = r.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(t2) {
            return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ns2(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            r.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(t2, e2) {
            const i2 = r.create("button", t2, this._container);
            return i2.type = "button", i2.addEventListener("click", e2), i2;
          }
        }, t.Popup = class extends e.E {
          constructor(t2) {
            super(), this.remove = () => (this._content && r.remove(this._content), this._container && (r.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new e.k("close"))), this), this._onMouseUp = (t3) => {
              this._update(t3.point);
            }, this._onMouseMove = (t3) => {
              this._update(t3.point);
            }, this._onDrag = (t3) => {
              this._update(t3.point);
            }, this._update = (t3) => {
              var e2;
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = r.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = r.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const t4 of this.options.className.split(" ")) this._container.classList.add(t4);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? js2(this._lngLat, this._flatPos, this._map.transform) : null === (e2 = this._lngLat) || void 0 === e2 ? void 0 : e2.wrap(), this._trackPointer && !t3) return;
              const i2 = this._flatPos = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && t3 ? t3 : this._map.transform.locationPoint(this._lngLat));
              let a2 = this.options.anchor;
              const s2 = Qs2(this.options.offset);
              if (!a2) {
                const t4 = this._container.offsetWidth, e3 = this._container.offsetHeight;
                let o3;
                o3 = i2.y + s2.bottom.y < e3 ? ["top"] : i2.y > this._map.transform.height - e3 ? ["bottom"] : [], i2.x < t4 / 2 ? o3.push("left") : i2.x > this._map.transform.width - t4 / 2 && o3.push("right"), a2 = 0 === o3.length ? "bottom" : o3.join("-");
              }
              let o2 = i2.add(s2[a2]);
              this.options.subpixelPositioning || (o2 = o2.round()), r.setTransform(this._container, "".concat(Zs2[a2], " translate(").concat(o2.x, "px,").concat(o2.y, "px)")), qs2(this._container, a2, "popup");
            }, this._onClose = () => {
              this.remove();
            }, this.options = e.e(Object.create(Js2), t2);
          }
          addTo(t2) {
            return this._map && this.remove(), this._map = t2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new e.k("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            return this._lngLat = e.N.convert(t2), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t2) {
            return this.setDOMContent(document.createTextNode(t2));
          }
          setHTML(t2) {
            const e2 = document.createDocumentFragment(), i2 = document.createElement("body");
            let a2;
            for (i2.innerHTML = t2; a2 = i2.firstChild, a2; ) e2.appendChild(a2);
            return this.setDOMContent(e2);
          }
          getMaxWidth() {
            var t2;
            return null === (t2 = this._container) || void 0 === t2 ? void 0 : t2.style.maxWidth;
          }
          setMaxWidth(t2) {
            return this.options.maxWidth = t2, this._update(), this;
          }
          setDOMContent(t2) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = r.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(t2) {
            return this._container && this._container.classList.add(t2), this;
          }
          removeClassName(t2) {
            return this._container && this._container.classList.remove(t2), this;
          }
          setOffset(t2) {
            return this.options.offset = t2, this._update(), this;
          }
          toggleClassName(t2) {
            if (this._container) return this._container.classList.toggle(t2);
          }
          setSubpixelPositioning(t2) {
            this.options.subpixelPositioning = t2;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = r.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const t2 = this._container.querySelector(Ys2);
            t2 && t2.focus();
          }
        }, t.RasterDEMTileSource = K, t.RasterTileSource = X, t.ScaleControl = class {
          constructor(t2) {
            this._onMove = () => {
              Xs2(this._map, this._container, this.options);
            }, this.setUnit = (t3) => {
              this.options.unit = t3, Xs2(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, $s2), t2);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t2) {
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, t.ScrollZoomHandler = us2, t.Style = de2, t.TerrainControl = class {
          constructor(t2) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = t2;
          }
          onAdd(t2) {
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = r.create("button", "maplibregl-ctrl-terrain", this._container), r.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, t.TwoFingersTouchPitchHandler = rs2, t.TwoFingersTouchRotateHandler = ss2, t.TwoFingersTouchZoomHandler = is2, t.TwoFingersTouchZoomRotateHandler = gs2, t.VectorTileSource = $, t.VideoSource = tt2, t.addSourceType = (t2, i2) => e._(void 0, void 0, void 0, function* () {
          if (at2(t2)) throw new Error('A source type called "'.concat(t2, '" already exists.'));
          ((t3, e2) => {
            it2[t3] = e2;
          })(t2, i2);
        }), t.clearPrewarmedResources = function() {
          const t2 = B;
          t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(k), B = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t.getMaxParallelImageRequests = function() {
          return e.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, t.getRTLTextPluginStatus = function() {
          return nt2().getRTLTextPluginStatus();
        }, t.getVersion = function() {
          return to2;
        }, t.getWorkerCount = function() {
          return L2.workerCount;
        }, t.getWorkerUrl = function() {
          return e.a.WORKER_URL;
        }, t.importScriptInWorkers = function(t2) {
          return j().broadcast("IS", t2);
        }, t.prewarm = function() {
          N().acquire(k);
        }, t.setMaxParallelImageRequests = function(t2) {
          e.a.MAX_PARALLEL_IMAGE_REQUESTS = t2;
        }, t.setRTLTextPlugin = function(t2, e2) {
          return nt2().setRTLTextPlugin(t2, e2);
        }, t.setWorkerCount = function(t2) {
          L2.workerCount = t2;
        }, t.setWorkerUrl = function(t2) {
          e.a.WORKER_URL = t2;
        };
      });
      var maplibregl$1 = maplibregl2;
      return maplibregl$1;
    });
  }
});

// src/js/maplibre-gl-directions.js
var require_maplibre_gl_directions = __commonJS({
  "src/js/maplibre-gl-directions.js"(exports, module) {
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.MapLibreDirections = f();
      }
    })(function() {
      var define2, module2, exports2;
      return (/* @__PURE__ */ function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof __require && __require;
                if (!f && c) return c(i2, true);
                if (u) return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof __require && __require, i = 0; i < t.length; i++) o(t[i]);
          return o;
        }
        return r;
<<<<<<< HEAD
      }())({
        1: [function(require2, module3, exports3) {
          "use strict";
          var polyline = {};
          function py2_round(value) {
            return Math.floor(Math.abs(value) + 0.5) * (value >= 0 ? 1 : -1);
=======
      }())({ 1: [function(require2, module3, exports3) {
        "use strict";
        var polyline2 = {};
        function py2_round(value) {
          return Math.floor(Math.abs(value) + 0.5) * (value >= 0 ? 1 : -1);
        }
        function encode(current, previous, factor) {
          current = py2_round(current * factor);
          previous = py2_round(previous * factor);
          var coordinate = current - previous;
          coordinate <<= 1;
          if (current - previous < 0) {
            coordinate = ~coordinate;
>>>>>>> bdd3a43f0a524c4d66399bc662fa9f5f1b8c5c18
          }
          function encode(current, previous, factor) {
            current = py2_round(current * factor);
            previous = py2_round(previous * factor);
            var coordinate = current - previous;
            coordinate <<= 1;
            if (current - previous < 0) {
              coordinate = ~coordinate;
            }
            var output = "";
            while (coordinate >= 32) {
              output += String.fromCharCode((32 | coordinate & 31) + 63);
              coordinate >>= 5;
            }
            output += String.fromCharCode(coordinate + 63);
            return output;
          }
<<<<<<< HEAD
          polyline.decode = function(str, precision) {
            var index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0, byte = null, latitude_change, longitude_change, factor = Math.pow(10, Number.isInteger(precision) ? precision : 5);
            while (index < str.length) {
              byte = null;
              shift = 0;
              result = 0;
              do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 31) << shift;
                shift += 5;
              } while (byte >= 32);
              latitude_change = result & 1 ? ~(result >> 1) : result >> 1;
              shift = result = 0;
              do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 31) << shift;
                shift += 5;
              } while (byte >= 32);
              longitude_change = result & 1 ? ~(result >> 1) : result >> 1;
              lat += latitude_change;
              lng += longitude_change;
              coordinates.push([lat / factor, lng / factor]);
            }
            return coordinates;
          };
          polyline.encode = function(coordinates, precision) {
            if (!coordinates.length) {
              return "";
            }
            var factor = Math.pow(10, Number.isInteger(precision) ? precision : 5), output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);
            for (var i = 1; i < coordinates.length; i++) {
              var a = coordinates[i], b = coordinates[i - 1];
              output += encode(a[0], b[0], factor);
              output += encode(a[1], b[1], factor);
            }
            return output;
          };
          function flipped(coords) {
            var flipped2 = [];
            for (var i = 0; i < coords.length; i++) {
              var coord = coords[i].slice();
              flipped2.push([coord[1], coord[0]]);
            }
            return flipped2;
=======
          output += String.fromCharCode(coordinate + 63);
          return output;
        }
        polyline2.decode = function(str, precision) {
          var index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0, byte = null, latitude_change, longitude_change, factor = Math.pow(10, Number.isInteger(precision) ? precision : 5);
          while (index < str.length) {
            byte = null;
            shift = 0;
            result = 0;
            do {
              byte = str.charCodeAt(index++) - 63;
              result |= (byte & 31) << shift;
              shift += 5;
            } while (byte >= 32);
            latitude_change = result & 1 ? ~(result >> 1) : result >> 1;
            shift = result = 0;
            do {
              byte = str.charCodeAt(index++) - 63;
              result |= (byte & 31) << shift;
              shift += 5;
            } while (byte >= 32);
            longitude_change = result & 1 ? ~(result >> 1) : result >> 1;
            lat += latitude_change;
            lng += longitude_change;
            coordinates.push([lat / factor, lng / factor]);
          }
          return coordinates;
        };
        polyline2.encode = function(coordinates, precision) {
          if (!coordinates.length) {
            return "";
          }
          var factor = Math.pow(10, Number.isInteger(precision) ? precision : 5), output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);
          for (var i = 1; i < coordinates.length; i++) {
            var a = coordinates[i], b = coordinates[i - 1];
            output += encode(a[0], b[0], factor);
            output += encode(a[1], b[1], factor);
          }
          return output;
        };
        function flipped(coords) {
          var flipped2 = [];
          for (var i = 0; i < coords.length; i++) {
            var coord = coords[i].slice();
            flipped2.push([coord[1], coord[0]]);
          }
          return flipped2;
        }
        polyline2.fromGeoJSON = function(geojson, precision) {
          if (geojson && geojson.type === "Feature") {
            geojson = geojson.geometry;
          }
          if (!geojson || geojson.type !== "LineString") {
            throw new Error("Input must be a GeoJSON LineString");
          }
          return polyline2.encode(flipped(geojson.coordinates), precision);
        };
        polyline2.toGeoJSON = function(str, precision) {
          var coords = polyline2.decode(str, precision);
          return {
            type: "LineString",
            coordinates: flipped(coords)
          };
        };
        if (typeof module3 === "object" && module3.exports) {
          module3.exports = polyline2;
        }
      }, {}], 2: [function(require2, module3, exports3) {
        "use strict";
        var isObj = require2("is-obj");
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
          if (val === null || val === void 0) {
            throw new TypeError("Sources cannot be null or undefined");
>>>>>>> bdd3a43f0a524c4d66399bc662fa9f5f1b8c5c18
          }
          polyline.fromGeoJSON = function(geojson, precision) {
            if (geojson && geojson.type === "Feature") {
              geojson = geojson.geometry;
            }
            if (!geojson || geojson.type !== "LineString") {
              throw new Error("Input must be a GeoJSON LineString");
            }
            return polyline.encode(flipped(geojson.coordinates), precision);
          };
          polyline.toGeoJSON = function(str, precision) {
            var coords = polyline.decode(str, precision);
            return {
              type: "LineString",
              coordinates: flipped(coords)
            };
          };
          if (typeof module3 === "object" && module3.exports) {
            module3.exports = polyline;
          }
        }, {}],
        2: [function(require2, module3, exports3) {
          "use strict";
          var isObj = require2("is-obj");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject(val) {
            if (val === null || val === void 0) {
              throw new TypeError("Sources cannot be null or undefined");
            }
            return Object(val);
          }
          function assignKey(to2, from, key) {
            var val = from[key];
            if (val === void 0 || val === null) {
              return;
            }
            if (hasOwnProperty.call(to2, key)) {
              if (to2[key] === void 0 || to2[key] === null) {
                throw new TypeError("Cannot convert undefined or null to object (" + key + ")");
              }
            }
            if (!hasOwnProperty.call(to2, key) || !isObj(val)) {
              to2[key] = val;
            } else {
              to2[key] = assign(Object(to2[key]), from[key]);
            }
          }
          function assign(to2, from) {
            if (to2 === from) {
              return to2;
            }
            from = Object(from);
            for (var key in from) {
              if (hasOwnProperty.call(from, key)) {
                assignKey(to2, from, key);
              }
            }
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(from);
              for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                  assignKey(to2, from, symbols[i]);
                }
              }
            }
            return to2;
          }
          module3.exports = function deepAssign(target) {
            target = toObject(target);
            for (var s = 1; s < arguments.length; s++) {
              assign(target, arguments[s]);
            }
            return target;
          };
        }, { "is-obj": 5 }],
        3: [function(require2, module3, exports3) {
          function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || void 0;
          }
          module3.exports = EventEmitter;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = void 0;
          EventEmitter.prototype._maxListeners = void 0;
          EventEmitter.defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function(n) {
            if (!isNumber(n) || n < 0 || isNaN(n))
              throw TypeError("n must be a positive number");
            this._maxListeners = n;
            return this;
          };
          EventEmitter.prototype.emit = function(type) {
            var er2, handler, len, args, i, listeners;
            if (!this._events)
              this._events = {};
            if (type === "error") {
              if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                er2 = arguments[1];
                if (er2 instanceof Error) {
                  throw er2;
                } else {
                  var err = new Error('Uncaught, unspecified "error" event. (' + er2 + ")");
                  err.context = er2;
                  throw err;
                }
              }
            }
            handler = this._events[type];
            if (isUndefined(handler))
              return false;
            if (isFunction(handler)) {
              switch (arguments.length) {
                // fast cases
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                // slower
                default:
                  args = Array.prototype.slice.call(arguments, 1);
                  handler.apply(this, args);
              }
            } else if (isObject(handler)) {
              args = Array.prototype.slice.call(arguments, 1);
              listeners = handler.slice();
              len = listeners.length;
              for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
            }
            return true;
          };
          EventEmitter.prototype.addListener = function(type, listener) {
            var m;
            if (!isFunction(listener))
              throw TypeError("listener must be a function");
            if (!this._events)
              this._events = {};
            if (this._events.newListener)
              this.emit(
                "newListener",
                type,
                isFunction(listener.listener) ? listener.listener : listener
              );
            if (!this._events[type])
              this._events[type] = listener;
            else if (isObject(this._events[type]))
              this._events[type].push(listener);
            else
              this._events[type] = [this._events[type], listener];
            if (isObject(this._events[type]) && !this._events[type].warned) {
              if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
              } else {
                m = EventEmitter.defaultMaxListeners;
              }
              if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error(
                  "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
                  this._events[type].length
                );
                if (typeof console.trace === "function") {
                  console.trace();
                }
              }
            }
            return this;
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.once = function(type, listener) {
            if (!isFunction(listener))
              throw TypeError("listener must be a function");
            var fired = false;
            function g() {
              this.removeListener(type, g);
              if (!fired) {
                fired = true;
                listener.apply(this, arguments);
              }
            }
            g.listener = listener;
            this.on(type, g);
            return this;
          };
          EventEmitter.prototype.removeListener = function(type, listener) {
            var list, position, length, i;
            if (!isFunction(listener))
              throw TypeError("listener must be a function");
            if (!this._events || !this._events[type])
              return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (list === listener || isFunction(list.listener) && list.listener === listener) {
              delete this._events[type];
              if (this._events.removeListener)
                this.emit("removeListener", type, listener);
            } else if (isObject(list)) {
              for (i = length; i-- > 0; ) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                  position = i;
                  break;
                }
              }
              if (position < 0)
                return this;
              if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
              } else {
                list.splice(position, 1);
              }
              if (this._events.removeListener)
                this.emit("removeListener", type, listener);
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners = function(type) {
            var key, listeners;
            if (!this._events)
              return this;
            if (!this._events.removeListener) {
              if (arguments.length === 0)
                this._events = {};
              else if (this._events[type])
                delete this._events[type];
              return this;
            }
            if (arguments.length === 0) {
              for (key in this._events) {
                if (key === "removeListener") continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners("removeListener");
              this._events = {};
              return this;
            }
            listeners = this._events[type];
            if (isFunction(listeners)) {
              this.removeListener(type, listeners);
            } else if (listeners) {
              while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];
            return this;
          };
          EventEmitter.prototype.listeners = function(type) {
            var ret;
            if (!this._events || !this._events[type])
              ret = [];
            else if (isFunction(this._events[type]))
              ret = [this._events[type]];
            else
              ret = this._events[type].slice();
            return ret;
          };
          EventEmitter.prototype.listenerCount = function(type) {
            if (this._events) {
              var evlistener = this._events[type];
              if (isFunction(evlistener))
                return 1;
              else if (evlistener)
                return evlistener.length;
            }
            return 0;
          };
          EventEmitter.listenerCount = function(emitter, type) {
            return emitter.listenerCount(type);
          };
          function isFunction(arg) {
            return typeof arg === "function";
          }
          function isNumber(arg) {
            return typeof arg === "number";
          }
          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          function isUndefined(arg) {
            return arg === void 0;
          }
        }, {}],
        4: [function(require2, module3, exports3) {
          (function() {
            var root = this;
            var fuzzy = {};
            if (typeof exports3 !== "undefined") {
              module3.exports = fuzzy;
            } else {
              root.fuzzy = fuzzy;
            }
            fuzzy.simpleFilter = function(pattern, array) {
              return array.filter(function(str) {
                return fuzzy.test(pattern, str);
              });
            };
            fuzzy.test = function(pattern, str) {
              return fuzzy.match(pattern, str) !== null;
            };
            fuzzy.match = function(pattern, str, opts) {
              opts = opts || {};
              var patternIdx = 0, result = [], len = str.length, totalScore = 0, currScore = 0, pre = opts.pre || "", post = opts.post || "", compareString = opts.caseSensitive && str || str.toLowerCase(), ch;
              pattern = opts.caseSensitive && pattern || pattern.toLowerCase();
              for (var idx = 0; idx < len; idx++) {
                ch = str[idx];
                if (compareString[idx] === pattern[patternIdx]) {
                  ch = pre + ch + post;
                  patternIdx += 1;
                  currScore += 1 + currScore;
                } else {
                  currScore = 0;
                }
                totalScore += currScore;
                result[result.length] = ch;
              }
              if (patternIdx === pattern.length) {
                totalScore = compareString === pattern ? Infinity : totalScore;
                return { rendered: result.join(""), score: totalScore };
              }
              return null;
            };
            fuzzy.filter = function(pattern, arr, opts) {
              if (!arr || arr.length === 0) {
                return [];
              }
              if (typeof pattern !== "string") {
                return arr;
              }
              opts = opts || {};
              return arr.reduce(function(prev, element, idx, arr2) {
                var str = element;
                if (opts.extract) {
                  str = opts.extract(element);
                }
                var rendered = fuzzy.match(pattern, str, opts);
                if (rendered != null) {
                  prev[prev.length] = {
                    string: rendered.rendered,
                    score: rendered.score,
                    index: idx,
                    original: element
                  };
                }
                return prev;
              }, []).sort(function(a, b) {
                var compare = b.score - a.score;
                if (compare) return compare;
                return a.index - b.index;
              });
            };
          })();
        }, {}],
        5: [function(require2, module3, exports3) {
          "use strict";
          module3.exports = function(x) {
            var type = typeof x;
            return x !== null && (type === "object" || type === "function");
          };
        }, {}],
        6: [function(require2, module3, exports3) {
          var reInterpolate = /<%=([\s\S]+?)%>/g;
          module3.exports = reInterpolate;
        }, {}],
        7: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var FUNC_ERROR_TEXT = "Expected a function";
              var NAN = 0 / 0;
              var symbolTag = "[object Symbol]";
              var reTrim = /^\s+|\s+$/g;
              var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
              var reIsBinary = /^0b[01]+$/i;
              var reIsOctal = /^0o[0-7]+$/i;
              var freeParseInt = parseInt;
              var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
              var freeSelf = typeof self == "object" && self && self.Object === Object && self;
              var root = freeGlobal || freeSelf || Function("return this")();
              var objectProto = Object.prototype;
              var objectToString = objectProto.toString;
              var nativeMax = Math.max, nativeMin = Math.min;
              var now = function() {
                return root.Date.now();
              };
              function debounce(func, wait, options) {
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if (typeof func != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                wait = toNumber(wait) || 0;
                if (isObject(options)) {
                  leading = !!options.leading;
                  maxing = "maxWait" in options;
                  maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                  trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                  var args = lastArgs, thisArg = lastThis;
                  lastArgs = lastThis = void 0;
                  lastInvokeTime = time;
                  result = func.apply(thisArg, args);
                  return result;
                }
                function leadingEdge(time) {
                  lastInvokeTime = time;
                  timerId = setTimeout(timerExpired, wait);
                  return leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
                  return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
                }
                function shouldInvoke(time) {
                  var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                  return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                  var time = now();
                  if (shouldInvoke(time)) {
                    return trailingEdge(time);
                  }
                  timerId = setTimeout(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                  timerId = void 0;
                  if (trailing && lastArgs) {
                    return invokeFunc(time);
                  }
                  lastArgs = lastThis = void 0;
                  return result;
                }
                function cancel() {
                  if (timerId !== void 0) {
                    clearTimeout(timerId);
                  }
                  lastInvokeTime = 0;
                  lastArgs = lastCallTime = lastThis = timerId = void 0;
                }
                function flush() {
                  return timerId === void 0 ? result : trailingEdge(now());
                }
                function debounced() {
                  var time = now(), isInvoking = shouldInvoke(time);
                  lastArgs = arguments;
                  lastThis = this;
                  lastCallTime = time;
                  if (isInvoking) {
                    if (timerId === void 0) {
                      return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                      timerId = setTimeout(timerExpired, wait);
                      return invokeFunc(lastCallTime);
                    }
                  }
                  if (timerId === void 0) {
                    timerId = setTimeout(timerExpired, wait);
                  }
                  return result;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
              }
              function isObject(value) {
                var type = typeof value;
                return !!value && (type == "object" || type == "function");
              }
              function isObjectLike(value) {
                return !!value && typeof value == "object";
              }
              function isSymbol(value) {
                return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
              }
              function toNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                if (isObject(value)) {
                  var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                  value = isObject(other) ? other + "" : other;
                }
                if (typeof value != "string") {
                  return value === 0 ? value : +value;
                }
                value = value.replace(reTrim, "");
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
              }
              module3.exports = debounce;
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        8: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var LARGE_ARRAY_SIZE = 200;
              var HASH_UNDEFINED = "__lodash_hash_undefined__";
              var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
              var MAX_SAFE_INTEGER = 9007199254740991;
              var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
              var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
              var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
              var reIsHostCtor = /^\[object .+?Constructor\]$/;
              var reIsUint = /^(?:0|[1-9]\d*)$/;
              var typedArrayTags = {};
              typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
              typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
              var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
              var freeSelf = typeof self == "object" && self && self.Object === Object && self;
              var root = freeGlobal || freeSelf || Function("return this")();
              var freeExports = typeof exports3 == "object" && exports3 && !exports3.nodeType && exports3;
              var freeModule = freeExports && typeof module3 == "object" && module3 && !module3.nodeType && module3;
              var moduleExports = freeModule && freeModule.exports === freeExports;
              var freeProcess = moduleExports && freeGlobal.process;
              var nodeUtil = function() {
                try {
                  return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {
                }
              }();
              var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
              function arrayFilter(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }
              function arrayPush(array, values) {
                var index = -1, length = values.length, offset = array.length;
                while (++index < length) {
                  array[offset + index] = values[index];
                }
                return array;
              }
              function arraySome(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (predicate(array[index], index, array)) {
                    return true;
                  }
                }
                return false;
              }
              function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) {
                  result[index] = iteratee(index);
                }
                return result;
              }
              function baseUnary(func) {
                return function(value) {
                  return func(value);
                };
              }
              function cacheHas(cache, key) {
                return cache.has(key);
              }
              function getValue(object, key) {
                return object == null ? void 0 : object[key];
              }
              function mapToArray(map2) {
                var index = -1, result = Array(map2.size);
                map2.forEach(function(value, key) {
                  result[++index] = [key, value];
                });
                return result;
              }
              function overArg(func, transform) {
                return function(arg) {
                  return func(transform(arg));
                };
              }
              function setToArray(set) {
                var index = -1, result = Array(set.size);
                set.forEach(function(value) {
                  result[++index] = value;
                });
                return result;
              }
              var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
              var coreJsData = root["__core-js_shared__"];
              var funcToString = funcProto.toString;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
              }();
              var nativeObjectToString = objectProto.toString;
              var reIsNative = RegExp(
                "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
              );
              var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
              var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
              var DataView = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
              var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
              var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
              function Hash(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
              }
              function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
              }
              function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result = data[key];
                  return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
              }
              function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
              }
              function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
                return this;
              }
              Hash.prototype.clear = hashClear;
              Hash.prototype["delete"] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;
              function ListCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
              }
              function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index, 1);
                }
                --this.size;
                return true;
              }
              function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
              }
              function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }
              function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                  ++this.size;
                  data.push([key, value]);
                } else {
                  data[index][1] = value;
                }
                return this;
              }
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype["delete"] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;
              function MapCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                  "hash": new Hash(),
                  "map": new (Map2 || ListCache)(),
                  "string": new Hash()
                };
              }
              function mapCacheDelete(key) {
                var result = getMapData(this, key)["delete"](key);
                this.size -= result ? 1 : 0;
                return result;
              }
              function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }
              function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }
              function mapCacheSet(key, value) {
                var data = getMapData(this, key), size = data.size;
                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
              }
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype["delete"] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;
              function SetCache(values) {
                var index = -1, length = values == null ? 0 : values.length;
                this.__data__ = new MapCache();
                while (++index < length) {
                  this.add(values[index]);
                }
              }
              function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
              }
              function setCacheHas(value) {
                return this.__data__.has(value);
              }
              SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
              SetCache.prototype.has = setCacheHas;
              function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
              }
              function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
              }
              function stackDelete(key) {
                var data = this.__data__, result = data["delete"](key);
                this.size = data.size;
                return result;
              }
              function stackGet(key) {
                return this.__data__.get(key);
              }
              function stackHas(key) {
                return this.__data__.has(key);
              }
              function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                  var pairs = data.__data__;
                  if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }
              Stack.prototype.clear = stackClear;
              Stack.prototype["delete"] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;
              function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for (var key in value) {
                  if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                  (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                  isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                  isIndex(key, length)))) {
                    result.push(key);
                  }
                }
                return result;
              }
              function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
              }
              function baseGetTag(value) {
                if (value == null) {
                  return value === void 0 ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
              }
              function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
              }
              function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                  return true;
                }
                if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
              }
              function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                  if (!isBuffer(other)) {
                    return false;
                  }
                  objIsArr = true;
                  objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                  stack || (stack = new Stack());
                  return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                  var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack || (stack = new Stack());
                return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
              }
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
              }
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                  if (hasOwnProperty.call(object, key) && key != "constructor") {
                    result.push(key);
                  }
                }
                return result;
              }
              function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                  return false;
                }
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) {
                  return stacked == other;
                }
                var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
                stack.set(array, other);
                stack.set(other, array);
                while (++index < arrLength) {
                  var arrValue = array[index], othValue = other[index];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                  }
                  if (compared !== void 0) {
                    if (compared) {
                      continue;
                    }
                    result = false;
                    break;
                  }
                  if (seen) {
                    if (!arraySome(other, function(othValue2, othIndex) {
                      if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                        return seen.push(othIndex);
                      }
                    })) {
                      result = false;
                      break;
                    }
                  } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    result = false;
                    break;
                  }
                }
                stack["delete"](array);
                stack["delete"](other);
                return result;
              }
              function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                      return false;
                    }
                    object = object.buffer;
                    other = other.buffer;
                  case arrayBufferTag:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                      return false;
                    }
                    return true;
                  case boolTag:
                  case dateTag:
                  case numberTag:
                    return eq(+object, +other);
                  case errorTag:
                    return object.name == other.name && object.message == other.message;
                  case regexpTag:
                  case stringTag:
                    return object == other + "";
                  case mapTag:
                    var convert = mapToArray;
                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) {
                      return false;
                    }
                    var stacked = stack.get(object);
                    if (stacked) {
                      return stacked == other;
                    }
                    bitmask |= COMPARE_UNORDERED_FLAG;
                    stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    stack["delete"](object);
                    return result;
                  case symbolTag:
                    if (symbolValueOf) {
                      return symbolValueOf.call(object) == symbolValueOf.call(other);
                    }
                }
                return false;
              }
              function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index = objLength;
                while (index--) {
                  var key = objProps[index];
                  if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                  }
                }
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) {
                  return stacked == other;
                }
                var result = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index < objLength) {
                  key = objProps[index];
                  var objValue = object[key], othValue = other[key];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                  }
                  if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == "constructor");
                }
                if (result && !skipCtor) {
                  var objCtor = object.constructor, othCtor = other.constructor;
                  if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    result = false;
                  }
                }
                stack["delete"](object);
                stack["delete"](other);
                return result;
              }
              function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }
              function getMapData(map2, key) {
                var data = map2.__data__;
                return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
              }
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : void 0;
              }
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                  value[symToStringTag] = void 0;
                  var unmasked = true;
                } catch (e) {
                }
                var result = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result;
              }
              var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                if (object == null) {
                  return [];
                }
                object = Object(object);
                return arrayFilter(nativeGetSymbols(object), function(symbol) {
                  return propertyIsEnumerable.call(object, symbol);
                });
              };
              var getTag = baseGetTag;
              if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
                getTag = function(value) {
                  var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
                  if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString:
                        return dataViewTag;
                      case mapCtorString:
                        return mapTag;
                      case promiseCtorString:
                        return promiseTag;
                      case setCtorString:
                        return setTag;
                      case weakMapCtorString:
                        return weakMapTag;
                    }
                  }
                  return result;
                };
              }
              function isIndex(value, length) {
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
              }
              function isKeyable(value) {
                var type = typeof value;
                return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
              }
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                return value === proto;
              }
              function objectToString(value) {
                return nativeObjectToString.call(value);
              }
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {
                  }
                  try {
                    return func + "";
                  } catch (e) {
                  }
                }
                return "";
              }
              function eq(value, other) {
                return value === other || value !== value && other !== other;
              }
              var isArguments = baseIsArguments(/* @__PURE__ */ function() {
                return arguments;
              }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
              };
              var isArray = Array.isArray;
              function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
              }
              var isBuffer = nativeIsBuffer || stubFalse;
              function isEqual(value, other) {
                return baseIsEqual(value, other);
              }
              function isFunction(value) {
                if (!isObject(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
              }
              function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }
              function isObject(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
              }
              function isObjectLike(value) {
                return value != null && typeof value == "object";
              }
              var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
              function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
              }
              function stubArray() {
                return [];
              }
              function stubFalse() {
                return false;
              }
              module3.exports = isEqual;
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        9: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var reInterpolate = require2("lodash._reinterpolate"), templateSettings = require2("lodash.templatesettings");
              var HOT_COUNT = 800, HOT_SPAN = 16;
              var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
              var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
              var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
              var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
              var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
              var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
              var reIsHostCtor = /^\[object .+?Constructor\]$/;
              var reIsUint = /^(?:0|[1-9]\d*)$/;
              var reNoMatch = /($^)/;
              var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
              var typedArrayTags = {};
              typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
              typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
              var stringEscapes = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
              };
              var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
              var freeSelf = typeof self == "object" && self && self.Object === Object && self;
              var root = freeGlobal || freeSelf || Function("return this")();
              var freeExports = typeof exports3 == "object" && exports3 && !exports3.nodeType && exports3;
              var freeModule = freeExports && typeof module3 == "object" && module3 && !module3.nodeType && module3;
              var moduleExports = freeModule && freeModule.exports === freeExports;
              var freeProcess = moduleExports && freeGlobal.process;
              var nodeUtil = function() {
                try {
                  var types = freeModule && freeModule.require && freeModule.require("util").types;
                  if (types) {
                    return types;
                  }
                  return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {
                }
              }();
              var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
              function apply(func, thisArg, args) {
                switch (args.length) {
                  case 0:
                    return func.call(thisArg);
                  case 1:
                    return func.call(thisArg, args[0]);
                  case 2:
                    return func.call(thisArg, args[0], args[1]);
                  case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
              }
              function arrayMap(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                while (++index < length) {
                  result[index] = iteratee(array[index], index, array);
                }
                return result;
              }
              function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) {
                  result[index] = iteratee(index);
                }
                return result;
              }
              function baseUnary(func) {
                return function(value) {
                  return func(value);
                };
              }
              function baseValues(object, props) {
                return arrayMap(props, function(key) {
                  return object[key];
                });
              }
              function escapeStringChar(chr) {
                return "\\" + stringEscapes[chr];
              }
              function getValue(object, key) {
                return object == null ? void 0 : object[key];
              }
              function overArg(func, transform) {
                return function(arg) {
                  return func(transform(arg));
                };
              }
              var funcProto = Function.prototype, objectProto = Object.prototype;
              var coreJsData = root["__core-js_shared__"];
              var funcToString = funcProto.toString;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
              }();
              var nativeObjectToString = objectProto.toString;
              var objectCtorString = funcToString.call(Object);
              var reIsNative = RegExp(
                "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
              );
              var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, getPrototype = overArg(Object.getPrototypeOf, Object), propertyIsEnumerable = objectProto.propertyIsEnumerable, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
              var defineProperty = function() {
                try {
                  var func = getNative(Object, "defineProperty");
                  func({}, "", {});
                  return func;
                } catch (e) {
                }
              }();
              var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeNow = Date.now;
              var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
              function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for (var key in value) {
                  if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                  (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                  isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                  isIndex(key, length)))) {
                    result.push(key);
                  }
                }
                return result;
              }
              function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
                  baseAssignValue(object, key, value);
                }
              }
              function baseAssignValue(object, key, value) {
                if (key == "__proto__" && defineProperty) {
                  defineProperty(object, key, {
                    "configurable": true,
                    "enumerable": true,
                    "value": value,
                    "writable": true
                  });
                } else {
                  object[key] = value;
                }
              }
              function baseGetTag(value) {
                if (value == null) {
                  return value === void 0 ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
              }
              function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
              }
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
              }
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                  if (hasOwnProperty.call(object, key) && key != "constructor") {
                    result.push(key);
                  }
                }
                return result;
              }
              function baseKeysIn(object) {
                if (!isObject(object)) {
                  return nativeKeysIn(object);
                }
                var isProto = isPrototype(object), result = [];
                for (var key in object) {
                  if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                  }
                }
                return result;
              }
              function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + "");
              }
              var baseSetToString = !defineProperty ? identity : function(func, string) {
                return defineProperty(func, "toString", {
                  "configurable": true,
                  "enumerable": false,
                  "value": constant(string),
                  "writable": true
                });
              };
              function baseToString(value) {
                if (typeof value == "string") {
                  return value;
                }
                if (isArray(value)) {
                  return arrayMap(value, baseToString) + "";
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : "";
                }
                var result = value + "";
                return result == "0" && 1 / value == -INFINITY ? "-0" : result;
              }
              function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index = -1, length = props.length;
                while (++index < length) {
                  var key = props[index];
                  var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                  if (newValue === void 0) {
                    newValue = source[key];
                  }
                  if (isNew) {
                    baseAssignValue(object, key, newValue);
                  } else {
                    assignValue(object, key, newValue);
                  }
                }
                return object;
              }
              function createAssigner(assigner) {
                return baseRest(function(object, sources) {
                  var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
                  customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? void 0 : customizer;
                    length = 1;
                  }
                  object = Object(object);
                  while (++index < length) {
                    var source = sources[index];
                    if (source) {
                      assigner(object, source, index, customizer);
                    }
                  }
                  return object;
                });
              }
              function customDefaultsAssignIn(objValue, srcValue, key, object) {
                if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  return srcValue;
                }
                return objValue;
              }
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : void 0;
              }
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                  value[symToStringTag] = void 0;
                  var unmasked = true;
                } catch (e) {
                }
                var result = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result;
              }
              function isIndex(value, length) {
                var type = typeof value;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
              }
              function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index;
                if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                  return eq(object[index], value);
                }
                return false;
              }
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                return value === proto;
              }
              function nativeKeysIn(object) {
                var result = [];
                if (object != null) {
                  for (var key in Object(object)) {
                    result.push(key);
                  }
                }
                return result;
              }
              function objectToString(value) {
                return nativeObjectToString.call(value);
              }
              function overRest(func, start, transform) {
                start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
                return function() {
                  var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                  while (++index < length) {
                    array[index] = args[start + index];
                  }
                  index = -1;
                  var otherArgs = Array(start + 1);
                  while (++index < start) {
                    otherArgs[index] = args[index];
                  }
                  otherArgs[start] = transform(array);
                  return apply(func, this, otherArgs);
                };
              }
              var setToString = shortOut(baseSetToString);
              function shortOut(func) {
                var count = 0, lastCalled = 0;
                return function() {
                  var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(void 0, arguments);
                };
              }
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {
                  }
                  try {
                    return func + "";
                  } catch (e) {
                  }
                }
                return "";
              }
              function eq(value, other) {
                return value === other || value !== value && other !== other;
              }
              var isArguments = baseIsArguments(/* @__PURE__ */ function() {
                return arguments;
              }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
              };
              var isArray = Array.isArray;
              function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
              }
              var isBuffer = nativeIsBuffer || stubFalse;
              function isError(value) {
                if (!isObjectLike(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
              }
              function isFunction(value) {
                if (!isObject(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
              }
              function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }
              function isObject(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
              }
              function isObjectLike(value) {
                return value != null && typeof value == "object";
              }
              function isPlainObject(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                  return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                  return true;
                }
                var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
              }
              function isSymbol(value) {
                return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
              }
              var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
              function toString(value) {
                return value == null ? "" : baseToString(value);
              }
              var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                copyObject(source, keysIn(source), object, customizer);
              });
              function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
              }
              function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
              }
              function template(string, options, guard) {
                var settings = templateSettings.imports._.templateSettings || templateSettings;
                if (guard && isIterateeCall(string, options, guard)) {
                  options = void 0;
                }
                string = toString(string);
                options = assignInWith({}, options, settings, customDefaultsAssignIn);
                var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                var reDelimiters = RegExp(
                  (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                  "g"
                );
                var sourceURL = hasOwnProperty.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/[\r\n]/g, " ") + "\n" : "";
                string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                  interpolateValue || (interpolateValue = esTemplateValue);
                  source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                  if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                  }
                  if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                  }
                  if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                  }
                  index = offset + match.length;
                  return match;
                });
                source += "';\n";
                var variable = hasOwnProperty.call(options, "variable") && options.variable;
                if (!variable) {
                  source = "with (obj) {\n" + source + "\n}\n";
                }
                source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                var result = attempt(function() {
                  return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
                });
                result.source = source;
                if (isError(result)) {
                  throw result;
                }
                return result;
              }
              var attempt = baseRest(function(func, args) {
                try {
                  return apply(func, void 0, args);
                } catch (e) {
                  return isError(e) ? e : new Error(e);
                }
              });
              function constant(value) {
                return function() {
                  return value;
                };
              }
              function identity(value) {
                return value;
              }
              function stubFalse() {
                return false;
              }
              module3.exports = template;
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "lodash._reinterpolate": 6, "lodash.templatesettings": 10 }],
        10: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var reInterpolate = require2("lodash._reinterpolate");
              var INFINITY = 1 / 0;
              var nullTag = "[object Null]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]";
              var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
              var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g;
              var htmlEscapes = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
              };
              var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
              var freeSelf = typeof self == "object" && self && self.Object === Object && self;
              var root = freeGlobal || freeSelf || Function("return this")();
              function arrayMap(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                while (++index < length) {
                  result[index] = iteratee(array[index], index, array);
                }
                return result;
              }
              function basePropertyOf(object) {
                return function(key) {
                  return object == null ? void 0 : object[key];
                };
              }
              var escapeHtmlChar = basePropertyOf(htmlEscapes);
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var nativeObjectToString = objectProto.toString;
              var Symbol2 = root.Symbol, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
              var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
              var templateSettings = {
                /**
                 * Used to detect `data` property values to be HTML-escaped.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "escape": reEscape,
                /**
                 * Used to detect code to be evaluated.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "evaluate": reEvaluate,
                /**
                 * Used to detect `data` property values to inject.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "interpolate": reInterpolate,
                /**
                 * Used to reference the data object in the template text.
                 *
                 * @memberOf _.templateSettings
                 * @type {string}
                 */
                "variable": "",
                /**
                 * Used to import variables into the compiled template.
                 *
                 * @memberOf _.templateSettings
                 * @type {Object}
                 */
                "imports": {
                  /**
                   * A reference to the `lodash` function.
                   *
                   * @memberOf _.templateSettings.imports
                   * @type {Function}
                   */
                  "_": { "escape": escape2 }
                }
              };
              function baseGetTag(value) {
                if (value == null) {
                  return value === void 0 ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
              }
              function baseToString(value) {
                if (typeof value == "string") {
                  return value;
                }
                if (isArray(value)) {
                  return arrayMap(value, baseToString) + "";
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : "";
                }
                var result = value + "";
                return result == "0" && 1 / value == -INFINITY ? "-0" : result;
              }
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                  value[symToStringTag] = void 0;
                  var unmasked = true;
                } catch (e) {
                }
                var result = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result;
              }
              function objectToString(value) {
                return nativeObjectToString.call(value);
              }
              var isArray = Array.isArray;
              function isObjectLike(value) {
                return value != null && typeof value == "object";
              }
              function isSymbol(value) {
                return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
              }
              function toString(value) {
                return value == null ? "" : baseToString(value);
              }
              function escape2(string) {
                string = toString(string);
                return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
              }
              module3.exports = templateSettings;
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "lodash._reinterpolate": 6 }],
        11: [function(require2, module3, exports3) {
          var root = require2("./_root");
          var Symbol2 = root.Symbol;
          module3.exports = Symbol2;
        }, { "./_root": 18 }],
        12: [function(require2, module3, exports3) {
          var Symbol2 = require2("./_Symbol"), getRawTag = require2("./_getRawTag"), objectToString = require2("./_objectToString");
          var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
          var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
          function baseGetTag(value) {
            if (value == null) {
              return value === void 0 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          module3.exports = baseGetTag;
        }, { "./_Symbol": 11, "./_getRawTag": 15, "./_objectToString": 16 }],
        13: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
              module3.exports = freeGlobal;
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        14: [function(require2, module3, exports3) {
          var overArg = require2("./_overArg");
          var getPrototype = overArg(Object.getPrototypeOf, Object);
          module3.exports = getPrototype;
        }, { "./_overArg": 17 }],
        15: [function(require2, module3, exports3) {
          var Symbol2 = require2("./_Symbol");
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var nativeObjectToString = objectProto.toString;
          var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = void 0;
              var unmasked = true;
            } catch (e) {
            }
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }
          module3.exports = getRawTag;
        }, { "./_Symbol": 11 }],
        16: [function(require2, module3, exports3) {
          var objectProto = Object.prototype;
          var nativeObjectToString = objectProto.toString;
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          module3.exports = objectToString;
        }, {}],
        17: [function(require2, module3, exports3) {
          function overArg(func, transform) {
            return function(arg) {
              return func(transform(arg));
            };
          }
          module3.exports = overArg;
        }, {}],
        18: [function(require2, module3, exports3) {
          var freeGlobal = require2("./_freeGlobal");
          var freeSelf = typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          module3.exports = root;
        }, { "./_freeGlobal": 13 }],
        19: [function(require2, module3, exports3) {
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          module3.exports = isObjectLike;
        }, {}],
        20: [function(require2, module3, exports3) {
          var baseGetTag = require2("./_baseGetTag"), getPrototype = require2("./_getPrototype"), isObjectLike = require2("./isObjectLike");
          var objectTag = "[object Object]";
          var funcProto = Function.prototype, objectProto = Object.prototype;
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var objectCtorString = funcToString.call(Object);
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          module3.exports = isPlainObject;
        }, { "./_baseGetTag": 12, "./_getPrototype": 14, "./isObjectLike": 19 }],
        21: [function(require2, module3, exports3) {
          var process2 = module3.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e2) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e2) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process2.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process2.title = "browser";
          process2.browser = true;
          process2.env = {};
          process2.argv = [];
          process2.version = "";
          process2.versions = {};
          function noop() {
          }
          process2.on = noop;
          process2.addListener = noop;
          process2.once = noop;
          process2.off = noop;
          process2.removeListener = noop;
          process2.removeAllListeners = noop;
          process2.emit = noop;
          process2.prependListener = noop;
          process2.prependOnceListener = noop;
          process2.listeners = function(name) {
            return [];
          };
          process2.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process2.cwd = function() {
            return "/";
          };
          process2.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process2.umask = function() {
            return 0;
          };
        }, {}],
        22: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.default = void 0;
          function createThunkMiddleware(extraArgument) {
            var middleware = function middleware2(_ref) {
              var dispatch = _ref.dispatch, getState = _ref.getState;
              return function(next) {
                return function(action) {
                  if (typeof action === "function") {
                    return action(dispatch, getState, extraArgument);
                  }
                  return next(action);
                };
              };
            };
            return middleware;
          }
          var thunk = createThunkMiddleware();
          thunk.withExtraArgument = createThunkMiddleware;
          var _default = thunk;
          exports3.default = _default;
        }, {}],
        23: [function(require2, module3, exports3) {
          "use strict";
          exports3.__esModule = true;
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          exports3["default"] = applyMiddleware;
          var _compose = require2("./compose");
          var _compose2 = _interopRequireDefault(_compose);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function applyMiddleware() {
            for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
              middlewares[_key] = arguments[_key];
            }
            return function(createStore) {
              return function(reducer, preloadedState, enhancer) {
                var store = createStore(reducer, preloadedState, enhancer);
                var _dispatch = store.dispatch;
                var chain = [];
                var middlewareAPI = {
                  getState: store.getState,
                  dispatch: function dispatch(action) {
                    return _dispatch(action);
                  }
                };
                chain = middlewares.map(function(middleware) {
                  return middleware(middlewareAPI);
                });
                _dispatch = _compose2["default"].apply(void 0, chain)(store.dispatch);
                return _extends({}, store, {
                  dispatch: _dispatch
                });
              };
            };
          }
        }, { "./compose": 26 }],
        24: [function(require2, module3, exports3) {
          "use strict";
          exports3.__esModule = true;
          exports3["default"] = bindActionCreators;
          function bindActionCreator(actionCreator, dispatch) {
            return function() {
              return dispatch(actionCreator.apply(void 0, arguments));
            };
          }
          function bindActionCreators(actionCreators, dispatch) {
            if (typeof actionCreators === "function") {
              return bindActionCreator(actionCreators, dispatch);
            }
            if (typeof actionCreators !== "object" || actionCreators === null) {
              throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? "null" : typeof actionCreators) + '. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
            }
            var keys = Object.keys(actionCreators);
            var boundActionCreators = {};
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              var actionCreator = actionCreators[key];
              if (typeof actionCreator === "function") {
                boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
              }
            }
            return boundActionCreators;
          }
        }, {}],
        25: [function(require2, module3, exports3) {
          (function(process2) {
            (function() {
              "use strict";
              exports3.__esModule = true;
              exports3["default"] = combineReducers;
              var _createStore = require2("./createStore");
              var _isPlainObject = require2("lodash/isPlainObject");
              var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
              var _warning = require2("./utils/warning");
              var _warning2 = _interopRequireDefault(_warning);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function getUndefinedStateErrorMessage(key, action) {
                var actionType = action && action.type;
                var actionName = actionType && '"' + actionType.toString() + '"' || "an action";
                return "Given action " + actionName + ', reducer "' + key + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.';
              }
              function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
                var reducerKeys = Object.keys(reducers);
                var argumentName = action && action.type === _createStore.ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
                if (reducerKeys.length === 0) {
                  return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
                }
                if (!(0, _isPlainObject2["default"])(inputState)) {
                  return "The " + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
                }
                var unexpectedKeys = Object.keys(inputState).filter(function(key) {
                  return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
                });
                unexpectedKeys.forEach(function(key) {
                  unexpectedKeyCache[key] = true;
                });
                if (unexpectedKeys.length > 0) {
                  return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
                }
              }
              function assertReducerShape(reducers) {
                Object.keys(reducers).forEach(function(key) {
                  var reducer = reducers[key];
                  var initialState = reducer(void 0, { type: _createStore.ActionTypes.INIT });
                  if (typeof initialState === "undefined") {
                    throw new Error('Reducer "' + key + "\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.");
                  }
                  var type = "@@redux/PROBE_UNKNOWN_ACTION_" + Math.random().toString(36).substring(7).split("").join(".");
                  if (typeof reducer(void 0, { type }) === "undefined") {
                    throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ("Don't try to handle " + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
                  }
                });
              }
              function combineReducers(reducers) {
                var reducerKeys = Object.keys(reducers);
                var finalReducers = {};
                for (var i = 0; i < reducerKeys.length; i++) {
                  var key = reducerKeys[i];
                  if (process2.env.NODE_ENV !== "production") {
                    if (typeof reducers[key] === "undefined") {
                      (0, _warning2["default"])('No reducer provided for key "' + key + '"');
                    }
                  }
                  if (typeof reducers[key] === "function") {
                    finalReducers[key] = reducers[key];
                  }
                }
                var finalReducerKeys = Object.keys(finalReducers);
                var unexpectedKeyCache = void 0;
                if (process2.env.NODE_ENV !== "production") {
                  unexpectedKeyCache = {};
                }
                var shapeAssertionError = void 0;
                try {
                  assertReducerShape(finalReducers);
                } catch (e) {
                  shapeAssertionError = e;
                }
                return function combination() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var action = arguments[1];
                  if (shapeAssertionError) {
                    throw shapeAssertionError;
                  }
                  if (process2.env.NODE_ENV !== "production") {
                    var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
                    if (warningMessage) {
                      (0, _warning2["default"])(warningMessage);
                    }
                  }
                  var hasChanged = false;
                  var nextState = {};
                  for (var _i2 = 0; _i2 < finalReducerKeys.length; _i2++) {
                    var _key = finalReducerKeys[_i2];
                    var reducer = finalReducers[_key];
                    var previousStateForKey = state[_key];
                    var nextStateForKey = reducer(previousStateForKey, action);
                    if (typeof nextStateForKey === "undefined") {
                      var errorMessage = getUndefinedStateErrorMessage(_key, action);
                      throw new Error(errorMessage);
                    }
                    nextState[_key] = nextStateForKey;
                    hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
                  }
                  return hasChanged ? nextState : state;
                };
              }
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./createStore": 27, "./utils/warning": 29, "_process": 21, "lodash/isPlainObject": 20 }],
        26: [function(require2, module3, exports3) {
          "use strict";
          exports3.__esModule = true;
          exports3["default"] = compose;
          function compose() {
            for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
              funcs[_key] = arguments[_key];
            }
            if (funcs.length === 0) {
              return function(arg) {
                return arg;
              };
            }
            if (funcs.length === 1) {
              return funcs[0];
            }
            return funcs.reduce(function(a, b) {
              return function() {
                return a(b.apply(void 0, arguments));
              };
            });
          }
        }, {}],
        27: [function(require2, module3, exports3) {
          "use strict";
          exports3.__esModule = true;
          exports3.ActionTypes = void 0;
          exports3["default"] = createStore;
          var _isPlainObject = require2("lodash/isPlainObject");
          var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
          var _symbolObservable = require2("symbol-observable");
          var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          var ActionTypes = exports3.ActionTypes = {
            INIT: "@@redux/INIT"
            /**
             * Creates a Redux store that holds the state tree.
             * The only way to change the data in the store is to call `dispatch()` on it.
             *
             * There should only be a single store in your app. To specify how different
             * parts of the state tree respond to actions, you may combine several reducers
             * into a single reducer function by using `combineReducers`.
             *
             * @param {Function} reducer A function that returns the next state tree, given
             * the current state tree and the action to handle.
             *
             * @param {any} [preloadedState] The initial state. You may optionally specify it
             * to hydrate the state from the server in universal apps, or to restore a
             * previously serialized user session.
             * If you use `combineReducers` to produce the root reducer function, this must be
             * an object with the same shape as `combineReducers` keys.
             *
             * @param {Function} [enhancer] The store enhancer. You may optionally specify it
             * to enhance the store with third-party capabilities such as middleware,
             * time travel, persistence, etc. The only store enhancer that ships with Redux
             * is `applyMiddleware()`.
             *
             * @returns {Store} A Redux store that lets you read the state, dispatch actions
             * and subscribe to changes.
             */
          };
          function createStore(reducer, preloadedState, enhancer) {
            var _ref2;
            if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
              enhancer = preloadedState;
              preloadedState = void 0;
            }
            if (typeof enhancer !== "undefined") {
              if (typeof enhancer !== "function") {
                throw new Error("Expected the enhancer to be a function.");
              }
              return enhancer(createStore)(reducer, preloadedState);
            }
            if (typeof reducer !== "function") {
              throw new Error("Expected the reducer to be a function.");
            }
            var currentReducer = reducer;
            var currentState = preloadedState;
            var currentListeners = [];
            var nextListeners = currentListeners;
            var isDispatching = false;
            function ensureCanMutateNextListeners() {
              if (nextListeners === currentListeners) {
                nextListeners = currentListeners.slice();
              }
            }
            function getState() {
              return currentState;
            }
            function subscribe(listener) {
              if (typeof listener !== "function") {
                throw new Error("Expected listener to be a function.");
              }
              var isSubscribed = true;
              ensureCanMutateNextListeners();
              nextListeners.push(listener);
              return function unsubscribe() {
                if (!isSubscribed) {
                  return;
                }
                isSubscribed = false;
                ensureCanMutateNextListeners();
                var index = nextListeners.indexOf(listener);
                nextListeners.splice(index, 1);
              };
            }
            function dispatch(action) {
              if (!(0, _isPlainObject2["default"])(action)) {
                throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
              }
              if (typeof action.type === "undefined") {
                throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
              }
              if (isDispatching) {
                throw new Error("Reducers may not dispatch actions.");
              }
              try {
                isDispatching = true;
                currentState = currentReducer(currentState, action);
              } finally {
                isDispatching = false;
              }
              var listeners = currentListeners = nextListeners;
              for (var i = 0; i < listeners.length; i++) {
                var listener = listeners[i];
                listener();
              }
              return action;
            }
            function replaceReducer(nextReducer) {
              if (typeof nextReducer !== "function") {
                throw new Error("Expected the nextReducer to be a function.");
              }
              currentReducer = nextReducer;
              dispatch({ type: ActionTypes.INIT });
            }
            function observable() {
              var _ref;
              var outerSubscribe = subscribe;
              return _ref = {
                /**
                 * The minimal observable subscription method.
                 * @param {Object} observer Any object that can be used as an observer.
                 * The observer object should have a `next` method.
                 * @returns {subscription} An object with an `unsubscribe` method that can
                 * be used to unsubscribe the observable from the store, and prevent further
                 * emission of values from the observable.
                 */
                subscribe: function subscribe2(observer) {
                  if (typeof observer !== "object") {
                    throw new TypeError("Expected the observer to be an object.");
                  }
                  function observeState() {
                    if (observer.next) {
                      observer.next(getState());
                    }
                  }
                  observeState();
                  var unsubscribe = outerSubscribe(observeState);
                  return { unsubscribe };
                }
              }, _ref[_symbolObservable2["default"]] = function() {
                return this;
              }, _ref;
            }
            dispatch({ type: ActionTypes.INIT });
            return _ref2 = {
              dispatch,
              subscribe,
              getState,
              replaceReducer
            }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
          }
        }, { "lodash/isPlainObject": 20, "symbol-observable": 33 }],
        28: [function(require2, module3, exports3) {
          (function(process2) {
            (function() {
              "use strict";
              exports3.__esModule = true;
              exports3.compose = exports3.applyMiddleware = exports3.bindActionCreators = exports3.combineReducers = exports3.createStore = void 0;
              var _createStore = require2("./createStore");
              var _createStore2 = _interopRequireDefault(_createStore);
              var _combineReducers = require2("./combineReducers");
              var _combineReducers2 = _interopRequireDefault(_combineReducers);
              var _bindActionCreators = require2("./bindActionCreators");
              var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
              var _applyMiddleware = require2("./applyMiddleware");
              var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
              var _compose = require2("./compose");
              var _compose2 = _interopRequireDefault(_compose);
              var _warning = require2("./utils/warning");
              var _warning2 = _interopRequireDefault(_warning);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              function isCrushed() {
              }
              if (process2.env.NODE_ENV !== "production" && typeof isCrushed.name === "string" && isCrushed.name !== "isCrushed") {
                (0, _warning2["default"])("You are currently using minified code outside of NODE_ENV === 'production'. This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) to ensure you have the correct code for your production build.");
              }
              exports3.createStore = _createStore2["default"];
              exports3.combineReducers = _combineReducers2["default"];
              exports3.bindActionCreators = _bindActionCreators2["default"];
              exports3.applyMiddleware = _applyMiddleware2["default"];
              exports3.compose = _compose2["default"];
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./applyMiddleware": 23, "./bindActionCreators": 24, "./combineReducers": 25, "./compose": 26, "./createStore": 27, "./utils/warning": 29, "_process": 21 }],
        29: [function(require2, module3, exports3) {
          "use strict";
          exports3.__esModule = true;
          exports3["default"] = warning;
          function warning(message) {
            if (typeof console !== "undefined" && typeof console.error === "function") {
              console.error(message);
            }
            try {
              throw new Error(message);
            } catch (e) {
            }
          }
        }, {}],
        30: [function(require2, module3, exports3) {
          "use strict";
          var Suggestions = require2("./src/suggestions");
          window.Suggestions = module3.exports = Suggestions;
        }, { "./src/suggestions": 32 }],
        31: [function(require2, module3, exports3) {
          "Use strict";
          var List = function(component) {
            this.component = component;
            this.items = [];
            this.active = 0;
            this.element = document.createElement("ul");
            this.element.className = "suggestions";
            this.selectingListItem = false;
            component.el.parentNode.insertBefore(this.element, component.el.nextSibling);
            return this;
          };
          List.prototype.show = function() {
            this.element.style.display = "block";
          };
          List.prototype.hide = function() {
            this.element.style.display = "none";
          };
          List.prototype.add = function(item) {
            this.items.push(item);
          };
          List.prototype.clear = function() {
            this.items = [];
            this.active = 0;
          };
          List.prototype.isEmpty = function() {
            return !this.items.length;
          };
          List.prototype.draw = function() {
            this.element.innerHTML = "";
            if (this.items.length === 0) {
              this.hide();
              return;
            }
            for (var i = 0; i < this.items.length; i++) {
              this.drawItem(this.items[i], this.active === i);
            }
            this.show();
          };
          List.prototype.drawItem = function(item, active) {
            var li2 = document.createElement("li"), a = document.createElement("a");
            if (active) li2.className += " active";
            a.innerHTML = item.string;
            li2.appendChild(a);
            this.element.appendChild(li2);
            li2.addEventListener("mousedown", (function() {
              this.selectingListItem = true;
            }).bind(this));
            li2.addEventListener("mouseup", (function() {
              this.handleMouseUp.call(this, item);
            }).bind(this));
          };
          List.prototype.handleMouseUp = function(item) {
            this.selectingListItem = false;
            this.component.value(item.original);
            this.clear();
            this.draw();
          };
          List.prototype.move = function(index) {
            this.active = index;
            this.draw();
          };
          List.prototype.previous = function() {
            this.move(this.active === 0 ? this.items.length - 1 : this.active - 1);
          };
          List.prototype.next = function() {
            this.move(this.active === this.items.length - 1 ? 0 : this.active + 1);
          };
          module3.exports = List;
        }, {}],
        32: [function(require2, module3, exports3) {
          "use strict";
          var extend = require2("xtend");
          var fuzzy = require2("fuzzy");
          var List = require2("./list");
          var Suggestions = function(el2, data, options) {
            options = options || {};
            this.options = extend({
              minLength: 2,
              limit: 5,
              filter: true
            }, options);
            this.el = el2;
            this.data = data || [];
            this.list = new List(this);
            this.query = "";
            this.selected = null;
            this.list.draw();
            this.el.addEventListener("keyup", (function(e) {
              this.handleKeyUp(e.keyCode);
            }).bind(this), false);
            this.el.addEventListener("keydown", (function(e) {
              this.handleKeyDown(e);
            }).bind(this));
            this.el.addEventListener("focus", (function() {
              this.handleFocus();
            }).bind(this));
            this.el.addEventListener("blur", (function() {
              this.handleBlur();
            }).bind(this));
            this.el.addEventListener("paste", (function(e) {
              this.handlePaste(e);
            }).bind(this));
            return this;
          };
          Suggestions.prototype.handleKeyUp = function(keyCode) {
            if (keyCode === 40 || keyCode === 38 || keyCode === 27 || keyCode === 13 || keyCode === 9) return;
            this.handleInputChange(this.el.value);
          };
          Suggestions.prototype.handleKeyDown = function(e) {
            switch (e.keyCode) {
              case 13:
              // ENTER
              case 9:
                e.preventDefault();
                if (!this.list.isEmpty()) {
                  this.value(this.list.items[this.list.active].original);
                  this.list.hide();
                }
                break;
              case 27:
                if (!this.list.isEmpty()) this.list.hide();
                break;
              case 38:
                this.list.previous();
                break;
              case 40:
                this.list.next();
                break;
            }
          };
          Suggestions.prototype.handleBlur = function() {
            if (!this.list.selectingListItem) {
              this.list.hide();
            }
          };
          Suggestions.prototype.handlePaste = function(e) {
            if (e.clipboardData) {
              this.handleInputChange(e.clipboardData.getData("Text"));
            } else {
              var self2 = this;
              setTimeout(function() {
                self2.handleInputChange(e.target.value);
              }, 100);
            }
          };
          Suggestions.prototype.handleInputChange = function(query) {
            this.query = this.normalize(query);
            this.list.clear();
            if (this.query.length < this.options.minLength) {
              this.list.draw();
              return;
            }
            this.getCandidates((function(data) {
              for (var i = 0; i < data.length; i++) {
                this.list.add(data[i]);
                if (i === this.options.limit - 1) break;
              }
              this.list.draw();
            }).bind(this));
          };
          Suggestions.prototype.handleFocus = function() {
            if (!this.list.isEmpty()) this.list.show();
            this.list.selectingListItem = false;
          };
          Suggestions.prototype.update = function(revisedData) {
            this.data = revisedData;
            this.handleKeyUp();
          };
          Suggestions.prototype.clear = function() {
            this.data = [];
            this.list.clear();
          };
          Suggestions.prototype.normalize = function(value) {
            value = value.toLowerCase();
            return value;
          };
          Suggestions.prototype.match = function(candidate, query) {
            return candidate.indexOf(query) > -1;
          };
          Suggestions.prototype.value = function(value) {
            this.selected = value;
            this.el.value = this.getItemValue(value);
            if (document.createEvent) {
              var e = document.createEvent("HTMLEvents");
              e.initEvent("change", true, false);
              this.el.dispatchEvent(e);
            } else {
              this.el.fireEvent("onchange");
            }
          };
          Suggestions.prototype.getCandidates = function(callback) {
            var options = {
              pre: "<strong>",
              post: "</strong>",
              extract: (function(d) {
                return this.getItemValue(d);
              }).bind(this)
            };
            var results = this.options.filter ? fuzzy.filter(this.query, this.data, options) : this.data.map((function(d) {
              var boldString = this.getItemValue(d);
              var indexString = this.normalize(boldString);
              var indexOfQuery = indexString.lastIndexOf(this.query);
              while (indexOfQuery > -1) {
                var endIndexOfQuery = indexOfQuery + this.query.length;
                boldString = boldString.slice(0, indexOfQuery) + "<strong>" + boldString.slice(indexOfQuery, endIndexOfQuery) + "</strong>" + boldString.slice(endIndexOfQuery);
                indexOfQuery = indexString.slice(0, indexOfQuery).lastIndexOf(this.query);
              }
              return {
                original: d,
                string: boldString
              };
            }).bind(this));
            callback(results);
          };
          Suggestions.prototype.getItemValue = function(item) {
            return item;
          };
          module3.exports = Suggestions;
        }, { "./list": 31, "fuzzy": 4, "xtend": 37 }],
        33: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              "use strict";
              Object.defineProperty(exports3, "__esModule", {
                value: true
              });
              var _ponyfill = require2("./ponyfill.js");
              var _ponyfill2 = _interopRequireDefault(_ponyfill);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { "default": obj };
              }
              var root;
              if (typeof self !== "undefined") {
                root = self;
              } else if (typeof window !== "undefined") {
                root = window;
              } else if (typeof global2 !== "undefined") {
                root = global2;
              } else if (typeof module3 !== "undefined") {
                root = module3;
              } else {
                root = Function("return this")();
              }
              var result = (0, _ponyfill2["default"])(root);
              exports3["default"] = result;
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./ponyfill.js": 34 }],
        34: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = symbolObservablePonyfill;
          function symbolObservablePonyfill(root) {
            var result;
            var _Symbol = root.Symbol;
            if (typeof _Symbol === "function") {
              if (_Symbol.observable) {
                result = _Symbol.observable;
              } else {
                result = _Symbol("observable");
                _Symbol.observable = result;
              }
            } else {
              result = "@@observable";
            }
            return result;
          }
          ;
        }, {}],
        35: [function(require2, module3, exports3) {
          var each = require2("turf-meta").coordEach;
          module3.exports = function(layer) {
            var extent = [Infinity, Infinity, -Infinity, -Infinity];
            each(layer, function(coord) {
              if (extent[0] > coord[0]) extent[0] = coord[0];
              if (extent[1] > coord[1]) extent[1] = coord[1];
              if (extent[2] < coord[0]) extent[2] = coord[0];
              if (extent[3] < coord[1]) extent[3] = coord[1];
            });
            return extent;
          };
        }, { "turf-meta": 36 }],
        36: [function(require2, module3, exports3) {
          function coordEach(layer, callback, excludeWrapCoord) {
            var i, j, k, g, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, isGeometryCollection, isFeatureCollection = layer.type === "FeatureCollection", isFeature = layer.type === "Feature", stop = isFeatureCollection ? layer.features.length : 1;
            for (i = 0; i < stop; i++) {
              geometryMaybeCollection = isFeatureCollection ? layer.features[i].geometry : isFeature ? layer.geometry : layer;
              isGeometryCollection = geometryMaybeCollection.type === "GeometryCollection";
              stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
              for (g = 0; g < stopG; g++) {
                geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
                coords = geometry.coordinates;
                wrapShrink = excludeWrapCoord && (geometry.type === "Polygon" || geometry.type === "MultiPolygon") ? 1 : 0;
                if (geometry.type === "Point") {
                  callback(coords);
                } else if (geometry.type === "LineString" || geometry.type === "MultiPoint") {
                  for (j = 0; j < coords.length; j++) callback(coords[j]);
                } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
                  for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length - wrapShrink; k++)
                      callback(coords[j][k]);
                } else if (geometry.type === "MultiPolygon") {
                  for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length; k++)
                      for (l = 0; l < coords[j][k].length - wrapShrink; l++)
                        callback(coords[j][k][l]);
                } else {
                  throw new Error("Unknown Geometry Type");
                }
              }
            }
          }
          module3.exports.coordEach = coordEach;
          function coordReduce(layer, callback, memo, excludeWrapCoord) {
            coordEach(layer, function(coord) {
              memo = callback(memo, coord);
            }, excludeWrapCoord);
            return memo;
          }
          module3.exports.coordReduce = coordReduce;
          function propEach(layer, callback) {
            var i;
            switch (layer.type) {
              case "FeatureCollection":
                features = layer.features;
                for (i = 0; i < layer.features.length; i++) {
                  callback(layer.features[i].properties);
                }
                break;
              case "Feature":
                callback(layer.properties);
                break;
            }
          }
          module3.exports.propEach = propEach;
          function propReduce(layer, callback, memo) {
            propEach(layer, function(prop) {
              memo = callback(memo, prop);
            });
            return memo;
          }
          module3.exports.propReduce = propReduce;
        }, {}],
        37: [function(require2, module3, exports3) {
          module3.exports = extend;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function extend() {
            var target = {};
            for (var i = 0; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          }
        }, {}],
        38: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.queryOrigin = queryOrigin;
          exports3.queryDestination = queryDestination;
          exports3.queryOriginCoordinates = queryOriginCoordinates;
          exports3.queryDestinationCoordinates = queryDestinationCoordinates;
          exports3.clearOrigin = clearOrigin;
          exports3.clearDestination = clearDestination;
          exports3.setOptions = setOptions;
          exports3.hoverMarker = hoverMarker;
          exports3.setRouteIndex = setRouteIndex;
          exports3.createOrigin = createOrigin;
          exports3.createDestination = createDestination;
          exports3.setProfile = setProfile;
          exports3.reverse = reverse;
          exports3.setOriginFromCoordinates = setOriginFromCoordinates;
          exports3.setDestinationFromCoordinates = setDestinationFromCoordinates;
          exports3.addWaypoint = addWaypoint;
          exports3.setWaypoint = setWaypoint;
          exports3.removeWaypoint = removeWaypoint;
          exports3.eventSubscribe = eventSubscribe;
          exports3.eventEmit = eventEmit;
          var _action_types = require2("../constants/action_types");
          var types = _interopRequireWildcard(_action_types);
          var _utils = require2("../utils");
          var _utils2 = _interopRequireDefault(_utils);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
              }
              newObj.default = obj;
              return newObj;
            }
          }
          var request = new XMLHttpRequest();
          function originPoint(coordinates) {
            return function(dispatch) {
              var origin = _utils2.default.createPoint(coordinates, {
                id: "origin",
                "marker-symbol": "A"
              });
              dispatch({ type: types.ORIGIN, origin });
              dispatch(eventEmit("origin", { feature: origin }));
            };
          }
          function destinationPoint(coordinates) {
            return function(dispatch) {
              var destination = _utils2.default.createPoint(coordinates, {
                id: "destination",
                "marker-symbol": "B"
              });
              dispatch({ type: types.DESTINATION, destination });
              dispatch(eventEmit("destination", { feature: destination }));
            };
          }
          function setDirections(directions) {
            return function(dispatch) {
              dispatch({
                type: types.DIRECTIONS,
                directions
              });
              dispatch(eventEmit("route", { route: directions }));
            };
          }
          function updateWaypoints(waypoints) {
            return {
              type: types.WAYPOINTS,
              waypoints
            };
          }
          function setHoverMarker(feature) {
            return {
              type: types.HOVER_MARKER,
              hoverMarker: feature
            };
          }
          function fetchDirections() {
            return function(dispatch, getState) {
              var _getState = getState(), api = _getState.api, routeIndex = _getState.routeIndex, profile = _getState.profile, alternatives = _getState.alternatives, congestion = _getState.congestion, destination = _getState.destination, language = _getState.language, exclude = _getState.exclude;
              if (!(destination && destination.geometry)) return;
              var query = buildDirectionsQuery(getState);
              var options = [];
              options.push("geometries=polyline");
              if (alternatives) options.push("alternatives=true");
              if (congestion) options.push("annotations=congestion");
              options.push("steps=true");
              options.push("overview=full");
              request.abort();
              request.open("GET", "" + api + profile + "/" + query + ".json?" + options.join("&"), true);
              request.onload = function() {
                if (request.status >= 200 && request.status < 400) {
                  var data = JSON.parse(request.responseText);
                  if (data.error) {
                    dispatch(setDirections([]));
                    return dispatch(setError(data.error));
                  }
                  dispatch(setError(null));
                  if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));
                  dispatch(setDirections(data.routes));
                  dispatch(originPoint(data.waypoints[0].location));
                  dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));
                } else {
                  dispatch(setDirections([]));
                  return dispatch(setError(JSON.parse(request.responseText).message));
                }
              };
              request.onerror = function() {
                dispatch(setDirections([]));
                return dispatch(setError(JSON.parse(request.responseText).message));
              };
              request.send();
            };
          }
          function buildDirectionsQuery(state) {
            var _state = state(), origin = _state.origin, destination = _state.destination, waypoints = _state.waypoints;
            var query = [];
            query.push(origin.geometry.coordinates.join(","));
            query.push(";");
            if (waypoints.length) {
              waypoints.forEach(function(waypoint) {
                query.push(waypoint.geometry.coordinates.join(","));
                query.push(";");
              });
            }
            query.push(destination.geometry.coordinates.join(","));
            return encodeURIComponent(query.join(""));
          }
          function normalizeWaypoint(waypoint) {
            var properties = { id: "waypoint" };
            return Object.assign(waypoint, {
              properties: waypoint.properties ? Object.assign(waypoint.properties, properties) : properties
            });
          }
          function setError(error) {
            return function(dispatch) {
              dispatch({
                type: "ERROR",
                error
              });
              if (error) dispatch(eventEmit("error", { error }));
            };
          }
          function queryOrigin(query) {
            return {
              type: types.ORIGIN_QUERY,
              query
            };
          }
          function queryDestination(query) {
            return {
              type: types.DESTINATION_QUERY,
              query
            };
          }
          function queryOriginCoordinates(coords) {
            return {
              type: types.ORIGIN_FROM_COORDINATES,
              coordinates: coords
            };
          }
          function queryDestinationCoordinates(coords) {
            return {
              type: types.DESTINATION_FROM_COORDINATES,
              coordinates: coords
            };
          }
          function clearOrigin() {
            return function(dispatch) {
              dispatch({
                type: types.ORIGIN_CLEAR
              });
              dispatch(eventEmit("clear", { type: "origin" }));
              dispatch(setError(null));
            };
          }
          function clearDestination() {
            return function(dispatch) {
              dispatch({
                type: types.DESTINATION_CLEAR
              });
              dispatch(eventEmit("clear", { type: "destination" }));
              dispatch(setError(null));
            };
          }
          function setOptions(options) {
            return {
              type: types.SET_OPTIONS,
              options
            };
          }
          function hoverMarker(coordinates) {
            return function(dispatch) {
              var feature = coordinates ? _utils2.default.createPoint(coordinates, { id: "hover" }) : {};
              dispatch(setHoverMarker(feature));
            };
          }
          function setRouteIndex(routeIndex) {
            return {
              type: types.ROUTE_INDEX,
              routeIndex
            };
          }
          function createOrigin(coordinates) {
            return function(dispatch, getState) {
              var _getState2 = getState(), destination = _getState2.destination;
              dispatch(originPoint(coordinates));
              if (destination.geometry) dispatch(fetchDirections());
            };
          }
          function createDestination(coordinates) {
            return function(dispatch, getState) {
              var _getState3 = getState(), origin = _getState3.origin;
              dispatch(destinationPoint(coordinates));
              if (origin.geometry) dispatch(fetchDirections());
            };
          }
          function setProfile(profile) {
            return function(dispatch, getState) {
              var _getState4 = getState(), origin = _getState4.origin, destination = _getState4.destination;
              dispatch({ type: types.DIRECTIONS_PROFILE, profile });
              dispatch(eventEmit("profile", { profile }));
              if (origin.geometry && destination.geometry) dispatch(fetchDirections());
            };
          }
          function reverse() {
            return function(dispatch, getState) {
              var state = getState();
              if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));
              if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));
              if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());
              var suggestions = document.getElementsByClassName("suggestions");
              for (var i = 0; i < suggestions.length; i++) {
                suggestions[i].style.visibility = "hidden";
              }
              ;
            };
          }
          function setOriginFromCoordinates(coords) {
            return function(dispatch) {
              if (!_utils2.default.validCoords(coords)) coords = [_utils2.default.wrap(coords[0]), _utils2.default.wrap(coords[1])];
              if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error("Coordinates are not valid")));
              dispatch(queryOriginCoordinates(coords));
              dispatch(createOrigin(coords));
            };
          }
          function setDestinationFromCoordinates(coords) {
            return function(dispatch) {
              if (!_utils2.default.validCoords(coords)) coords = [_utils2.default.wrap(coords[0]), _utils2.default.wrap(coords[1])];
              if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error("Coordinates are not valid")));
              dispatch(createDestination(coords));
              dispatch(queryDestinationCoordinates(coords));
            };
          }
          function addWaypoint(index, waypoint) {
            return function(dispatch, getState) {
              var _getState5 = getState(), destination = _getState5.destination, waypoints = _getState5.waypoints;
              waypoints.splice(index, 0, normalizeWaypoint(waypoint));
              dispatch(updateWaypoints(waypoints));
              if (destination.geometry) dispatch(fetchDirections());
            };
          }
          function setWaypoint(index, waypoint) {
            return function(dispatch, getState) {
              var _getState6 = getState(), destination = _getState6.destination, waypoints = _getState6.waypoints;
              waypoints[index] = normalizeWaypoint(waypoint);
              dispatch(updateWaypoints(waypoints));
              if (destination.geometry) dispatch(fetchDirections());
            };
          }
          function removeWaypoint(waypoint) {
            return function(dispatch, getState) {
              var _getState7 = getState(), destination = _getState7.destination, waypoints = _getState7.waypoints;
              waypoints = waypoints.filter(function(way) {
                return !_utils2.default.coordinateMatch(way, waypoint);
              });
              dispatch(updateWaypoints(waypoints));
              if (destination.geometry) dispatch(fetchDirections());
            };
          }
          function eventSubscribe(type, fn2) {
            return function(dispatch, getState) {
              var _getState8 = getState(), events = _getState8.events;
              events[type] = events[type] || [];
              events[type].push(fn2);
              return {
                type: types.EVENTS,
                events
              };
            };
          }
          function eventEmit(type, data) {
            var _this = this;
            return function(dispatch, getState) {
              var _getState9 = getState(), events = _getState9.events;
              if (!events[type]) {
                return {
                  type: types.EVENTS,
                  events
                };
              }
              var listeners = events[type].slice();
              for (var i = 0; i < listeners.length; i++) {
                listeners[i].call(_this, data);
              }
            };
          }
        }, { "../constants/action_types": 39, "../utils": 47 }],
        39: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var DESTINATION = exports3.DESTINATION = "DESTINATION";
          var DESTINATION_CLEAR = exports3.DESTINATION_CLEAR = "DESTINATION_CLEAR";
          var DESTINATION_QUERY = exports3.DESTINATION_QUERY = "DESTINATION_QUERY";
          var DESTINATION_FROM_COORDINATES = exports3.DESTINATION_FROM_COORDINATES = "DESTINATION_FROM_COORDINATES";
          var DIRECTIONS = exports3.DIRECTIONS = "DIRECTIONS";
          var DIRECTIONS_PROFILE = exports3.DIRECTIONS_PROFILE = "DIRECTIONS_PROFILE";
          var EVENTS = exports3.EVENTS = "EVENTS";
          var ERROR = exports3.ERROR = "ERROR";
          var HOVER_MARKER = exports3.HOVER_MARKER = "HOVER_MARKER";
          var ORIGIN = exports3.ORIGIN = "ORIGIN";
          var ORIGIN_CLEAR = exports3.ORIGIN_CLEAR = "ORIGIN_CLEAR";
          var ORIGIN_QUERY = exports3.ORIGIN_QUERY = "ORIGIN_QUERY";
          var ORIGIN_FROM_COORDINATES = exports3.ORIGIN_FROM_COORDINATES = "ORIGIN_FROM_COORDINATES";
          var ROUTE_INDEX = exports3.ROUTE_INDEX = "ROUTE_INDEX";
          var SET_OPTIONS = exports3.SET_OPTIONS = "SET_OPTIONS";
          var WAYPOINTS = exports3.WAYPOINTS = "WAYPOINTS";
        }, {}],
        40: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var _createClass = /* @__PURE__ */ function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _suggestions = require2("suggestions");
          var _suggestions2 = _interopRequireDefault(_suggestions);
          var _lodash = require2("lodash.debounce");
          var _lodash2 = _interopRequireDefault(_lodash);
          var _events = require2("events");
          var _utils = require2("../utils");
          var _utils2 = _interopRequireDefault(_utils);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _UrlExists(url) {
            var http = new XMLHttpRequest();
            http.open(url, true);
            http.send();
            if (http.status != 404) {
              return true;
            } else {
              return false;
            }
          }
          var Geocoder = function() {
            function Geocoder2(options) {
              _classCallCheck(this, Geocoder2);
              this._ev = new _events.EventEmitter();
              this.options = options;
              this.api = options && options.api || "https://nominatim.openstreetmap.org/search?format=geojson&limit=5&q=";
            }
            _createClass(Geocoder2, [
              {
                key: "onAdd",
                value: function onAdd(map2) {
                  this._map = map2;
                  this.request = new XMLHttpRequest();
                  var el2 = document.createElement("div");
                  el2.className = "maplibregl-ctrl-geocoder";
                  var icon = document.createElement("span");
                  icon.className = "geocoder-icon geocoder-icon-search";
                  var input = this._inputEl = document.createElement("input");
                  input.type = "text";
                  input.placeholder = this.options.placeholder;
                  input.addEventListener("keydown", (0, _lodash2.default)((function(e) {
                    if (!e.target.value) return this._clearEl.classList.remove("active");
                    if (e.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(e.keyCode) !== -1) return;
                    this._queryFromInput(e.target.value);
                  }).bind(this)), 200);
                  input.addEventListener("change", (function(e) {
                    if (e.target.value) this._clearEl.classList.add("active");
                    var selected = this._typeahead.selected;
                    if (selected) {
                      if (this.options.flyTo) {
                        if (selected.bbox && selected.context && selected.context.length <= 3 || selected.bbox && !selected.context) {
                          var bbox = selected.bbox;
                          map2.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]]);
                        } else {
                          map2.flyTo({
                            center: selected.center,
                            zoom: this.options.zoom
                          });
                        }
                      }
                      this._input = selected;
                      this.fire("result", { result: selected });
                    }
                  }).bind(this));
                  var actions = document.createElement("div");
                  actions.classList.add("geocoder-pin-right");
                  var clear = this._clearEl = document.createElement("button");
                  clear.className = "geocoder-icon geocoder-icon-close";
                  clear.addEventListener("click", this._clear.bind(this));
                  var loading = this._loadingEl = document.createElement("span");
                  loading.className = "geocoder-icon geocoder-icon-loading";
                  actions.appendChild(clear);
                  actions.appendChild(loading);
                  el2.appendChild(icon);
                  el2.appendChild(input);
                  el2.appendChild(actions);
                  if (this.options.container) this.options.position = false;
                  this._typeahead = new _suggestions2.default(input, [], { filter: false });
                  this._typeahead.getItemValue = function(item) {
                    return item.properties.display_name;
                  };
                  return el2;
                }
              },
              {
                key: "_geocode",
                value: function _geocode(q, callback) {
                  this._loadingEl.classList.add("active");
                  this.fire("loading");
                  var geocodingOptions = this.options;
                  var exclude = ["placeholder", "zoom", "flyTo", "api"];
                  var options = Object.keys(this.options).filter(function(key) {
                    return exclude.indexOf(key) === -1;
                  }).map(function(key) {
                    return key + "=" + geocodingOptions[key];
                  });
                  this.request.abort();
                  var xurl = this.api + encodeURIComponent(q.trim()) + "&" + options.join("&");
                  var url0 = this.api + encodeURIComponent(q.trim()) + "&" + options.join("&");
                  var url1 = this.api + encodeURIComponent(q.trim()) + "?overview=false";
                  var url2 = this.api2 + encodeURIComponent(q.trim()) + "?overview=false";
                  isMandeha = _UrlExists(url0);
                  if (isMandeha) {
                    this.request.open("GET", url0, true);
                  } else {
                    isMandeha = _UrlExists(url1);
                    if (isMandeha) {
                      this.request.open("GET", url1, true);
                    } else {
                      this.request.open("GET", url2, true);
                    }
                  }
                  this.request.onload = (function() {
                    this._loadingEl.classList.remove("active");
                    if (this.request.status >= 200 && this.request.status < 400) {
                      var data = JSON.parse(this.request.responseText);
                      if (data.features.length) {
                        this._clearEl.classList.add("active");
                      } else {
                        this._clearEl.classList.remove("active");
                        this._typeahead.selected = null;
                      }
                      this.fire("results", { results: data.features });
                      this._typeahead.update(data.features);
                      return callback(data.features);
                    } else {
                      this.fire("error", { error: JSON.parse(this.request.responseText).message });
                    }
                  }).bind(this);
                  this.request.onerror = (function() {
                    this._loadingEl.classList.remove("active");
                    this.fire("error", { error: JSON.parse(this.request.responseText).message });
                  }).bind(this);
                  this.request.send();
                }
              },
              {
                key: "_queryFromInput",
                value: function _queryFromInput(q) {
                  q = q.trim();
                  if (!q) this._clear();
                  if (q.length > 2) {
                    this._geocode(q, (function(results) {
                      this._results = results;
                    }).bind(this));
                  }
                }
              },
              {
                key: "_change",
                value: function _change() {
                  var onChange = document.createEvent("HTMLEvents");
                  onChange.initEvent("change", true, false);
                  this._inputEl.dispatchEvent(onChange);
                }
              },
              {
                key: "_query",
                value: function _query(input) {
                  if (!input) return;
                  if ((typeof input === "undefined" ? "undefined" : _typeof(input)) === "object" && input.length) {
                    input = [_utils2.default.wrap(input[0]), _utils2.default.wrap(input[1])].join();
                  }
                  this._geocode(input, (function(results) {
                    if (!results.length) return;
                    var result = results[0];
                    this._results = results;
                    this._typeahead.selected = result;
                    this._inputEl.value = result.properties.display_name;
                    this._change();
                  }).bind(this));
                }
              },
              {
                key: "_setInput",
                value: function _setInput(input) {
                  if (!input) return;
                  if ((typeof input === "undefined" ? "undefined" : _typeof(input)) === "object" && input.length) {
                    input = [_utils2.default.roundWithOriginalPrecision(_utils2.default.wrap(input[0]), input[0]), _utils2.default.roundWithOriginalPrecision(_utils2.default.wrap(input[1]), input[1])].join();
                  }
                  this._inputEl.value = input;
                  this._input = null;
                  this._typeahead.selected = null;
                  this._typeahead.clear();
                  this._change();
                }
              },
              {
                key: "_clear",
                value: function _clear() {
                  this._input = null;
                  this._inputEl.value = "";
                  this._typeahead.selected = null;
                  this._typeahead.clear();
                  this._change();
                  this._inputEl.focus();
                  this._clearEl.classList.remove("active");
                  this.fire("clear");
                }
              },
              {
                key: "getResult",
                value: function getResult() {
                  return this._input;
                }
                /**
                 * Set & query the input
                 * @param {Array|String} query An array of coordinates [lng, lat] or location name as a string.
                 * @returns {Geocoder} this
                 */
              },
              {
                key: "query",
                value: function query(_query2) {
                  this._query(_query2);
                  return this;
                }
                /**
                 * Set input
                 * @param {Array|String} value An array of coordinates [lng, lat] or location name as a string. Calling this function just sets the input and does not trigger an API request.
                 * @returns {Geocoder} this
                 */
              },
              {
                key: "setInput",
                value: function setInput(value) {
                  this._setInput(value);
                  return this;
                }
                /**
                 * Subscribe to events that happen within the plugin.
                 * @param {String} type name of event. Available events and the data passed into their respective event objects are:
                 *
                 * - __clear__ `Emitted when the input is cleared`
                 * - __loading__ `Emitted when the geocoder is looking up a query`
                 * - __results__ `{ results } Fired when the geocoder returns a response`
                 * - __result__ `{ result } Fired when input is set`
                 * - __error__ `{ error } Error as string`
                 * @param {Function} fn function that's called when the event is emitted.
                 * @returns {Geocoder} this;
                 */
              },
              {
                key: "on",
                value: function on2(type, fn2) {
                  this._ev.on(type, fn2);
                  this._ev.on("error", function(err) {
                    console.log(err);
                  });
                  return this;
                }
                /**
                 * Fire an event
                 * @param {String} type event name.
                 * @param {Object} data event data to pass to the function subscribed.
                 * @returns {Geocoder} this
                 */
              },
              {
                key: "fire",
                value: function fire(type, data) {
                  this._ev.emit(type, data);
                  return this;
                }
                /**
                 * Remove an event
                 * @returns {Geocoder} this
                 * @param {String} type Event name.
                 * @param {Function} fn Function that should unsubscribe to the event emitted.
                 */
              },
              {
                key: "off",
                value: function off(type, fn2) {
                  this._ev.removeListener(type, fn2);
                  return this;
                }
              }
            ]);
            return Geocoder2;
          }();
          exports3.default = Geocoder;
          ;
        }, { "../utils": 47, "events": 3, "lodash.debounce": 7, "suggestions": 30 }],
        41: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass = /* @__PURE__ */ function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _geocoder = require2("./geocoder");
          var _geocoder2 = _interopRequireDefault(_geocoder);
          var _lodash = require2("lodash.template");
          var _lodash2 = _interopRequireDefault(_lodash);
          var _lodash3 = require2("lodash.isequal");
          var _lodash4 = _interopRequireDefault(_lodash3);
          var _turfExtent = require2("turf-extent");
          var _turfExtent2 = _interopRequireDefault(_turfExtent);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var tmpl = (0, _lodash2.default)("<div class='maplibre-directions-component maplibre-directions-inputs'>\n  <div class='maplibre-directions-component-keyline'>\n    <div class='maplibre-directions-origin'>\n      <label class='maplibre-form-label'>\n        <span class='directions-icon directions-icon-depart'></span>\n      </label>\n      <div id='maplibre-directions-origin-input'></div>\n    </div>\n\n    <button\n      class='directions-icon directions-icon-reverse directions-reverse js-reverse-inputs'\n      title='Reverse origin &amp; destination'>\n    </button>\n\n    <div class='maplibre-directions-destination'>\n      <label class='maplibre-form-label'>\n        <span class='directions-icon directions-icon-arrive'></span>\n      </label>\n      <div id='maplibre-directions-destination-input'></div>\n    </div>\n  </div>\n\n  <% if (controls.profileSwitcher) { %>\n  <div class='maplibre-directions-profile maplibre-directions-component-keyline maplibre-directions-clearfix'><input\n      id='maplibre-directions-profile-driving-traffic'\n      type='radio'\n      name='profile'\n      value='maplibre/driving-traffic'\n      <% if (profile === 'maplibre/driving-traffic') { %>checked<% } %>\n    />\n    <label for='maplibre-directions-profile-driving-traffic'>Traffic</label>\n    <input\n      id='maplibre-directions-profile-driving'\n      type='radio'\n      name='profile'\n      value='maplibre/driving'\n      <% if (profile === 'maplibre/driving') { %>checked<% } %>\n    />\n    <label for='maplibre-directions-profile-driving'>Driving</label>\n    <input\n      id='maplibre-directions-profile-walking'\n      type='radio'\n      name='profile'\n      value='maplibre/walking'\n      <% if (profile === 'maplibre/walking') { %>checked<% } %>\n    />\n    <label for='maplibre-directions-profile-walking'>Walking</label>\n    <input\n      id='maplibre-directions-profile-cycling'\n      type='radio'\n      name='profile'\n      value='maplibre/cycling'\n      <% if (profile === 'maplibre/cycling') { %>checked<% } %>\n    />\n    <label for='maplibre-directions-profile-cycling'>Cycling</label>\n  </div>\n  <% } %>\n</div>\n");
          var Inputs = function() {
            function Inputs2(el2, store, actions, map2) {
              _classCallCheck(this, Inputs2);
              var _store$getState = store.getState(), originQuery = _store$getState.originQuery, destinationQuery = _store$getState.destinationQuery, profile = _store$getState.profile, controls = _store$getState.controls;
              el2.innerHTML = tmpl({
                originQuery,
                destinationQuery,
                profile,
                controls
              });
              this.container = el2;
              this.actions = actions;
              this.store = store;
              this._map = map2;
              this.onAdd();
              this.render();
            }
            _createClass(Inputs2, [{
              key: "animateToCoordinates",
              value: function animateToCoordinates(mode, coords) {
                var _store$getState2 = this.store.getState(), origin = _store$getState2.origin, destination = _store$getState2.destination, routePadding = _store$getState2.routePadding;
                if (origin.geometry && destination.geometry && !(0, _lodash4.default)(origin.geometry, destination.geometry)) {
                  var bb = (0, _turfExtent2.default)({
                    type: "FeatureCollection",
                    features: [origin, destination]
                  });
                  this._map.fitBounds([[bb[0], bb[1]], [bb[2], bb[3]]], { padding: routePadding });
                } else {
                  this._map.flyTo({ center: coords });
                }
              }
            }, {
              key: "onAdd",
              value: function onAdd() {
                var _this = this;
                var _actions = this.actions, clearOrigin = _actions.clearOrigin, clearDestination = _actions.clearDestination, createOrigin = _actions.createOrigin, createDestination = _actions.createDestination, setProfile = _actions.setProfile, reverse = _actions.reverse;
                var _store$getState3 = this.store.getState(), geocoder = _store$getState3.geocoder, flyTo = _store$getState3.flyTo, placeholderOrigin = _store$getState3.placeholderOrigin, placeholderDestination = _store$getState3.placeholderDestination, zoom = _store$getState3.zoom;
                this.originInput = new _geocoder2.default(Object.assign({}, {}, geocoder, { flyTo, placeholder: placeholderOrigin, zoom }));
                var originEl = this.originInput.onAdd(this._map);
                var originContainerEl = this.container.querySelector("#maplibre-directions-origin-input");
                originContainerEl.appendChild(originEl);
                this.destinationInput = new _geocoder2.default(Object.assign({}, {}, geocoder, { flyTo, placeholder: placeholderDestination, zoom }));
                var destinationEl = this.destinationInput.onAdd(this._map);
                this.container.querySelector("#maplibre-directions-destination-input").appendChild(destinationEl);
                this.originInput.on("result", function(e) {
                  var coords = e.result.geometry.coordinates;
                  createOrigin(coords);
                  _this.animateToCoordinates("origin", coords);
                });
                this.originInput.on("clear", clearOrigin);
                this.destinationInput.on("result", function(e) {
                  var coords = e.result.geometry.coordinates;
                  createDestination(coords);
                  _this.animateToCoordinates("destination", coords);
                });
                this.destinationInput.on("clear", clearDestination);
                var profiles = this.container.querySelectorAll('input[type="radio"]');
                Array.prototype.forEach.call(profiles, function(el2) {
                  el2.addEventListener("change", function() {
                    setProfile(el2.value);
                  });
                });
                this.container.querySelector(".js-reverse-inputs").addEventListener("click", function() {
                  var _store$getState4 = _this.store.getState(), origin = _store$getState4.origin, destination = _store$getState4.destination;
                  if (origin) _this.actions.queryDestination(origin.geometry.coordinates);
                  if (destination) _this.actions.queryOrigin(destination.geometry.coordinates);
                  reverse();
                });
              }
            }, {
              key: "render",
              value: function render() {
                var _this2 = this;
                this.store.subscribe(function() {
                  var _store$getState5 = _this2.store.getState(), originQuery = _store$getState5.originQuery, destinationQuery = _store$getState5.destinationQuery, originQueryCoordinates = _store$getState5.originQueryCoordinates, destinationQueryCoordinates = _store$getState5.destinationQueryCoordinates;
                  if (originQuery) {
                    _this2.originInput.query(originQuery);
                    _this2.actions.queryOrigin(null);
                  }
                  if (destinationQuery) {
                    _this2.destinationInput.query(destinationQuery);
                    _this2.actions.queryDestination(null);
                  }
                  if (originQueryCoordinates) {
                    _this2.originInput.setInput(originQueryCoordinates);
                    _this2.animateToCoordinates("origin", originQueryCoordinates);
                    _this2.actions.queryOriginCoordinates(null);
                  }
                  if (destinationQueryCoordinates) {
                    _this2.destinationInput.setInput(destinationQueryCoordinates);
                    _this2.animateToCoordinates("destination", destinationQueryCoordinates);
                    _this2.actions.queryDestinationCoordinates(null);
                  }
                });
              }
            }]);
            return Inputs2;
          }();
          exports3.default = Inputs;
        }, { "./geocoder": 40, "lodash.isequal": 8, "lodash.template": 9, "turf-extent": 35 }],
        42: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass = /* @__PURE__ */ function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _utils = require2("../utils");
          var _utils2 = _interopRequireDefault(_utils);
          var _lodash = require2("lodash.template");
          var _lodash2 = _interopRequireDefault(_lodash);
          var _lodash3 = require2("lodash.isequal");
          var _lodash4 = _interopRequireDefault(_lodash3);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var instructionsTemplate = (0, _lodash2.default)("<div class='directions-control directions-control-directions'>\n  <div class='mapbox-directions-component mapbox-directions-route-summary<% if (routes > 1) { %> mapbox-directions-multiple<% } %>'>\n    <% if (routes > 1) { %>\n    <div class='mapbox-directions-routes mapbox-directions-clearfix'>\n      <% for (var i = 0; i < routes; i++) { %>\n        <input type='radio' name='routes' id='<%= i %>' <% if (i === routeIndex) { %>checked<% } %>>\n        <label for='<%= i %>' class='mapbox-directions-route'><%= i + 1 %></label>\n      <% } %>\n    </div>\n    <% } %>\n    <h1><%- duration %></h1>\n    <span><%- distance %></span>\n  </div>\n\n  <div class='mapbox-directions-instructions'>\n    <div class='mapbox-directions-instructions-wrapper'>\n      <ol class='mapbox-directions-steps'>\n        <% steps.forEach(function(step) { %>\n          <%\n            var distance = step.distance ? format(step.distance) : false;\n            var icon = step.maneuver.modifier ? step.maneuver.modifier.replace(/\\s+/g, '-').toLowerCase() : step.maneuver.type.replace(/\\s+/g, '-').toLowerCase();\n\n            if (step.maneuver.type === 'arrive' || step.maneuver.type === 'depart') {\n              icon = step.maneuver.type;\n            }\n\n            if (step.maneuver.type === 'roundabout' || step.maneuver.type === 'rotary') {\n              icon= 'roundabout';\n            }\n\n            var lng = step.maneuver.location[0];\n            var lat = step.maneuver.location[1];\n          %>\n          <li\n            data-lat='<%= lat %>'\n            data-lng='<%= lng %>'\n            class='mapbox-directions-step'>\n            <span class='directions-icon directions-icon-<%= icon %>'></span>\n            <div class='mapbox-directions-step-maneuver'>\n              <%= step.maneuver.instruction %>\n              <%= step.maneuver.modifier %>\n            </div>\n            <% if (distance) { %>\n              <div class='mapbox-directions-step-distance'>\n                <%= distance %>\n              </div>\n            <% } %>\n          </li>\n        <% }); %>\n      </ol>\n    </div>\n  </div>\n</div>\n");
          var errorTemplate = (0, _lodash2.default)("<div class='directions-control directions-control-directions'>\n  <div class='maplibre-directions-error'>\n    <%= error %>\n  </div>\n</div>\n");
          var Instructions = function() {
            function Instructions2(el2, store, actions, map2) {
              _classCallCheck(this, Instructions2);
              this.container = el2;
              this.actions = actions;
              this.store = store;
              this._map = map2;
              this.directions = {};
              this.render();
            }
            _createClass(Instructions2, [{
              key: "render",
              value: function render() {
                var _this = this;
                this.store.subscribe(function() {
                  var _actions = _this.actions, hoverMarker = _actions.hoverMarker, setRouteIndex = _actions.setRouteIndex;
                  var _store$getState = _this.store.getState(), routeIndex = _store$getState.routeIndex, unit = _store$getState.unit, directions = _store$getState.directions, error = _store$getState.error, compile = _store$getState.compile;
                  var shouldRender = !(0, _lodash4.default)(directions[routeIndex], _this.directions);
                  if (error) {
                    _this.container.innerHTML = errorTemplate({ error });
                    return;
                  }
                  if (directions.length && shouldRender) {
                    var direction = _this.directions = directions[routeIndex];
                    if (compile) {
                      direction.legs.forEach(function(leg) {
                        leg.steps.forEach(function(step) {
                          step.maneuver.instruction = compile("en", step);
                        });
                      });
                    }
                    _this.container.innerHTML = instructionsTemplate({
                      routeIndex,
                      routes: directions.length,
                      steps: direction.legs[0].steps,
                      // Todo: Respect all legs,
                      format: _utils2.default.format[unit],
                      duration: _utils2.default.format[unit](direction.distance),
                      distance: _utils2.default.format.duration(direction.duration)
                    });
                    var steps = _this.container.querySelectorAll(".maplibre-directions-step");
                    Array.prototype.forEach.call(steps, function(el2) {
                      var lng = el2.getAttribute("data-lng");
                      var lat = el2.getAttribute("data-lat");
                      el2.addEventListener("mouseover", function() {
                        hoverMarker([lng, lat]);
                      });
                      el2.addEventListener("mouseout", function() {
                        hoverMarker(null);
                      });
                      el2.addEventListener("click", function() {
                        _this._map.flyTo({
                          center: [lng, lat],
                          zoom: 16
                        });
                      });
                    });
                    var routes = _this.container.querySelectorAll('input[type="radio"]');
                    Array.prototype.forEach.call(routes, function(el2) {
                      el2.addEventListener("change", function(e) {
                        setRouteIndex(parseInt(e.target.id, 10));
                      });
                    });
                  } else if (_this.container.innerHTML && shouldRender) {
                    _this.container.innerHTML = "";
                  }
                });
              }
            }]);
            return Instructions2;
          }();
          exports3.default = Instructions;
        }, { "../utils": 47, "lodash.isequal": 8, "lodash.template": 9 }],
        43: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass = /* @__PURE__ */ function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _redux = require2("redux");
          var _reduxThunk = require2("redux-thunk");
          var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
          var _polyline = require2("@mapbox/polyline");
          var _utils = require2("./utils");
          var _utils2 = _interopRequireDefault(_utils);
          var _reducers = require2("./reducers");
          var _reducers2 = _interopRequireDefault(_reducers);
          var _actions = require2("./actions");
          var actions = _interopRequireWildcard(_actions);
          var _directions_style = require2("./directions_style");
          var _directions_style2 = _interopRequireDefault(_directions_style);
          var _inputs = require2("./controls/inputs");
          var _inputs2 = _interopRequireDefault(_inputs);
          var _instructions = require2("./controls/instructions");
          var _instructions2 = _interopRequireDefault(_instructions);
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
              }
              newObj.default = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var storeWithMiddleware = (0, _redux.applyMiddleware)(_reduxThunk2.default)(_redux.createStore);
          var store = storeWithMiddleware(_reducers2.default);
          var MapLibreDirections2 = function() {
            function MapLibreDirections3(options) {
              _classCallCheck(this, MapLibreDirections3);
              this.actions = (0, _redux.bindActionCreators)(actions, store.dispatch);
              this.actions.setOptions(options || {});
              this.options = options || {};
              this.onDragDown = this._onDragDown.bind(this);
              this.onDragMove = this._onDragMove.bind(this);
              this.onDragUp = this._onDragUp.bind(this);
              this.move = this._move.bind(this);
              this.onClick = this._clickHandler().bind(this);
            }
            _createClass(MapLibreDirections3, [{
              key: "onAdd",
              value: function onAdd(map2) {
                var _this = this;
                this._map = map2;
                var _store$getState = store.getState(), controls = _store$getState.controls;
                var el2 = this.container = document.createElement("div");
                el2.className = "maplibregl-ctrl-directions maplibregl-ctrl";
                var inputEl = document.createElement("div");
                inputEl.className = "directions-control directions-control-inputs";
                new _inputs2.default(inputEl, store, this.actions, this._map);
                var directionsEl = document.createElement("div");
                directionsEl.className = "directions-control directions-control-instructions";
                new _instructions2.default(directionsEl, store, {
                  hoverMarker: this.actions.hoverMarker,
                  setRouteIndex: this.actions.setRouteIndex
                }, this._map);
                if (controls.inputs) el2.appendChild(inputEl);
                if (controls.instructions) el2.appendChild(directionsEl);
                this.subscribedActions();
                if (this._map.loaded()) this.mapState();
                else this._map.on("load", function() {
                  return _this.mapState();
                });
                return el2;
              }
              /**
               * Removes the control from the map it has been added to. This is called by `map.removeControl`,
               * which is the recommended method to remove controls.
               *
               * @returns {Control} `this`
               */
            }, {
              key: "onRemove",
              value: function onRemove(map2) {
                this.container.parentNode.removeChild(this.container);
                this.removeRoutes();
                map2.off("mousedown", this.onDragDown);
                map2.off("mousemove", this.move);
                map2.off("touchstart", this.onDragDown);
                map2.off("touchstart", this.move);
                map2.off("click", this.onClick);
                if (this.storeUnsubscribe) {
                  this.storeUnsubscribe();
                  delete this.storeUnsubscribe;
                }
                _directions_style2.default.forEach(function(layer) {
                  if (map2.getLayer(layer.id)) map2.removeLayer(layer.id);
                });
                if (map2.getSource("directions")) map2.removeSource("directions");
                this._map = null;
                return this;
              }
            }, {
              key: "mapState",
              value: function mapState() {
                var _this2 = this;
                var _store$getState2 = store.getState(), profile = _store$getState2.profile, alternatives = _store$getState2.alternatives, congestion = _store$getState2.congestion, styles = _store$getState2.styles, interactive = _store$getState2.interactive, compile = _store$getState2.compile;
                this.actions.eventEmit("profile", { profile });
                var geojson = {
                  type: "geojson",
                  data: {
                    type: "FeatureCollection",
                    features: []
                  }
                };
                this._map.addSource("directions", geojson);
                if (styles && styles.length) styles.forEach(function(style) {
                  return _this2._map.addLayer(style);
                });
                _directions_style2.default.forEach(function(style) {
                  if (!_this2._map.getLayer(style.id)) _this2._map.addLayer(style);
                });
                if (interactive) {
                  this._map.on("mousedown", this.onDragDown);
                  this._map.on("mousemove", this.move);
                  this._map.on("click", this.onClick);
                  this._map.on("touchstart", this.move);
                  this._map.on("touchstart", this.onDragDown);
                }
              }
            }, {
              key: "subscribedActions",
              value: function subscribedActions() {
                var _this3 = this;
                this.storeUnsubscribe = store.subscribe(function() {
                  var _store$getState3 = store.getState(), origin = _store$getState3.origin, destination = _store$getState3.destination, hoverMarker = _store$getState3.hoverMarker, directions = _store$getState3.directions, routeIndex = _store$getState3.routeIndex;
                  var geojson = {
                    type: "FeatureCollection",
                    features: [origin, destination, hoverMarker].filter(function(d) {
                      return d.geometry;
                    })
                  };
                  if (directions.length) {
                    directions.forEach(function(feature, index) {
                      var features2 = [];
                      var decoded = (0, _polyline.decode)(feature.geometry, 5).map(function(c) {
                        return c.reverse();
                      });
                      decoded.forEach(function(c, i) {
                        var previous = features2[features2.length - 1];
                        var congestion = feature.legs[0].annotation && feature.legs[0].annotation.congestion && feature.legs[0].annotation.congestion[i - 1];
                        if (previous && (!congestion || previous.properties.congestion === congestion)) {
                          previous.geometry.coordinates.push(c);
                        } else {
                          var segment = {
                            geometry: {
                              type: "LineString",
                              coordinates: []
                            },
                            properties: {
                              "route-index": index,
                              route: index === routeIndex ? "selected" : "alternate"
                            }
                          };
                          if (previous) segment.geometry.coordinates.push(previous.geometry.coordinates[previous.geometry.coordinates.length - 1]);
                          segment.geometry.coordinates.push(c);
                          if (congestion) {
                            segment.properties.congestion = feature.legs[0].annotation.congestion[i - 1];
                          }
                          features2.push(segment);
                        }
                      });
                      geojson.features = geojson.features.concat(features2);
                      if (index === routeIndex) {
                        feature.legs[0].steps.forEach(function(d) {
                          if (d.maneuver.type === "waypoint") {
                            geojson.features.push({
                              type: "Feature",
                              geometry: d.maneuver.location,
                              properties: {
                                id: "waypoint"
                              }
                            });
                          }
                        });
                      }
                    });
                  }
                  if (_this3._map.style && _this3._map.getSource("directions")) {
                    _this3._map.getSource("directions").setData(geojson);
                  }
                });
              }
            }, {
              key: "_clickHandler",
              value: function _clickHandler() {
                var timer = null;
                var delay = 250;
                return function(event) {
                  if (!timer) {
                    var singleClickHandler = this._onSingleClick.bind(this);
                    timer = setTimeout(function() {
                      singleClickHandler(event);
                      timer = null;
                    }, delay);
                  } else {
                    clearTimeout(timer);
                    timer = null;
                    this._map.zoomIn();
                  }
                };
              }
            }, {
              key: "_onSingleClick",
              value: function _onSingleClick(e) {
                var _this4 = this;
                var _store$getState4 = store.getState(), origin = _store$getState4.origin;
                var coords = [e.lngLat.lng, e.lngLat.lat];
                if (!origin.geometry) {
                  this.actions.setOriginFromCoordinates(coords);
                } else {
                  var features2 = this._map.queryRenderedFeatures(e.point, {
                    layers: ["directions-origin-point", "directions-destination-point", "directions-waypoint-point", "directions-route-line-alt"]
                  });
                  if (features2.length) {
                    features2.forEach(function(f) {
                      if (f.layer.id === "directions-waypoint-point") {
                        _this4.actions.removeWaypoint(f);
                      }
                    });
                    if (features2[0].properties.route === "alternate") {
                      var index = features2[0].properties["route-index"];
                      this.actions.setRouteIndex(index);
                    }
                  } else {
                    this.actions.setDestinationFromCoordinates(coords);
                    this._map.flyTo({ center: coords });
                  }
                }
              }
            }, {
              key: "_move",
              value: function _move(e) {
                var _this5 = this;
                var _store$getState5 = store.getState(), hoverMarker = _store$getState5.hoverMarker;
                var features2 = this._map.queryRenderedFeatures(e.point, {
                  layers: ["directions-route-line-alt", "directions-route-line", "directions-origin-point", "directions-destination-point", "directions-hover-point"]
                });
                this._map.getCanvas().style.cursor = features2.length ? "pointer" : "";
                if (features2.length) {
                  this.isCursorOverPoint = features2[0];
                  this._map.dragPan.disable();
                  features2.forEach(function(feature) {
                    if (feature.layer.id === "directions-route-line") {
                      _this5.actions.hoverMarker([e.lngLat.lng, e.lngLat.lat]);
                    } else if (hoverMarker.geometry) {
                      _this5.actions.hoverMarker(null);
                    }
                  });
                } else if (this.isCursorOverPoint) {
                  this.isCursorOverPoint = false;
                  this._map.dragPan.enable();
                }
              }
            }, {
              key: "_onDragDown",
              value: function _onDragDown() {
                if (!this.isCursorOverPoint) return;
                this.isDragging = this.isCursorOverPoint;
                this._map.getCanvas().style.cursor = "grab";
                this._map.on("mousemove", this.onDragMove);
                this._map.on("mouseup", this.onDragUp);
                this._map.on("touchmove", this.onDragMove);
                this._map.on("touchend", this.onDragUp);
              }
            }, {
              key: "_onDragMove",
              value: function _onDragMove(e) {
                if (!this.isDragging) return;
                var coords = [e.lngLat.lng, e.lngLat.lat];
                switch (this.isDragging.layer.id) {
                  case "directions-origin-point":
                    this.actions.createOrigin(coords);
                    break;
                  case "directions-destination-point":
                    this.actions.createDestination(coords);
                    break;
                  case "directions-hover-point":
                    this.actions.hoverMarker(coords);
                    break;
                }
              }
            }, {
              key: "_onDragUp",
              value: function _onDragUp() {
                if (!this.isDragging) return;
                var _store$getState6 = store.getState(), hoverMarker = _store$getState6.hoverMarker, origin = _store$getState6.origin, destination = _store$getState6.destination;
                switch (this.isDragging.layer.id) {
                  case "directions-origin-point":
                    this.actions.setOriginFromCoordinates(origin.geometry.coordinates);
                    break;
                  case "directions-destination-point":
                    this.actions.setDestinationFromCoordinates(destination.geometry.coordinates);
                    break;
                  case "directions-hover-point":
                    if (hoverMarker.geometry && !_utils2.default.coordinateMatch(this.isDragging, hoverMarker)) {
                      this.actions.addWaypoint(0, hoverMarker);
                    }
                    break;
                }
                this.isDragging = false;
                this._map.getCanvas().style.cursor = "";
                this._map.off("touchmove", this.onDragMove);
                this._map.off("touchend", this.onDragUp);
                this._map.off("mousemove", this.onDragMove);
                this._map.off("mouseup", this.onDragUp);
              }
              // API Methods
              // ============================
              /**
               * Turn on or off interactivity
               * @param {Boolean} state sets interactivity based on a state of `true` or `false`.
               * @returns {MapLibreDirections} this
               */
            }, {
              key: "interactive",
              value: function interactive(state) {
                if (state) {
                  this._map.on("touchstart", this.move);
                  this._map.on("touchstart", this.onDragDown);
                  this._map.on("mousedown", this.onDragDown);
                  this._map.on("mousemove", this.move);
                  this._map.on("click", this.onClick);
                } else {
                  this._map.off("touchstart", this.move);
                  this._map.off("touchstart", this.onDragDown);
                  this._map.off("mousedown", this.onDragDown);
                  this._map.off("mousemove", this.move);
                  this._map.off("click", this.onClick);
                }
                return this;
              }
              /**
               * Returns the origin of the current route.
               * @returns {Object} origin
               */
            }, {
              key: "getOrigin",
              value: function getOrigin() {
                return store.getState().origin;
              }
              /**
               * Sets origin. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
               * to have run.
               * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.
               * @returns {MapLibreDirections} this
               */
            }, {
              key: "setOrigin",
              value: function setOrigin(query) {
                if (typeof query === "string") {
                  this.actions.queryOrigin(query);
                } else {
                  this.actions.setOriginFromCoordinates(query);
                }
                return this;
              }
              /**
               * Returns the destination of the current route.
               * @returns {Object} destination
               */
            }, {
              key: "getDestination",
              value: function getDestination() {
                return store.getState().destination;
              }
              /**
               * Sets destination. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
               * to have run.
               * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.
               * @returns {MapLibreDirections} this
               */
            }, {
              key: "setDestination",
              value: function setDestination(query) {
                if (typeof query === "string") {
                  this.actions.queryDestination(query);
                } else {
                  this.actions.setDestinationFromCoordinates(query);
                }
                return this;
              }
              /**
               * Swap the origin and destination.
               * @returns {MapLibreDirections} this
               */
            }, {
              key: "reverse",
              value: function reverse() {
                this.actions.reverse();
                return this;
              }
              /**
               * Add a waypoint to the route. _Note:_ calling this method requires the
               * [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load) to have run.
               * @param {Number} index position waypoint should be placed in the waypoint array
               * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.
               * @returns {MapLibreDirections} this;
               */
            }, {
              key: "addWaypoint",
              value: function addWaypoint(index, waypoint) {
                if (!waypoint.type) waypoint = _utils2.default.createPoint(waypoint, { id: "waypoint" });
                this.actions.addWaypoint(index, waypoint);
                return this;
              }
              /**
               * Change the waypoint at a given index in the route. _Note:_ calling this
               * method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
               * to have run.
               * @param {Number} index indexed position of the waypoint to update
               * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.
               * @returns {MapLibreDirections} this;
               */
            }, {
              key: "setWaypoint",
              value: function setWaypoint(index, waypoint) {
                if (!waypoint.type) waypoint = _utils2.default.createPoint(waypoint, { id: "waypoint" });
                this.actions.setWaypoint(index, waypoint);
                return this;
              }
              /**
               * Remove a waypoint from the route.
               * @param {Number} index position in the waypoints array.
               * @returns {MapLibreDirections} this;
               */
            }, {
              key: "removeWaypoint",
              value: function removeWaypoint(index) {
                var _store$getState7 = store.getState(), waypoints = _store$getState7.waypoints;
                this.actions.removeWaypoint(waypoints[index]);
                return this;
              }
              /**
               * Fetch all current waypoints in a route.
               * @returns {Array} waypoints
               */
            }, {
              key: "getWaypoints",
              value: function getWaypoints() {
                return store.getState().waypoints;
              }
              /**
               * Removes all routes and waypoints from the map.
               *
               * @returns {MapLibreDirections} this;
               */
            }, {
              key: "removeRoutes",
              value: function removeRoutes() {
                this.actions.clearOrigin();
                this.actions.clearDestination();
                return this;
              }
              /**
               * Subscribe to events that happen within the plugin.
               * @param {String} type name of event. Available events and the data passed into their respective event objects are:
               *
               * - __clear__ `{ type: } Type is one of 'origin' or 'destination'`
               * - __loading__ `{ type: } Type is one of 'origin' or 'destination'`
               * - __profile__ `{ profile } Profile is one of 'driving', 'walking', or 'cycling'`
               * - __origin__ `{ feature } Fired when origin is set`
               * - __destination__ `{ feature } Fired when destination is set`
               * - __route__ `{ route } Fired when a route is updated`
               * - __error__ `{ error } Error as string`
               * @param {Function} fn function that's called when the event is emitted.
               * @returns {MapLibreDirections} this;
               */
            }, {
              key: "on",
              value: function on2(type, fn2) {
                this.actions.eventSubscribe(type, fn2);
                return this;
              }
            }]);
            return MapLibreDirections3;
          }();
          exports3.default = MapLibreDirections2;
        }, { "./actions": 38, "./controls/inputs": 41, "./controls/instructions": 42, "./directions_style": 44, "./reducers": 46, "./utils": 47, "@mapbox/polyline": 1, "redux": 28, "redux-thunk": 22 }],
        44: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var style = [{
            "id": "directions-route-line-alt",
            "type": "line",
            "source": "directions",
            "layout": {
              "line-cap": "round",
              "line-join": "round"
            },
            "paint": {
              "line-color": "#bbb",
              "line-width": 4
            },
            "filter": ["all", ["in", "$type", "LineString"], ["in", "route", "alternate"]]
          }, {
            "id": "directions-route-line-casing",
            "type": "line",
            "source": "directions",
            "layout": {
              "line-cap": "round",
              "line-join": "round"
            },
            "paint": {
              "line-color": "#2d5f99",
              "line-width": 12
            },
            "filter": ["all", ["in", "$type", "LineString"], ["in", "route", "selected"]]
          }, {
            "id": "directions-route-line",
            "type": "line",
            "source": "directions",
            "layout": {
              "line-cap": "butt",
              "line-join": "round"
            },
            "paint": {
              "line-color": {
                "property": "congestion",
                "type": "categorical",
                "default": "#4882c5",
                "stops": [["unknown", "#4882c5"], ["low", "#4882c5"], ["moderate", "#f09a46"], ["heavy", "#e34341"], ["severe", "#8b2342"]]
              },
              "line-width": 7
            },
            "filter": ["all", ["in", "$type", "LineString"], ["in", "route", "selected"]]
          }, {
            "id": "directions-hover-point-casing",
            "type": "circle",
            "source": "directions",
            "paint": {
              "circle-radius": 8,
              "circle-color": "#fff"
            },
            "filter": ["all", ["in", "$type", "Point"], ["in", "id", "hover"]]
          }, {
            "id": "directions-hover-point",
            "type": "circle",
            "source": "directions",
            "paint": {
              "circle-radius": 6,
              "circle-color": "#3bb2d0"
            },
            "filter": ["all", ["in", "$type", "Point"], ["in", "id", "hover"]]
          }, {
            "id": "directions-waypoint-point-casing",
            "type": "circle",
            "source": "directions",
            "paint": {
              "circle-radius": 8,
              "circle-color": "#fff"
            },
            "filter": ["all", ["in", "$type", "Point"], ["in", "id", "waypoint"]]
          }, {
            "id": "directions-waypoint-point",
            "type": "circle",
            "source": "directions",
            "paint": {
              "circle-radius": 6,
              "circle-color": "#8a8bc9"
            },
            "filter": ["all", ["in", "$type", "Point"], ["in", "id", "waypoint"]]
          }, {
            "id": "directions-origin-point",
            "type": "circle",
            "source": "directions",
            "paint": {
              "circle-radius": 18,
              "circle-color": "#3bb2d0"
            },
            "filter": ["all", ["in", "$type", "Point"], ["in", "marker-symbol", "A"]]
          }, {
            "id": "directions-origin-label",
            "type": "symbol",
            "source": "directions",
            "layout": {
              "text-field": "A",
              "text-size": 12
            },
            "paint": {
              "text-color": "#fff"
            },
            "filter": ["all", ["in", "$type", "Point"], ["in", "marker-symbol", "A"]]
          }, {
            "id": "directions-destination-point",
            "type": "circle",
            "source": "directions",
            "paint": {
              "circle-radius": 18,
              "circle-color": "#8a8bc9"
            },
            "filter": ["all", ["in", "$type", "Point"], ["in", "marker-symbol", "B"]]
          }, {
            "id": "directions-destination-label",
            "type": "symbol",
            "source": "directions",
            "layout": {
              "text-field": "B",
              "text-size": 12
            },
            "paint": {
              "text-color": "#fff"
            },
            "filter": ["all", ["in", "$type", "Point"], ["in", "marker-symbol", "B"]]
          }];
          exports3.default = style;
        }, {}],
        45: [function(require2, module3, exports3) {
          "use strict";
          var _directions = require2("./directions");
          var _directions2 = _interopRequireDefault(_directions);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          module3.exports = _directions2.default;
        }, { "./directions": 43 }],
        46: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _action_types = require2("../constants/action_types.js");
          var types = _interopRequireWildcard(_action_types);
          var _deepAssign = require2("deep-assign");
          var _deepAssign2 = _interopRequireDefault(_deepAssign);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
              }
              newObj.default = obj;
              return newObj;
            }
          }
          var initialState = {
            // Options set on initialization
            api: "http://router.project-osrm.org/route/v1/",
            api2: "http://traffic.tag-ip.com/route/v1/",
            profile: "driving",
            alternatives: false,
            congestion: false,
            unit: "imperial",
            flyTo: true,
            placeholderOrigin: "Choose a starting place",
            placeholderDestination: "Choose destination",
            zoom: 16,
            compile: null,
            proximity: false,
            styles: [],
            // UI controls
            controls: {
              profileSwitcher: true,
              inputs: true,
              instructions: true
            },
            // Optional setting to pass options available to mapbox-gl-geocoder
            geocoder: {},
            interactive: true,
            // Container for client registered events
            events: {},
            // Marker feature drawn on the map at any point.
            origin: {},
            destination: {},
            hoverMarker: {},
            waypoints: [],
            // User input strings or result returned from geocoder
            originQuery: null,
            destinationQuery: null,
            originQueryCoordinates: null,
            destinationQueryCoordinates: null,
            // Directions data
            directions: [],
            routeIndex: 0,
            routePadding: 80
          };
          function data() {
            var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState;
            var action = arguments[1];
            switch (action.type) {
              case types.SET_OPTIONS:
                return (0, _deepAssign2.default)({}, state, action.options);
              case types.DIRECTIONS_PROFILE:
                return Object.assign({}, state, {
                  profile: action.profile
                });
              case types.ORIGIN:
                return Object.assign({}, state, {
                  origin: action.origin,
                  hoverMarker: {}
                });
              case types.DESTINATION:
                return Object.assign({}, state, {
                  destination: action.destination,
                  hoverMarker: {}
                });
              case types.HOVER_MARKER:
                return Object.assign({}, state, {
                  hoverMarker: action.hoverMarker
                });
              case types.WAYPOINTS:
                return Object.assign({}, state, {
                  waypoints: action.waypoints
                });
              case types.ORIGIN_QUERY:
                return Object.assign({}, state, {
                  originQuery: action.query
                });
              case types.DESTINATION_QUERY:
                return Object.assign({}, state, {
                  destinationQuery: action.query
                });
              case types.ORIGIN_FROM_COORDINATES:
                return Object.assign({}, state, {
                  originQueryCoordinates: action.coordinates
                });
              case types.DESTINATION_FROM_COORDINATES:
                return Object.assign({}, state, {
                  destinationQueryCoordinates: action.coordinates
                });
              case types.ORIGIN_CLEAR:
                return Object.assign({}, state, {
                  origin: {},
                  originQuery: "",
                  waypoints: [],
                  directions: []
                });
              case types.DESTINATION_CLEAR:
                return Object.assign({}, state, {
                  destination: {},
                  destinationQuery: "",
                  waypoints: [],
                  directions: []
                });
              case types.DIRECTIONS:
                return Object.assign({}, state, {
                  directions: action.directions
                });
              case types.ROUTE_INDEX:
                return Object.assign({}, state, {
                  routeIndex: action.routeIndex
                });
              case types.ERROR:
                return Object.assign({}, state, {
                  error: action.error
                });
              default:
                return state;
            }
          }
          exports3.default = data;
        }, { "../constants/action_types.js": 39, "deep-assign": 2 }],
        47: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function validCoords(coords) {
            return coords[0] >= -180 && coords[0] <= 180 && coords[1] >= -90 && coords[1] <= 90;
          }
          function coordinateMatch(a, b) {
            a = a.geometry.coordinates;
            b = b.geometry.coordinates;
            return a.join() === b.join() || a[0].toFixed(3) === b[0].toFixed(3) && a[1].toFixed(3) === b[1].toFixed(3);
          }
          function wrap(n) {
            var d = 180 - -180;
            var w = ((n - -180) % d + d) % d + -180;
            return w === -180 ? 180 : w;
          }
          function roundWithOriginalPrecision(input, original) {
            var precision = 0;
            if (Math.floor(original) !== original) {
              precision = original.toString().split(".")[1].length;
            }
            return input.toFixed(Math.min(precision, 5));
          }
          function createPoint(coordinates, properties) {
            return {
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates
              },
              properties: properties ? properties : {}
            };
          }
          var format = {
            duration: function duration(s) {
              var m = Math.floor(s / 60), h = Math.floor(m / 60);
              s %= 60;
              m %= 60;
              if (h === 0 && m === 0) return s + "s";
              if (h === 0) return m + "min";
              return h + "h " + m + "min";
            },
            imperial: function imperial(m) {
              var mi2 = m / 1609.344;
              if (mi2 >= 100) return mi2.toFixed(0) + "mi";
              if (mi2 >= 10) return mi2.toFixed(1) + "mi";
              if (mi2 >= 0.1) return mi2.toFixed(2) + "mi";
              return (mi2 * 5280).toFixed(0) + "ft";
            },
            metric: function metric(m) {
              if (m >= 1e5) return (m / 1e3).toFixed(0) + "km";
              if (m >= 1e4) return (m / 1e3).toFixed(1) + "km";
              if (m >= 100) return (m / 1e3).toFixed(2) + "km";
              return m.toFixed(0) + "m";
            }
          };
          exports3.default = { format, coordinateMatch, createPoint, validCoords, wrap, roundWithOriginalPrecision };
        }, {}]
      }, {}, [45])(45);
    });
  }
});

// node_modules/.pnpm/@mapbox+polyline@1.2.1/node_modules/@mapbox/polyline/src/polyline.js
var require_polyline = __commonJS({
  "node_modules/.pnpm/@mapbox+polyline@1.2.1/node_modules/@mapbox/polyline/src/polyline.js"(exports, module) {
    "use strict";
    var polyline2 = {};
    function py2_round(value) {
      return Math.floor(Math.abs(value) + 0.5) * (value >= 0 ? 1 : -1);
    }
    function encode(current, previous, factor) {
      current = py2_round(current * factor);
      previous = py2_round(previous * factor);
      var coordinate = (current - previous) * 2;
      if (coordinate < 0) {
        coordinate = -coordinate - 1;
      }
      var output = "";
      while (coordinate >= 32) {
        output += String.fromCharCode((32 | coordinate & 31) + 63);
        coordinate /= 32;
      }
      output += String.fromCharCode((coordinate | 0) + 63);
      return output;
    }
    polyline2.decode = function(str, precision) {
      var index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0, byte = null, latitude_change, longitude_change, factor = Math.pow(10, Number.isInteger(precision) ? precision : 5);
      while (index < str.length) {
        byte = null;
        shift = 1;
        result = 0;
        do {
          byte = str.charCodeAt(index++) - 63;
          result += (byte & 31) * shift;
          shift *= 32;
        } while (byte >= 32);
        latitude_change = result & 1 ? (-result - 1) / 2 : result / 2;
        shift = 1;
        result = 0;
        do {
          byte = str.charCodeAt(index++) - 63;
          result += (byte & 31) * shift;
          shift *= 32;
        } while (byte >= 32);
        longitude_change = result & 1 ? (-result - 1) / 2 : result / 2;
        lat += latitude_change;
        lng += longitude_change;
        coordinates.push([lat / factor, lng / factor]);
      }
      return coordinates;
    };
    polyline2.encode = function(coordinates, precision) {
      if (!coordinates.length) {
        return "";
      }
      var factor = Math.pow(10, Number.isInteger(precision) ? precision : 5), output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);
      for (var i = 1; i < coordinates.length; i++) {
        var a = coordinates[i], b = coordinates[i - 1];
        output += encode(a[0], b[0], factor);
        output += encode(a[1], b[1], factor);
      }
      return output;
    };
    function flipped(coords) {
      var flipped2 = [];
      for (var i = 0; i < coords.length; i++) {
        var coord = coords[i].slice();
        flipped2.push([coord[1], coord[0]]);
      }
      return flipped2;
    }
    polyline2.fromGeoJSON = function(geojson, precision) {
      if (geojson && geojson.type === "Feature") {
        geojson = geojson.geometry;
      }
      if (!geojson || geojson.type !== "LineString") {
        throw new Error("Input must be a GeoJSON LineString");
      }
      return polyline2.encode(flipped(geojson.coordinates), precision);
    };
    polyline2.toGeoJSON = function(str, precision) {
      var coords = polyline2.decode(str, precision);
      return {
        type: "LineString",
        coordinates: flipped(coords)
      };
    };
    if (typeof module === "object" && module.exports) {
      module.exports = polyline2;
    }
  }
});

// app.js
var import_maplibre_gl = __toESM(require_maplibre_gl());
var import_maplibre_gl_directions = __toESM(require_maplibre_gl_directions());
var import_polyline = __toESM(require_polyline());

// src/map.maplibre/map_defaults.js
var map_defaults_default = {
  version: "0.0.5",
  overlayurl: "https://overlays.tag-ip.xyz",
  vectorurl: "https://vector-tiles.tag-ip.xyz",
  rasterurl: "https://tiles.tag-ip.com",
  style: "https://vector-tiles.tag-ip.xyz".concat("/styles/tag-ip-mu/style.json")
};

// src/map.maplibre/bounds_helper.js
var SW = {
  lng: 41.428523678184234,
  lat: -25.855015532118756
};
var NE = {
  lng: 52.75820791383018,
  lat: -11.711066264154994
};
var initBounds = [
  [41.428523678184234, -25.855015532118756],
  [52.75820791383018, -11.711066264154994]
];
var Center = [46.8691, -18.7669];
var Zoom = 5;
function fleet() {
}
function trace() {
}
var bounds_helper_default = {
  fleet,
  trace,
  SW,
  NE,
  initBounds,
  Center,
  Zoom
};

// src/map.maplibre/map_state.js
var MapState = class {
  constructor() {
    __publicField(this, "follow", true);
    __publicField(this, "playMode", false);
    __publicField(this, "trb", null);
    __publicField(this, "flt", null);
    // label de flotte
    __publicField(this, "filter", "all");
    // label de flotte avec filtre
    __publicField(this, "trackables", {});
    __publicField(this, "statuses", {});
    __publicField(this, "trackable_features", {});
    __publicField(this, "fleet_features", null);
    __publicField(this, "trace_features", null);
    __publicField(this, "trace", []);
    __publicField(this, "popup", null);
    __publicField(this, "popupOnClose", null);
    __publicField(this, "marker", null);
    __publicField(this, "selected_event_id", null);
    __publicField(this, "overlay_ids", []);
    __publicField(this, "system_overlay_ids", []);
    __publicField(this, "overlays", {});
    __publicField(this, "pitch", 0);
    __publicField(this, "zoom", 0);
    __publicField(this, "keepZoom", false);
    __publicField(this, "interactiveMode", false);
    __publicField(this, "maxZoomRequested", false);
    __publicField(this, "controls", {
      basemap: {
        isVector: false
      }
    });
  }
  get wowMode() {
    return this.controls.basemap.isVector;
  }
  get allowClick() {
    return !this.interactiveMode;
  }
  get allowFollow() {
    return !this.interactiveMode;
  }
  get isInteractive() {
    return this.interactiveMode;
  }
  requestMaxZoom() {
    this.maxZoomRequested = true;
  }
  maxZoomApplied() {
    this.maxZoomRequested = false;
  }
  startCustomZoom() {
    this.keepZoom = true;
    this.maxZoomRequested = false;
  }
  endCustomZoom() {
    this.keepZoom = false;
  }
  startInteractiveMode() {
    console.log("Starting interactive mode");
    if (!this.interactiveMode) {
      console.log("Started interactive mode");
      this.interactiveMode = true;
      map.resetNorthPitch();
    } else console.log("Interactive mode already started");
  }
  /**
   * L'utilisateur peut faire des choses sur la carte, les selections sont
   * desactivés, et les mises à jiur de la carte sont desactivées
   */
  enableInteractiveMode() {
    this.startInteractiveMode();
  }
  endInteractiveMode() {
    console.log("Ending interactive mode");
    if (this.interactiveMode) {
      console.log("Ended interactive mode");
      this.interactiveMode = false;
    } else console.log("Interactive mode already ended");
  }
  /**
   * L'utilisateur a fini ses actions sur la carte, reactiver le mode selection
   * et le follow
   */
  disableInteractiveMode() {
    this.endInteractiveMode();
  }
};

// node_modules/.pnpm/@watergis+maplibre-gl-legend@2.0.5/node_modules/@watergis/maplibre-gl-legend/dist/maplibre-gl-legend.es.js
var wi = Object.defineProperty;
var xi = (r, e, t) => e in r ? wi(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var ae = (r, e, t) => (xi(r, typeof e != "symbol" ? e + "" : e, t), t);
var ki = 8;
var ji = {
  version: {
    required: true,
    type: "enum",
    values: [
      8
    ],
    doc: "Style specification version number. Must be 8.",
    example: 8
  },
  name: {
    type: "string",
    doc: "A human-readable name for the style.",
    example: "Bright"
  },
  metadata: {
    type: "*",
    doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
  },
  center: {
    type: "array",
    value: "number",
    doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    example: [
      -73.9749,
      40.7736
    ]
  },
  zoom: {
    type: "number",
    doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    example: 12.5
  },
  bearing: {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    doc: 'Default bearing, in degrees. The bearing is the compass direction that is "up"; for example, a bearing of 90\xB0 orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
    example: 29
  },
  pitch: {
    type: "number",
    default: 0,
    units: "degrees",
    doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
    example: 50
  },
  light: {
    type: "light",
    doc: "The global light source.",
    example: {
      anchor: "viewport",
      color: "white",
      intensity: 0.4
    }
  },
  terrain: {
    type: "terrain",
    doc: "A global modifier that elevates layers and markers based on a DEM data source."
  },
  fog: {
    type: "fog",
    doc: "A global effect that fades layers and markers based on their distance to the camera. The fog can be used to approximate the effect of atmosphere on distant objects and enhance the depth perception of the map when used with terrain or 3D features. Note: fog is renamed to atmosphere in the Android and iOS SDKs and planned to be changed in GL-JS v.3.0.0."
  },
  sources: {
    required: true,
    type: "sources",
    doc: "Data source specifications.",
    example: {
      "mapbox-streets": {
        type: "vector",
        url: "mapbox://mapbox.mapbox-streets-v6"
      }
    }
  },
  sprite: {
    type: "string",
    doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
    example: "mapbox://sprites/mapbox/bright-v8"
  },
  glyphs: {
    type: "string",
    doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",
    example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
  },
  transition: {
    type: "transition",
    doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
    example: {
      duration: 300,
      delay: 0
    }
  },
  projection: {
    type: "projection",
    doc: "The projection the map should be rendered in. Supported projections are Mercator, Globe, Albers, Equal Earth, Equirectangular (WGS84), Lambert conformal conic, Natural Earth, and Winkel Tripel. Terrain, sky and fog are supported by only Mercator and globe. CustomLayerInterface is not supported outside of Mercator.",
    example: {
      name: "albers",
      center: [
        -154,
        50
      ],
      parallels: [
        55,
        65
      ]
    }
  },
  layers: {
    required: true,
    type: "array",
    value: "layer",
    doc: "Layers will be drawn in the order of this array.",
    example: [
      {
        id: "water",
        source: "mapbox-streets",
        "source-layer": "water",
        type: "fill",
        paint: {
          "fill-color": "#00ffff"
        }
      }
    ]
  }
};
var Ti = {
  "*": {
    type: "source",
    doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."
  }
};
var zi = [
  "source_vector",
  "source_raster",
  "source_raster_dem",
  "source_geojson",
  "source_video",
  "source_image"
];
var Ci = {
  type: {
    required: true,
    type: "enum",
    values: {
      vector: {
        doc: "A vector tile source."
      }
    },
    doc: "The type of the source."
  },
  url: {
    type: "string",
    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
  },
  tiles: {
    type: "array",
    value: "string",
    doc: "An array of one or more tile source URLs, as in the TileJSON spec."
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ],
    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {
        doc: "Slippy map tilenames scheme."
      },
      tms: {
        doc: "OSGeo spec scheme."
      }
    },
    default: "xyz",
    doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
  },
  minzoom: {
    type: "number",
    default: 0,
    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
  },
  maxzoom: {
    type: "number",
    default: 22,
    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
  },
  attribution: {
    type: "string",
    doc: "Contains an attribution to be displayed when the map is shown to a user."
  },
  promoteId: {
    type: "promoteId",
    doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers. If specified as an object only specified source layers will have id overriden, others will fallback to original feature id"
  },
  volatile: {
    type: "boolean",
    default: false,
    doc: "A setting to determine whether a source's tiles are cached locally.",
    "sdk-support": {
      "basic functionality": {
        android: "9.3.0",
        ios: "5.10.0"
      }
    }
  },
  "*": {
    type: "*",
    doc: "Other keys to configure the data source."
  }
};
var Ei = {
  type: {
    required: true,
    type: "enum",
    values: {
      raster: {
        doc: "A raster tile source."
      }
    },
    doc: "The type of the source."
  },
  url: {
    type: "string",
    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
  },
  tiles: {
    type: "array",
    value: "string",
    doc: "An array of one or more tile source URLs, as in the TileJSON spec."
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ],
    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
  },
  minzoom: {
    type: "number",
    default: 0,
    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
  },
  maxzoom: {
    type: "number",
    default: 22,
    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels",
    doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {
        doc: "Slippy map tilenames scheme."
      },
      tms: {
        doc: "OSGeo spec scheme."
      }
    },
    default: "xyz",
    doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."
  },
  attribution: {
    type: "string",
    doc: "Contains an attribution to be displayed when the map is shown to a user."
  },
  volatile: {
    type: "boolean",
    default: false,
    doc: "A setting to determine whether a source's tiles are cached locally.",
    "sdk-support": {
      "basic functionality": {
        android: "9.3.0",
        ios: "5.10.0"
      }
    }
  },
  "*": {
    type: "*",
    doc: "Other keys to configure the data source."
  }
};
var Ai = {
  type: {
    required: true,
    type: "enum",
    values: {
      "raster-dem": {
        doc: "A RGB-encoded raster DEM source"
      }
    },
    doc: "The type of the source."
  },
  url: {
    type: "string",
    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."
  },
  tiles: {
    type: "array",
    value: "string",
    doc: "An array of one or more tile source URLs, as in the TileJSON spec."
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ],
    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."
  },
  minzoom: {
    type: "number",
    default: 0,
    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."
  },
  maxzoom: {
    type: "number",
    default: 22,
    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels",
    doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
  },
  attribution: {
    type: "string",
    doc: "Contains an attribution to be displayed when the map is shown to a user."
  },
  encoding: {
    type: "enum",
    values: {
      terrarium: {
        doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."
      },
      mapbox: {
        doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."
      }
    },
    default: "mapbox",
    doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"
  },
  volatile: {
    type: "boolean",
    default: false,
    doc: "A setting to determine whether a source's tiles are cached locally.",
    "sdk-support": {
      "basic functionality": {
        android: "9.3.0",
        ios: "5.10.0"
      }
    }
  },
  "*": {
    type: "*",
    doc: "Other keys to configure the data source."
  }
};
var _i = {
  type: {
    required: true,
    type: "enum",
    values: {
      geojson: {
        doc: "A GeoJSON data source."
      }
    },
    doc: "The data type of the GeoJSON source."
  },
  data: {
    type: "*",
    doc: "A URL to a GeoJSON file, or inline GeoJSON."
  },
  maxzoom: {
    type: "number",
    default: 18,
    doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
  },
  attribution: {
    type: "string",
    doc: "Contains an attribution to be displayed when the map is shown to a user."
  },
  buffer: {
    type: "number",
    default: 128,
    maximum: 512,
    minimum: 0,
    doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."
  },
  filter: {
    type: "*",
    doc: "An expression for filtering features prior to processing them for rendering."
  },
  tolerance: {
    type: "number",
    default: 0.375,
    doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
  },
  cluster: {
    type: "boolean",
    default: false,
    doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count"
  },
  clusterRadius: {
    type: "number",
    default: 50,
    minimum: 0,
    doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."
  },
  clusterMaxZoom: {
    type: "number",
    doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered). Clusters are re-evaluated at integer zoom levels so setting clusterMaxZoom to 14 means the clusters will be displayed until z15."
  },
  clusterMinPoints: {
    type: "number",
    doc: "Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`."
  },
  clusterProperties: {
    type: "*",
    doc: 'An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{"property_name": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `"+"` or `"max"`) \u2014 it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{"sum": ["+", ["get", "scalerank"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `["accumulated"]` value, e.g.:\n`{"sum": [["+", ["accumulated"], ["get", "sum"]], ["get", "scalerank"]]}`'
  },
  lineMetrics: {
    type: "boolean",
    default: false,
    doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."
  },
  generateId: {
    type: "boolean",
    default: false,
    doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."
  },
  promoteId: {
    type: "promoteId",
    doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."
  }
};
var Si = {
  type: {
    required: true,
    type: "enum",
    values: {
      video: {
        doc: "A video data source."
      }
    },
    doc: "The data type of the video source."
  },
  urls: {
    required: true,
    type: "array",
    value: "string",
    doc: "URLs to video content in order of preferred format."
  },
  coordinates: {
    required: true,
    doc: "Corners of video specified in longitude, latitude pairs.",
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number",
      doc: "A single longitude, latitude pair."
    }
  }
};
var Ii = {
  type: {
    required: true,
    type: "enum",
    values: {
      image: {
        doc: "An image data source."
      }
    },
    doc: "The data type of the image source."
  },
  url: {
    required: true,
    type: "string",
    doc: "URL that points to an image."
  },
  coordinates: {
    required: true,
    doc: "Corners of image specified in longitude, latitude pairs.",
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number",
      doc: "A single longitude, latitude pair."
    }
  }
};
var Ri = {
  id: {
    type: "string",
    doc: "Unique layer name.",
    required: true
  },
  type: {
    type: "enum",
    values: {
      fill: {
        doc: "A filled polygon with an optional stroked border.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      line: {
        doc: "A stroked line.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      symbol: {
        doc: "An icon or a text label.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      circle: {
        doc: "A filled circle.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      heatmap: {
        doc: "A heatmap.",
        "sdk-support": {
          "basic functionality": {
            js: "0.41.0",
            android: "6.0.0",
            ios: "4.0.0",
            macos: "0.7.0"
          }
        }
      },
      "fill-extrusion": {
        doc: "An extruded (3D) polygon.",
        "sdk-support": {
          "basic functionality": {
            js: "0.27.0",
            android: "5.1.0",
            ios: "3.6.0",
            macos: "0.5.0"
          }
        }
      },
      raster: {
        doc: "Raster map textures such as satellite imagery.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      hillshade: {
        doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",
        "sdk-support": {
          "basic functionality": {
            js: "0.43.0",
            android: "6.0.0",
            ios: "4.0.0",
            macos: "0.7.0"
          }
        }
      },
      background: {
        doc: "The background color or pattern of the map.",
        "sdk-support": {
          "basic functionality": {
            js: "0.10.0",
            android: "2.0.1",
            ios: "2.0.0",
            macos: "0.1.0"
          }
        }
      },
      sky: {
        doc: "A spherical dome around the map that is always rendered behind all other layers.",
        "sdk-support": {
          "basic functionality": {
            js: "2.0.0",
            ios: "10.0.0",
            android: "10.0.0"
          }
        }
      }
    },
    doc: "Rendering type of this layer.",
    required: true
  },
  metadata: {
    type: "*",
    doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
  },
  source: {
    type: "string",
    doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."
  },
  "source-layer": {
    type: "string",
    doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."
  },
  minzoom: {
    type: "number",
    minimum: 0,
    maximum: 24,
    doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."
  },
  maxzoom: {
    type: "number",
    minimum: 0,
    maximum: 24,
    doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."
  },
  filter: {
    type: "filter",
    doc: 'An expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `["feature-state", ...]` expression is not supported in filter expressions.  The `["pitch"]` and `["distance-from-center"]` expressions are supported only for filter expressions on the symbol layer.'
  },
  layout: {
    type: "layout",
    doc: "Layout properties for the layer."
  },
  paint: {
    type: "paint",
    doc: "Default paint properties for this layer."
  }
};
var Oi = [
  "layout_fill",
  "layout_line",
  "layout_circle",
  "layout_heatmap",
  "layout_fill-extrusion",
  "layout_symbol",
  "layout_raster",
  "layout_hillshade",
  "layout_background",
  "layout_sky"
];
var qi = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var Li = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    "property-type": "constant"
  }
};
var Ni = {
  "fill-sort-key": {
    type: "number",
    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    "sdk-support": {
      "basic functionality": {
        js: "1.2.0",
        android: "9.1.0",
        ios: "5.8.0",
        macos: "0.15.0"
      },
      "data-driven styling": {
        js: "1.2.0",
        android: "9.1.0",
        ios: "5.8.0",
        macos: "0.15.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var Di = {
  "circle-sort-key": {
    type: "number",
    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    "sdk-support": {
      "basic functionality": {
        js: "1.2.0",
        android: "9.2.0",
        ios: "5.9.0",
        macos: "0.16.0"
      },
      "data-driven styling": {
        js: "1.2.0",
        android: "9.2.0",
        ios: "5.9.0",
        macos: "0.16.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var Pi = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    "property-type": "constant"
  }
};
var Mi = {
  "line-cap": {
    type: "enum",
    values: {
      butt: {
        doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."
      },
      round: {
        doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
      },
      square: {
        doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
      }
    },
    default: "butt",
    doc: "The display of line endings.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "2.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-join": {
    type: "enum",
    values: {
      bevel: {
        doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width."
      },
      round: {
        doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line."
      },
      miter: {
        doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."
      }
    },
    default: "miter",
    doc: "The display of lines when joining.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-miter-limit": {
    type: "number",
    default: 2,
    doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",
    requires: [
      {
        "line-join": "miter"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-round-limit": {
    type: "number",
    default: 1.05,
    doc: "Used to automatically convert round joins to miter joins for shallow angles.",
    requires: [
      {
        "line-join": "round"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-sort-key": {
    type: "number",
    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",
    "sdk-support": {
      "basic functionality": {
        js: "1.2.0",
        android: "9.1.0",
        ios: "5.8.0",
        macos: "0.15.0"
      },
      "data-driven styling": {
        js: "1.2.0",
        android: "9.1.0",
        ios: "5.8.0",
        macos: "0.15.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var $i = {
  "symbol-placement": {
    type: "enum",
    values: {
      point: {
        doc: "The label is placed at the point where the geometry is located."
      },
      line: {
        doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."
      },
      "line-center": {
        doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."
      }
    },
    default: "point",
    doc: "Label placement relative to its geometry.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "`line-center` value": {
        js: "0.47.0",
        android: "6.4.0",
        ios: "4.3.0",
        macos: "0.10.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-spacing": {
    type: "number",
    default: 250,
    minimum: 1,
    units: "pixels",
    doc: "Distance between two symbol anchors.",
    requires: [
      {
        "symbol-placement": "line"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-avoid-edges": {
    type: "boolean",
    default: false,
    doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-sort-key": {
    type: "number",
    doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",
    "sdk-support": {
      "basic functionality": {
        js: "0.53.0",
        android: "7.4.0",
        ios: "4.11.0",
        macos: "0.14.0"
      },
      "data-driven styling": {
        js: "0.53.0",
        android: "7.4.0",
        ios: "4.11.0",
        macos: "0.14.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "symbol-z-order": {
    type: "enum",
    values: {
      auto: {
        doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
      },
      "viewport-y": {
        doc: "Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."
      },
      source: {
        doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data."
      }
    },
    default: "auto",
    doc: "Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.",
    "sdk-support": {
      "basic functionality": {
        js: "0.49.0",
        android: "6.6.0",
        ios: "4.5.0",
        macos: "0.12.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-allow-overlap": {
    type: "boolean",
    default: false,
    doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-ignore-placement": {
    type: "boolean",
    default: false,
    doc: "If true, other symbols can be visible even if they collide with the icon.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-optional": {
    type: "boolean",
    default: false,
    doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
    requires: [
      "icon-image",
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-rotation-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."
      },
      viewport: {
        doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
      },
      auto: {
        doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
      }
    },
    default: "auto",
    doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "`auto` value": {
        js: "0.25.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-size": {
    type: "number",
    default: 1,
    minimum: 0,
    units: "factor of the original icon size",
    doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-text-fit": {
    type: "enum",
    values: {
      none: {
        doc: "The icon is displayed at its intrinsic aspect ratio."
      },
      width: {
        doc: "The icon is scaled in the x-dimension to fit the width of the text."
      },
      height: {
        doc: "The icon is scaled in the y-dimension to fit the height of the text."
      },
      both: {
        doc: "The icon is scaled in both x- and y-dimensions."
      }
    },
    default: "none",
    doc: "Scales the icon to fit around the associated text.",
    requires: [
      "icon-image",
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.21.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.2.1"
      },
      "stretchable icons": {
        js: "1.6.0",
        android: "9.2.0",
        ios: "5.8.0",
        macos: "0.15.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-text-fit-padding": {
    type: "array",
    value: "number",
    length: 4,
    default: [
      0,
      0,
      0,
      0
    ],
    units: "pixels",
    doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",
    requires: [
      "icon-image",
      "text-field",
      {
        "icon-text-fit": [
          "both",
          "width",
          "height"
        ]
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.21.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.2.1"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-image": {
    type: "resolvedImage",
    doc: "Name of image in sprite to use for drawing an image background.",
    tokens: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    doc: "Rotates the icon clockwise.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.21.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-padding": {
    type: "number",
    default: 2,
    minimum: 0,
    units: "pixels",
    doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-keep-upright": {
    type: "boolean",
    default: false,
    doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",
    requires: [
      "icon-image",
      {
        "icon-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-offset": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-anchor": {
    type: "enum",
    values: {
      center: {
        doc: "The center of the icon is placed closest to the anchor."
      },
      left: {
        doc: "The left side of the icon is placed closest to the anchor."
      },
      right: {
        doc: "The right side of the icon is placed closest to the anchor."
      },
      top: {
        doc: "The top of the icon is placed closest to the anchor."
      },
      bottom: {
        doc: "The bottom of the icon is placed closest to the anchor."
      },
      "top-left": {
        doc: "The top left corner of the icon is placed closest to the anchor."
      },
      "top-right": {
        doc: "The top right corner of the icon is placed closest to the anchor."
      },
      "bottom-left": {
        doc: "The bottom left corner of the icon is placed closest to the anchor."
      },
      "bottom-right": {
        doc: "The bottom right corner of the icon is placed closest to the anchor."
      }
    },
    default: "center",
    doc: "Part of the icon placed closest to the anchor.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      },
      "data-driven styling": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-pitch-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "The icon is aligned to the plane of the map."
      },
      viewport: {
        doc: "The icon is aligned to the plane of the viewport."
      },
      auto: {
        doc: "Automatically matches the value of `icon-rotation-alignment`."
      }
    },
    default: "auto",
    doc: "Orientation of icon when map is pitched.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-pitch-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "The text is aligned to the plane of the map."
      },
      viewport: {
        doc: "The text is aligned to the plane of the viewport."
      },
      auto: {
        doc: "Automatically matches the value of `text-rotation-alignment`."
      }
    },
    default: "auto",
    doc: "Orientation of text when map is pitched.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.21.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.2.1"
      },
      "`auto` value": {
        js: "0.25.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotation-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."
      },
      viewport: {
        doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."
      },
      auto: {
        doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."
      }
    },
    default: "auto",
    doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "`auto` value": {
        js: "0.25.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-field": {
    type: "formatted",
    default: "",
    tokens: true,
    doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-font": {
    type: "array",
    value: "string",
    default: [
      "Open Sans Regular",
      "Arial Unicode MS Regular"
    ],
    doc: "Font stack to use for displaying text.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-size": {
    type: "number",
    default: 16,
    minimum: 0,
    units: "pixels",
    doc: "Font size.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-width": {
    type: "number",
    default: 10,
    minimum: 0,
    units: "ems",
    doc: "The maximum line width for text wrapping.",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-line-height": {
    type: "number",
    default: 1.2,
    units: "ems",
    doc: "Text leading value for multi-line text.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "2.3.0",
        android: "10.0.0",
        ios: "10.0.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-letter-spacing": {
    type: "number",
    default: 0,
    units: "ems",
    doc: "Text tracking amount.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.40.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-justify": {
    type: "enum",
    values: {
      auto: {
        doc: "The text is aligned towards the anchor position."
      },
      left: {
        doc: "The text is aligned to the left."
      },
      center: {
        doc: "The text is centered."
      },
      right: {
        doc: "The text is aligned to the right."
      }
    },
    default: "center",
    doc: "Text justification options.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      },
      auto: {
        js: "0.54.0",
        android: "7.4.0",
        ios: "4.10.0",
        macos: "0.14.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-radial-offset": {
    type: "number",
    units: "ems",
    default: 0,
    doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
    "sdk-support": {
      "basic functionality": {
        js: "0.54.0",
        android: "7.4.0",
        ios: "4.10.0",
        macos: "0.14.0"
      },
      "data-driven styling": {
        js: "0.54.0",
        android: "7.4.0",
        ios: "4.10.0",
        macos: "0.14.0"
      }
    },
    requires: [
      "text-field"
    ],
    "property-type": "data-driven",
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    }
  },
  "text-variable-anchor": {
    type: "array",
    value: "enum",
    values: {
      center: {
        doc: "The center of the text is placed closest to the anchor."
      },
      left: {
        doc: "The left side of the text is placed closest to the anchor."
      },
      right: {
        doc: "The right side of the text is placed closest to the anchor."
      },
      top: {
        doc: "The top of the text is placed closest to the anchor."
      },
      bottom: {
        doc: "The bottom of the text is placed closest to the anchor."
      },
      "top-left": {
        doc: "The top left corner of the text is placed closest to the anchor."
      },
      "top-right": {
        doc: "The top right corner of the text is placed closest to the anchor."
      },
      "bottom-left": {
        doc: "The bottom left corner of the text is placed closest to the anchor."
      },
      "bottom-right": {
        doc: "The bottom right corner of the text is placed closest to the anchor."
      }
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",
    "sdk-support": {
      "basic functionality": {
        js: "0.54.0",
        android: "7.4.0",
        ios: "4.10.0",
        macos: "0.14.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-anchor": {
    type: "enum",
    values: {
      center: {
        doc: "The center of the text is placed closest to the anchor."
      },
      left: {
        doc: "The left side of the text is placed closest to the anchor."
      },
      right: {
        doc: "The right side of the text is placed closest to the anchor."
      },
      top: {
        doc: "The top of the text is placed closest to the anchor."
      },
      bottom: {
        doc: "The bottom of the text is placed closest to the anchor."
      },
      "top-left": {
        doc: "The top left corner of the text is placed closest to the anchor."
      },
      "top-right": {
        doc: "The top right corner of the text is placed closest to the anchor."
      },
      "bottom-left": {
        doc: "The bottom left corner of the text is placed closest to the anchor."
      },
      "bottom-right": {
        doc: "The bottom right corner of the text is placed closest to the anchor."
      }
    },
    default: "center",
    doc: "Part of the text placed closest to the anchor.",
    requires: [
      "text-field",
      {
        "!": "text-variable-anchor"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-angle": {
    type: "number",
    default: 45,
    units: "degrees",
    doc: "Maximum angle change between adjacent characters.",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-writing-mode": {
    type: "array",
    value: "enum",
    values: {
      horizontal: {
        doc: "If a text's language supports horizontal writing mode, symbols would be laid out horizontally."
      },
      vertical: {
        doc: "If a text's language supports vertical writing mode, symbols would be laid out vertically."
      }
    },
    doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesn\u2019t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "1.3.0",
        android: "8.3.0",
        ios: "5.3.0",
        macos: "0.15.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    doc: "Rotates the text clockwise.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-padding": {
    type: "number",
    default: 2,
    minimum: 0,
    units: "pixels",
    doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-keep-upright": {
    type: "boolean",
    default: true,
    doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
    requires: [
      "text-field",
      {
        "text-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-transform": {
    type: "enum",
    values: {
      none: {
        doc: "The text is not altered."
      },
      uppercase: {
        doc: "Forces all letters to be displayed in uppercase."
      },
      lowercase: {
        doc: "Forces all letters to be displayed in lowercase."
      }
    },
    default: "none",
    doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-offset": {
    type: "array",
    doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",
    value: "number",
    units: "ems",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "text-field",
      {
        "!": "text-radial-offset"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.35.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-allow-overlap": {
    type: "boolean",
    default: false,
    doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-ignore-placement": {
    type: "boolean",
    default: false,
    doc: "If true, other symbols can be visible even if they collide with the text.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-optional": {
    type: "boolean",
    default: false,
    doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
    requires: [
      "text-field",
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var Fi = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    "property-type": "constant"
  }
};
var Ui = {
  visibility: {
    type: "enum",
    values: {
      visible: {
        doc: "The layer is shown."
      },
      none: {
        doc: "The layer is not shown."
      }
    },
    default: "visible",
    doc: "Whether this layer is displayed.",
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    "property-type": "constant"
  }
};
var Bi = {
  type: "array",
  value: "*",
  doc: "A filter selects specific features from a layer."
};
var Wi = {
  type: "boolean",
  doc: 'Expression which determines whether or not to display a symbol. Symbols support dynamic filtering, meaning this expression can use the `["pitch"]` and `["distance-from-center"]` expressions to reference the current state of the view.',
  default: false,
  transition: false,
  "property-type": "data-driven",
  expression: {
    interpolated: false,
    parameters: [
      "zoom",
      "feature",
      "pitch",
      "distance-from-center"
    ]
  }
};
var Ji = {
  type: "boolean",
  doc: 'Expression which determines whether or not to display a polygon. Fill layer does NOT support dynamic filtering, meaning this expression can NOT use the `["pitch"]` and `["distance-from-center"]` expressions to reference the current state of the view.',
  default: false,
  transition: false,
  "property-type": "data-driven",
  expression: {
    interpolated: false,
    parameters: [
      "zoom",
      "feature"
    ]
  }
};
var Vi = {
  type: "boolean",
  doc: 'Expression which determines whether or not to display a Polygon or LineString. Line layer does NOT support dynamic filtering, meaning this expression can NOT use the `["pitch"]` and `["distance-from-center"]` expressions to reference the current state of the view.',
  default: false,
  transition: false,
  "property-type": "data-driven",
  expression: {
    interpolated: false,
    parameters: [
      "zoom",
      "feature"
    ]
  }
};
var Hi = {
  type: "boolean",
  doc: 'Expression which determines whether or not to display a circle. Circle layer does NOT support dynamic filtering, meaning this expression can NOT use the `["pitch"]` and `["distance-from-center"]` expressions to reference the current state of the view.',
  default: false,
  transition: false,
  "property-type": "data-driven",
  expression: {
    interpolated: false,
    parameters: [
      "zoom",
      "feature"
    ]
  }
};
var Gi = {
  type: "boolean",
  doc: 'Expression used to determine whether a point is being displayed or not. Heatmap layer does NOT support dynamic filtering, meaning this expression can NOT use the `["pitch"]` and `["distance-from-center"]` expressions to reference the current state of the view.',
  default: false,
  transition: false,
  "property-type": "data-driven",
  expression: {
    interpolated: false,
    parameters: [
      "zoom",
      "feature"
    ]
  }
};
var Zi = {
  type: "enum",
  values: {
    "==": {
      doc: '`["==", key, value]` equality: `feature[key] = value`'
    },
    "!=": {
      doc: '`["!=", key, value]` inequality: `feature[key] \u2260 value`'
    },
    ">": {
      doc: '`[">", key, value]` greater than: `feature[key] > value`'
    },
    ">=": {
      doc: '`[">=", key, value]` greater than or equal: `feature[key] \u2265 value`'
    },
    "<": {
      doc: '`["<", key, value]` less than: `feature[key] < value`'
    },
    "<=": {
      doc: '`["<=", key, value]` less than or equal: `feature[key] \u2264 value`'
    },
    in: {
      doc: '`["in", key, v0, ..., vn]` set inclusion: `feature[key] \u2208 {v0, ..., vn}`'
    },
    "!in": {
      doc: '`["!in", key, v0, ..., vn]` set exclusion: `feature[key] \u2209 {v0, ..., vn}`'
    },
    all: {
      doc: '`["all", f0, ..., fn]` logical `AND`: `f0 \u2227 ... \u2227 fn`'
    },
    any: {
      doc: '`["any", f0, ..., fn]` logical `OR`: `f0 \u2228 ... \u2228 fn`'
    },
    none: {
      doc: '`["none", f0, ..., fn]` logical `NOR`: `\xACf0 \u2227 ... \u2227 \xACfn`'
    },
    has: {
      doc: '`["has", key]` `feature[key]` exists'
    },
    "!has": {
      doc: '`["!has", key]` `feature[key]` does not exist'
    },
    within: {
      doc: '`["within", object]` feature geometry is within object geometry'
    }
  },
  doc: "The filter operator."
};
var Xi = {
  type: "enum",
  values: {
    Point: {
      doc: "Filter to point geometries."
    },
    LineString: {
      doc: "Filter to line geometries."
    },
    Polygon: {
      doc: "Filter to polygon geometries."
    }
  },
  doc: "The geometry type for the filter to select."
};
var Yi = {
  type: "array",
  minimum: 0,
  maximum: 24,
  value: [
    "number",
    "color"
  ],
  length: 2,
  doc: "Zoom level and value pair."
};
var Ki = {
  type: "array",
  value: "*",
  minimum: 1,
  doc: "An expression defines a function that can be used for data-driven style properties or feature filters."
};
var Qi = {
  doc: "",
  type: "enum",
  values: {
    let: {
      doc: 'Binds expressions to named variables, which can then be referenced in the result expression using ["var", "variable_name"].',
      group: "Variable binding",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    var: {
      doc: 'References variable bound using "let".',
      group: "Variable binding",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    literal: {
      doc: "Provides a literal array or object value.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    array: {
      doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    at: {
      doc: "Retrieves an item from an array.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    in: {
      doc: "Determines whether an item exists in an array or a substring exists in a string. In the specific case when the second and third arguments are string literals, you must wrap at least one of them in a [`literal`](#types-literal) expression to hint correct interpretation to the [type system](#type-system).",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "1.6.0",
          android: "9.1.0",
          ios: "5.8.0",
          macos: "0.15.0"
        }
      }
    },
    "index-of": {
      doc: "Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "1.10.0",
          android: "10.0.0",
          ios: "10.0.0"
        }
      }
    },
    slice: {
      doc: "Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "1.10.0",
          android: "10.0.0",
          ios: "10.0.0"
        }
      }
    },
    case: {
      doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    match: {
      doc: 'Selects the output for which the label value matches the input value, or the fallback value if no match is found. The input can be any expression (for example, `["get", "building_type"]`). Each label must be unique, and must be either:\n - a single literal value; or\n - an array of literal values, the values of which must be all strings or all numbers (for example `[100, 101]` or `["c", "b"]`).\n\nThe input matches if any of the values in the array matches using strict equality, similar to the `"in"` operator.\nIf the input type does not match the type of the labels, the result will be the fallback value.',
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    coalesce: {
      doc: "Evaluates each expression in turn until the first valid value is obtained. Invalid values are `null` and [`'image'`](#types-image) expressions that are unavailable in the style. If all values are invalid, `coalesce` returns the first value listed.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    step: {
      doc: 'Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values ("stops"). The `input` may be any numeric expression (e.g., `["get", "population"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.',
      group: "Ramps, scales, curves",
      "sdk-support": {
        "basic functionality": {
          js: "0.42.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    interpolate: {
      doc: 'Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). The `input` may be any numeric expression (e.g., `["get", "population"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `["linear"]`: Interpolates linearly between the pair of stops just less than and just greater than the input.\n- `["exponential", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `["cubic-bezier", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.',
      group: "Ramps, scales, curves",
      "sdk-support": {
        "basic functionality": {
          js: "0.42.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "interpolate-hcl": {
      doc: 'Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.',
      group: "Ramps, scales, curves",
      "sdk-support": {
        "basic functionality": {
          js: "0.49.0"
        }
      }
    },
    "interpolate-lab": {
      doc: 'Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.',
      group: "Ramps, scales, curves",
      "sdk-support": {
        "basic functionality": {
          js: "0.49.0"
        }
      }
    },
    ln2: {
      doc: "Returns mathematical constant ln(2).",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    pi: {
      doc: "Returns the mathematical constant pi.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    e: {
      doc: "Returns the mathematical constant e.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    typeof: {
      doc: "Returns a string describing the type of the given value.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    string: {
      doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    number: {
      doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    boolean: {
      doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    object: {
      doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    collator: {
      doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    format: {
      doc: 'Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`\'image\'`](#types-image) expression. Strings may be followed by a style override object that supports the following properties:\n- `"text-font"`: Overrides the font stack specified by the root layout property.\n- `"text-color"`: Overrides the color specified by the root paint property.\n- `"font-scale"`: Applies a scaling factor on `text-size` as specified by the root layout property.',
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.48.0",
          android: "6.7.0",
          ios: "4.6.0",
          macos: "0.12.0"
        },
        "text-font": {
          js: "0.48.0",
          android: "6.7.0",
          ios: "4.6.0",
          macos: "0.12.0"
        },
        "font-scale": {
          js: "0.48.0",
          android: "6.7.0",
          ios: "4.6.0",
          macos: "0.12.0"
        },
        "text-color": {
          js: "1.3.0",
          android: "7.3.0",
          ios: "4.10.0",
          macos: "0.14.0"
        },
        image: {
          js: "1.6.0",
          android: "8.6.0",
          ios: "5.7.0",
          macos: "0.15.0"
        }
      }
    },
    image: {
      doc: "Returns a [`ResolvedImage`](/mapbox-gl-js/style-spec/types/#resolvedimage) for use in [`icon-image`](/mapbox-gl-js/style-spec/layers/#layout-symbol-icon-image), `*-pattern` entries, and as a section in the [`'format'`](#types-format) expression. A [`'coalesce'`](#coalesce) expression containing `image` expressions will evaluate to the first listed image that is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `'image'` argument.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "1.4.0",
          android: "8.6.0",
          ios: "5.7.0",
          macos: "0.15.0"
        }
      }
    },
    "number-format": {
      doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `unit` argument specifies a [simple ECMAScript unit](https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_proposed_out.html#sec-issanctionedsimpleunitidentifier) to use for unit-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.54.0",
          android: "8.4.0",
          ios: "5.4.0",
          macos: "0.15.0"
        }
      }
    },
    "to-string": {
      doc: 'Converts the input value to a string. If the input is `null`, the result is `""`. If the input is a [`boolean`](#types-boolean), the result is `"true"` or `"false"`. If the input is a number, it is converted to a string as specified by the ["NumberToString" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a [`color`](#color), it is converted to a string of the form `"rgba(r,g,b,a)"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. If the input is an [`\'image\'`](#types-image) expression, `\'to-string\'` returns the image name. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.',
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "to-number": {
      doc: 'Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the ["ToNumber Applied to the String Type" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.',
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "to-boolean": {
      doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "to-rgba": {
      doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
      group: "Color",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "to-color": {
      doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",
      group: "Types",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    rgb: {
      doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",
      group: "Color",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    rgba: {
      doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",
      group: "Color",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    get: {
      doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns `null` if the requested property is missing.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    has: {
      doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    length: {
      doc: "Returns the length of an array or string.",
      group: "Lookup",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    properties: {
      doc: 'Returns the feature properties object.  Note that in some cases, it may be more efficient to use `["get", "property_name"]` directly.',
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "feature-state": {
      doc: "Retrieves a property value from the current feature's state. Returns `null` if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.46.0",
          android: "10.0.0",
          ios: "10.0.0"
        }
      }
    },
    "geometry-type": {
      doc: "Returns the feature's geometry type: `Point`, `LineString` or `Polygon`. `Multi*` feature types return the singular forms.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    id: {
      doc: "Returns the feature's id, if it has one.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    zoom: {
      doc: 'Returns the current zoom level.  Note that in style layout and paint properties, ["zoom"] may only appear as the input to a top-level "step" or "interpolate" expression.',
      group: "Camera",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    pitch: {
      doc: 'Returns the current pitch in degrees. `["pitch"]` may only be used in the `filter` expression for a `symbol` layer.',
      group: "Camera",
      "sdk-support": {
        "basic functionality": {
          js: "2.6.0",
          android: "10.9.0",
          ios: "10.9.0"
        }
      }
    },
    "distance-from-center": {
      doc: 'Returns the distance of a `symbol` instance from the center of the map. The distance is measured in pixels divided by the height of the map container. It measures 0 at the center, decreases towards the camera and increase away from the camera. For example, if the height of the map is 1000px, a value of -1 means 1000px away from the center towards the camera, and a value of 1 means a distance of 1000px away from the camera from the center. `["distance-from-center"]` may only be used in the `filter` expression for a `symbol` layer.',
      group: "Camera",
      "sdk-support": {
        "basic functionality": {
          js: "2.6.0",
          android: "10.9.0",
          ios: "10.9.0"
        }
      }
    },
    "heatmap-density": {
      doc: "Returns the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",
      group: "Heatmap",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "line-progress": {
      doc: "Returns the progress along a gradient line. Can only be used in the `line-gradient` property.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.6.0",
          macos: "0.12.0"
        }
      }
    },
    "sky-radial-progress": {
      doc: "Returns the distance of a point on the sky from the sun position. Returns 0 at sun position and 1 when the distance reaches `sky-gradient-radius`. Can only be used in the `sky-gradient` property.",
      group: "sky",
      "sdk-support": {
        "basic functionality": {
          js: "2.0.0",
          ios: "10.0.0",
          android: "10.0.0"
        }
      }
    },
    accumulated: {
      doc: "Returns the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",
      group: "Feature data",
      "sdk-support": {
        "basic functionality": {
          js: "0.53.0",
          android: "8.4.0",
          ios: "5.5.0",
          macos: "0.15.0"
        }
      }
    },
    "+": {
      doc: "Returns the sum of the inputs.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "*": {
      doc: "Returns the product of the inputs.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "-": {
      doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "/": {
      doc: "Returns the result of floating point division of the first input by the second.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "%": {
      doc: "Returns the remainder after integer division of the first input by the second.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "^": {
      doc: "Returns the result of raising the first input to the power specified by the second.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    sqrt: {
      doc: "Returns the square root of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.42.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    log10: {
      doc: "Returns the base-ten logarithm of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    ln: {
      doc: "Returns the natural logarithm of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    log2: {
      doc: "Returns the base-two logarithm of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    sin: {
      doc: "Returns the sine of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    cos: {
      doc: "Returns the cosine of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    tan: {
      doc: "Returns the tangent of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    asin: {
      doc: "Returns the arcsine of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    acos: {
      doc: "Returns the arccosine of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    atan: {
      doc: "Returns the arctangent of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    min: {
      doc: "Returns the minimum value of the inputs.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    max: {
      doc: "Returns the maximum value of the inputs.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    round: {
      doc: 'Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `["round", -1.5]` evaluates to -2.',
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    abs: {
      doc: "Returns the absolute value of the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    ceil: {
      doc: "Returns the smallest integer that is greater than or equal to the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    floor: {
      doc: "Returns the largest integer that is less than or equal to the input.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    distance: {
      doc: "Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.",
      group: "Math",
      "sdk-support": {
        "basic functionality": {
          android: "9.2.0",
          ios: "5.9.0",
          macos: "0.16.0"
        }
      }
    },
    "==": {
      doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    "!=": {
      doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    ">": {
      doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    "<": {
      doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    ">=": {
      doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    "<=": {
      doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        },
        collator: {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    },
    all: {
      doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    any: {
      doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "!": {
      doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    within: {
      doc: "Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:\n- `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.\n- `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line's endpoint is on the boundary.",
      group: "Decision",
      "sdk-support": {
        "basic functionality": {
          js: "1.9.0",
          android: "9.1.0",
          ios: "5.8.0",
          macos: "0.15.0"
        }
      }
    },
    "is-supported-script": {
      doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.6.0",
          ios: "4.1.0",
          macos: "0.8.0"
        }
      }
    },
    upcase: {
      doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    downcase: {
      doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    concat: {
      doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.41.0",
          android: "6.0.0",
          ios: "4.0.0",
          macos: "0.7.0"
        }
      }
    },
    "resolved-locale": {
      doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",
      group: "String",
      "sdk-support": {
        "basic functionality": {
          js: "0.45.0",
          android: "6.5.0",
          ios: "4.2.0",
          macos: "0.9.0"
        }
      }
    }
  }
};
var eo = {
  range: {
    type: "array",
    default: [
      0.5,
      10
    ],
    minimum: -20,
    maximum: 20,
    length: 2,
    value: "number",
    "property-type": "data-constant",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    doc: "The start and end distance range in which fog fades from fully transparent to fully opaque. The distance to the point at the center of the map is defined as zero, so that negative range values are closer to the camera, and positive values are farther away.",
    example: [
      0.5,
      10
    ],
    "sdk-support": {
      "basic functionality": {
        js: "2.3.0",
        android: "10.6.0",
        ios: "10.6.0"
      }
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true,
    doc: "The color of the atmosphere region immediately below the horizon and within the `range` and above the horizon and within `horizon-blend`. Using opacity is recommended only for smoothly transitioning fog on/off as anything less than 100% opacity results in more tiles loaded and drawn.",
    "sdk-support": {
      "basic functionality": {
        js: "2.3.0",
        android: "10.6.0",
        ios: "10.6.0"
      }
    }
  },
  "high-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#245cdf",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true,
    doc: "The color of the atmosphere region above the horizon, `high-color` extends further above the horizon than the `color` property and its spread can be controlled with `horizon-blend`. The opacity can be set to `0` to remove the high atmosphere color contribution.",
    "sdk-support": {
      "basic functionality": {
        js: "2.9.0",
        android: "10.6.0",
        ios: "10.6.0"
      }
    }
  },
  "space-color": {
    type: "color",
    "property-type": "data-constant",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "zoom"
      ],
      4,
      "#010b19",
      7,
      "#367ab9"
    ],
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true,
    doc: "The color of the region above the horizon and after the end of the `horizon-blend` contribution. The opacity can be set to `0` to have a transparent background.",
    "sdk-support": {
      "basic functionality": {
        js: "2.9.0",
        android: "10.6.0",
        ios: "10.6.0"
      }
    }
  },
  "horizon-blend": {
    type: "number",
    "property-type": "data-constant",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "zoom"
      ],
      4,
      0.2,
      7,
      0.1
    ],
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true,
    doc: "Horizon blend applies a smooth fade from the color of the atmosphere to the color of space. A value of zero leaves a sharp transition from atmosphere to space. Increasing the value blends the color of atmosphere into increasingly high angles of the sky.",
    "sdk-support": {
      "basic functionality": {
        js: "2.3.0",
        android: "10.6.0",
        ios: "10.6.0"
      }
    }
  },
  "star-intensity": {
    type: "number",
    "property-type": "data-constant",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "zoom"
      ],
      5,
      0.35,
      6,
      0
    ],
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true,
    doc: "A value controlling the star intensity where `0` will show no stars and `1` will show stars at their maximum intensity.",
    "sdk-support": {
      "basic functionality": {
        js: "2.9.0",
        android: "10.6.0",
        ios: "10.6.0"
      }
    }
  }
};
var to = {
  anchor: {
    type: "enum",
    default: "viewport",
    values: {
      map: {
        doc: "The position of the light source is aligned to the rotation of the map."
      },
      viewport: {
        doc: "The position of the light source is aligned to the rotation of the viewport."
      }
    },
    "property-type": "data-constant",
    transition: false,
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    doc: "Whether extruded geometries are lit relative to the map or viewport.",
    example: "map",
    "sdk-support": {
      "basic functionality": {
        js: "0.27.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    }
  },
  position: {
    type: "array",
    default: [
      1.15,
      210,
      30
    ],
    length: 3,
    value: "number",
    "property-type": "data-constant",
    transition: true,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0\xB0 (0\xB0 when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0\xB0 when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0\xB0, directly above, to 180\xB0, directly below).",
    example: [
      1.5,
      90,
      80
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.27.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true,
    doc: "Color tint for lighting extruded geometries.",
    "sdk-support": {
      "basic functionality": {
        js: "0.27.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    }
  },
  intensity: {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true,
    doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",
    "sdk-support": {
      "basic functionality": {
        js: "0.27.0",
        android: "5.1.0",
        ios: "3.6.0",
        macos: "0.5.0"
      }
    }
  }
};
var ro = {
  name: {
    type: "enum",
    values: {
      albers: {
        doc: "An Albers equal-area projection centered on the continental United States. You can configure the projection for a different region by setting `center` and `parallels` properties. You may want to set max bounds to constrain the map to the relevant region."
      },
      equalEarth: {
        doc: "An Equal Earth projection."
      },
      equirectangular: {
        doc: "An Equirectangular projection. This projection is very similar to the Plate Carr\xE9e projection."
      },
      lambertConformalConic: {
        doc: "A Lambert conformal conic projection. You can configure the projection for a region by setting `center` and `parallels` properties. You may want to set max bounds to constrain the map to the relevant region."
      },
      mercator: {
        doc: "The Mercator projection is the default projection."
      },
      naturalEarth: {
        doc: "A Natural Earth projection."
      },
      winkelTripel: {
        doc: "A Winkel Tripel projection."
      },
      globe: {
        doc: "A globe projection."
      }
    },
    default: "mercator",
    doc: "The name of the projection to be used for rendering the map.",
    required: true,
    "sdk-support": {
      "basic functionality": {
        js: "2.6.0"
      }
    }
  },
  center: {
    type: "array",
    length: 2,
    value: "number",
    "property-type": "data-constant",
    minimum: [
      -180,
      -90
    ],
    maximum: [
      180,
      90
    ],
    transition: false,
    doc: "The reference longitude and latitude of the projection. `center` takes the form of [lng, lat]. This property is only configurable for conic projections (Albers and Lambert Conformal Conic). All other projections are centered on [0, 0].",
    example: [
      -96,
      37.5
    ],
    requires: [
      {
        name: [
          "albers",
          "lambertConformalConic"
        ]
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "2.6.0"
      }
    }
  },
  parallels: {
    type: "array",
    length: 2,
    value: "number",
    "property-type": "data-constant",
    minimum: [
      -90,
      -90
    ],
    maximum: [
      90,
      90
    ],
    transition: false,
    doc: "The standard parallels of the projection, denoting the desired latitude range with minimal distortion. `parallels` takes the form of [lat0, lat1]. This property is only configurable for conic projections (Albers and Lambert Conformal Conic).",
    example: [
      29.5,
      45.5
    ],
    requires: [
      {
        name: [
          "albers",
          "lambertConformalConic"
        ]
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "2.6.0"
      }
    }
  }
};
var no = {
  source: {
    type: "string",
    doc: "Name of a source of `raster_dem` type to be used for terrain elevation.",
    required: true,
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    }
  },
  exaggeration: {
    type: "number",
    "property-type": "data-constant",
    default: 1,
    minimum: 0,
    maximum: 1e3,
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    transition: true,
    doc: "Exaggerates the elevation of the terrain by multiplying the data from the DEM with this value.",
    requires: [
      "source"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    }
  }
};
var io = [
  "paint_fill",
  "paint_line",
  "paint_circle",
  "paint_heatmap",
  "paint_fill-extrusion",
  "paint_symbol",
  "paint_raster",
  "paint_hillshade",
  "paint_background",
  "paint_sky"
];
var oo = {
  "fill-antialias": {
    type: "boolean",
    default: true,
    doc: "Whether or not the fill should be antialiased.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.21.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-color": {
    type: "color",
    default: "#000000",
    doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
    transition: true,
    requires: [
      {
        "!": "fill-pattern"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.19.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-outline-color": {
    type: "color",
    doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
    transition: true,
    requires: [
      {
        "!": "fill-pattern"
      },
      {
        "fill-antialias": true
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.19.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The fill is translated relative to the map."
      },
      viewport: {
        doc: "The fill is translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `fill-translate`.",
    default: "map",
    requires: [
      "fill-translate"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-pattern": {
    type: "resolvedImage",
    transition: false,
    doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.49.0",
        android: "6.5.0",
        macos: "0.11.0",
        ios: "4.4.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  }
};
var ao = {
  "line-opacity": {
    type: "number",
    doc: "The opacity at which the line will be drawn.",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-color": {
    type: "color",
    doc: "The color with which the line will be drawn.",
    default: "#000000",
    transition: true,
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.23.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The line is translated relative to the map."
      },
      viewport: {
        doc: "The line is translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `line-translate`.",
    default: "map",
    requires: [
      "line-translate"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-width": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Stroke thickness.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-gap-width": {
    type: "number",
    default: 0,
    minimum: 0,
    doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
    transition: true,
    units: "pixels",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-offset": {
    type: "number",
    default: 0,
    doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
    transition: true,
    units: "pixels",
    "sdk-support": {
      "basic functionality": {
        js: "0.12.1",
        android: "3.0.0",
        ios: "3.1.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Blur applied to the line, in pixels.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-dasharray": {
    type: "array",
    value: "number",
    doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    minimum: 0,
    transition: false,
    units: "line widths",
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "2.3.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-pattern": {
    type: "resolvedImage",
    transition: false,
    doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.49.0",
        android: "6.5.0",
        macos: "0.11.0",
        ios: "4.4.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-gradient": {
    type: "color",
    doc: 'Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `"lineMetrics": true`.',
    transition: false,
    requires: [
      {
        "!": "line-pattern"
      },
      {
        source: "geojson",
        has: {
          lineMetrics: true
        }
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.45.0",
        android: "6.5.0",
        ios: "4.4.0",
        macos: "0.11.0"
      },
      "data-driven styling": {}
    },
    expression: {
      interpolated: true,
      parameters: [
        "line-progress"
      ]
    },
    "property-type": "color-ramp"
  },
  "line-trim-offset": {
    type: "array",
    value: "number",
    doc: "The line part between [trim-start, trim-end] will be marked as transparent to make a route vanishing effect. The line trim-off offset is based on the whole line range [0.0, 1.0].",
    length: 2,
    default: [
      0,
      0
    ],
    minimum: [
      0,
      0
    ],
    maximum: [
      1,
      1
    ],
    transition: false,
    requires: [
      {
        source: "geojson",
        has: {
          lineMetrics: true
        }
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "2.9.0",
        android: "10.5.0",
        ios: "10.5.0",
        macos: "10.5.0"
      }
    },
    "property-type": "constant"
  }
};
var so = {
  "circle-radius": {
    type: "number",
    default: 5,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Circle radius.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.18.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-color": {
    type: "color",
    default: "#000000",
    doc: "The fill color of the circle.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.18.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-blur": {
    type: "number",
    default: 0,
    doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.20.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-opacity": {
    type: "number",
    doc: "The opacity at which the circle will be drawn.",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.20.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The circle is translated relative to the map."
      },
      viewport: {
        doc: "The circle is translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `circle-translate`.",
    default: "map",
    requires: [
      "circle-translate"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-scale": {
    type: "enum",
    values: {
      map: {
        doc: "Circles are scaled according to their apparent distance to the camera."
      },
      viewport: {
        doc: "Circles are not scaled."
      }
    },
    default: "map",
    doc: "Controls the scaling behavior of the circle when the map is pitched.",
    "sdk-support": {
      "basic functionality": {
        js: "0.21.0",
        android: "4.2.0",
        ios: "3.4.0",
        macos: "0.2.1"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-alignment": {
    type: "enum",
    values: {
      map: {
        doc: "The circle is aligned to the plane of the map."
      },
      viewport: {
        doc: "The circle is aligned to the plane of the viewport."
      }
    },
    default: "viewport",
    doc: "Orientation of circle when map is pitched.",
    "sdk-support": {
      "basic functionality": {
        js: "0.39.0",
        android: "5.2.0",
        ios: "3.7.0",
        macos: "0.6.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-stroke-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
    "sdk-support": {
      "basic functionality": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-color": {
    type: "color",
    default: "#000000",
    doc: "The stroke color of the circle.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-opacity": {
    type: "number",
    doc: "The opacity of the circle's stroke.",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      },
      "data-driven styling": {
        js: "0.29.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  }
};
var lo = {
  "heatmap-radius": {
    type: "number",
    default: 30,
    minimum: 1,
    transition: true,
    units: "pixels",
    doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed. `queryRenderedFeatures` on heatmap layers will return points within this radius.",
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      },
      "data-driven styling": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-weight": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: false,
    doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      },
      "data-driven styling": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-intensity": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: true,
    doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "heatmap-color": {
    type: "color",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "heatmap-density"
      ],
      0,
      "rgba(0, 0, 255, 0)",
      0.1,
      "royalblue",
      0.3,
      "cyan",
      0.5,
      "lime",
      0.7,
      "yellow",
      1,
      "red"
    ],
    doc: 'Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `["heatmap-density"]` as input.',
    transition: false,
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      },
      "data-driven styling": {}
    },
    expression: {
      interpolated: true,
      parameters: [
        "heatmap-density"
      ]
    },
    "property-type": "color-ramp"
  },
  "heatmap-opacity": {
    type: "number",
    doc: "The global opacity at which the heatmap layer will be drawn.",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.41.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var uo = {
  "icon-opacity": {
    doc: "The opacity at which the icon will be drawn.",
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-color": {
    type: "color",
    default: "#000000",
    transition: true,
    doc: "The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: true,
    doc: "The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Distance of halo to the icon outline.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Fade out the halo towards the outside.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
    requires: [
      "icon-image"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "Icons are translated relative to the map."
      },
      viewport: {
        doc: "Icons are translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `icon-translate`.",
    default: "map",
    requires: [
      "icon-image",
      "icon-translate"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-opacity": {
    type: "number",
    doc: "The opacity at which the text will be drawn.",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-color": {
    type: "color",
    doc: "The color with which the text will be drawn.",
    default: "#000000",
    transition: true,
    overridable: true,
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: true,
    doc: "The color of the text's halo, which helps it stand out from backgrounds.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: true,
    units: "pixels",
    doc: "The halo's fadeout distance towards the outside.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      },
      "data-driven styling": {
        js: "0.33.0",
        android: "5.0.0",
        ios: "3.5.0",
        macos: "0.4.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: true,
    units: "pixels",
    doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
    requires: [
      "text-field"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-translate-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The text is translated relative to the map."
      },
      viewport: {
        doc: "The text is translated relative to the viewport."
      }
    },
    doc: "Controls the frame of reference for `text-translate`.",
    default: "map",
    requires: [
      "text-field",
      "text-translate"
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var co = {
  "raster-opacity": {
    type: "number",
    doc: "The opacity at which the image will be drawn.",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-hue-rotate": {
    type: "number",
    default: 0,
    period: 360,
    transition: true,
    units: "degrees",
    doc: "Rotates hues around the color wheel.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-min": {
    type: "number",
    doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",
    default: 0,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-max": {
    type: "number",
    doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-saturation": {
    type: "number",
    doc: "Increase or reduce the saturation of the image.",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-contrast": {
    type: "number",
    doc: "Increase or reduce the contrast of the image.",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-resampling": {
    type: "enum",
    doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",
    values: {
      linear: {
        doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"
      },
      nearest: {
        doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"
      }
    },
    default: "linear",
    "sdk-support": {
      "basic functionality": {
        js: "0.47.0",
        android: "6.3.0",
        ios: "4.2.0",
        macos: "0.9.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-fade-duration": {
    type: "number",
    default: 300,
    minimum: 0,
    transition: false,
    units: "milliseconds",
    doc: "Fade duration when a new tile is added.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var po = {
  "hillshade-illumination-direction": {
    type: "number",
    default: 335,
    minimum: 0,
    maximum: 359,
    doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",
    transition: false,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-anchor": {
    type: "enum",
    values: {
      map: {
        doc: "The hillshade illumination is relative to the north direction."
      },
      viewport: {
        doc: "The hillshade illumination is relative to the top of the viewport."
      }
    },
    default: "viewport",
    doc: "Direction of light source when map is rotated.",
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-exaggeration": {
    type: "number",
    doc: "Intensity of the hillshade",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-shadow-color": {
    type: "color",
    default: "#000000",
    doc: "The shading color of areas that face away from the light source.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-highlight-color": {
    type: "color",
    default: "#FFFFFF",
    doc: "The shading color of areas that faces towards the light source.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-accent-color": {
    type: "color",
    default: "#000000",
    doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.43.0",
        android: "6.0.0",
        ios: "4.0.0",
        macos: "0.7.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var ho = {
  "background-color": {
    type: "color",
    default: "#000000",
    doc: "The color with which the background will be drawn.",
    transition: true,
    requires: [
      {
        "!": "background-pattern"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "background-pattern": {
    type: "resolvedImage",
    transition: false,
    doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "background-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    doc: "The opacity at which the background will be drawn.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "0.10.0",
        android: "2.0.1",
        ios: "2.0.0",
        macos: "0.1.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var fo = {
  "sky-type": {
    type: "enum",
    values: {
      gradient: {
        doc: "Renders the sky with a gradient that can be configured with `sky-gradient-radius` and `sky-gradient`."
      },
      atmosphere: {
        doc: "Renders the sky with a simulated atmospheric scattering algorithm, the sun direction can be attached to the light position or explicitly set through `sky-atmosphere-sun`."
      }
    },
    default: "atmosphere",
    doc: "The type of the sky",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "sky-atmosphere-sun": {
    type: "array",
    value: "number",
    length: 2,
    units: "degrees",
    minimum: [
      0,
      0
    ],
    maximum: [
      360,
      180
    ],
    transition: false,
    doc: "Position of the sun center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the sun relative to 0\xB0 north, where degrees proceed clockwise. The polar angle indicates the height of the sun, where 0\xB0 is directly above, at zenith, and 90\xB0 at the horizon. When this property is ommitted, the sun center is directly inherited from the light position.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    requires: [
      {
        "sky-type": "atmosphere"
      }
    ],
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "sky-atmosphere-sun-intensity": {
    type: "number",
    requires: [
      {
        "sky-type": "atmosphere"
      }
    ],
    default: 10,
    minimum: 0,
    maximum: 100,
    transition: false,
    doc: "Intensity of the sun as a light source in the atmosphere (on a scale from 0 to a 100). Setting higher values will brighten up the sky.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    "property-type": "data-constant"
  },
  "sky-gradient-center": {
    type: "array",
    requires: [
      {
        "sky-type": "gradient"
      }
    ],
    value: "number",
    default: [
      0,
      0
    ],
    length: 2,
    units: "degrees",
    minimum: [
      0,
      0
    ],
    maximum: [
      360,
      180
    ],
    transition: false,
    doc: "Position of the gradient center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the gradient center relative to 0\xB0 north, where degrees proceed clockwise. The polar angle indicates the height of the gradient center, where 0\xB0 is directly above, at zenith, and 90\xB0 at the horizon.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "sky-gradient-radius": {
    type: "number",
    requires: [
      {
        "sky-type": "gradient"
      }
    ],
    default: 90,
    minimum: 0,
    maximum: 180,
    transition: false,
    doc: "The angular distance (measured in degrees) from `sky-gradient-center` up to which the gradient extends. A value of 180 causes the gradient to wrap around to the opposite direction from `sky-gradient-center`.",
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    expression: {
      interpolated: false,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "sky-gradient": {
    type: "color",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "sky-radial-progress"
      ],
      0.8,
      "#87ceeb",
      1,
      "white"
    ],
    doc: "Defines a radial color gradient with which to color the sky. The color values can be interpolated with an expression using `sky-radial-progress`. The range [0, 1] for the interpolant covers a radial distance (in degrees) of [0, `sky-gradient-radius`] centered at the position specified by `sky-gradient-center`.",
    transition: false,
    requires: [
      {
        "sky-type": "gradient"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      },
      "data-driven styling": {}
    },
    expression: {
      interpolated: true,
      parameters: [
        "sky-radial-progress"
      ]
    },
    "property-type": "color-ramp"
  },
  "sky-atmosphere-halo-color": {
    type: "color",
    default: "white",
    doc: "A color applied to the atmosphere sun halo. The alpha channel describes how strongly the sun halo is represented in an atmosphere sky layer.",
    transition: false,
    requires: [
      {
        "sky-type": "atmosphere"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    "property-type": "data-constant"
  },
  "sky-atmosphere-color": {
    type: "color",
    default: "white",
    doc: "A color used to tweak the main atmospheric scattering coefficients. Using white applies the default coefficients giving the natural blue color to the atmosphere. This color affects how heavily the corresponding wavelength is represented during scattering. The alpha channel describes the density of the atmosphere, with 1 maximum density and 0 no density.",
    transition: false,
    requires: [
      {
        "sky-type": "atmosphere"
      }
    ],
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    "property-type": "data-constant"
  },
  "sky-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    doc: "The opacity of the entire sky layer.",
    transition: true,
    "sdk-support": {
      "basic functionality": {
        js: "2.0.0",
        ios: "10.0.0",
        android: "10.0.0"
      }
    },
    expression: {
      interpolated: true,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
};
var mo = {
  duration: {
    type: "number",
    default: 300,
    minimum: 0,
    units: "milliseconds",
    doc: "Time allotted for transitions to complete."
  },
  delay: {
    type: "number",
    default: 0,
    minimum: 0,
    units: "milliseconds",
    doc: "Length of time before a transition begins."
  }
};
var yo = {
  "*": {
    type: "string",
    doc: "A name of a feature property to use as ID for feature state."
  }
};
var go = {
  $version: ki,
  $root: ji,
  sources: Ti,
  source: zi,
  source_vector: Ci,
  source_raster: Ei,
  source_raster_dem: Ai,
  source_geojson: _i,
  source_video: Si,
  source_image: Ii,
  layer: Ri,
  layout: Oi,
  layout_background: qi,
  layout_sky: Li,
  layout_fill: Ni,
  layout_circle: Di,
  layout_heatmap: Pi,
  "layout_fill-extrusion": {
    visibility: {
      type: "enum",
      values: {
        visible: {
          doc: "The layer is shown."
        },
        none: {
          doc: "The layer is not shown."
        }
      },
      default: "visible",
      doc: "Whether this layer is displayed.",
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      "property-type": "constant"
    },
    "fill-extrusion-edge-radius": {
      type: "number",
      private: true,
      default: 0,
      minimum: 0,
      maximum: 1,
      doc: "Radius of a fill extrusion edge in meters. If not zero, rounds extrusion edges for a smoother appearance.",
      "sdk-support": {
        "basic functionality": {
          js: "v2.10.0",
          android: "10.7.0",
          ios: "10.7.0"
        }
      },
      "property-type": "constant"
    }
  },
  layout_line: Mi,
  layout_symbol: $i,
  layout_raster: Fi,
  layout_hillshade: Ui,
  filter: Bi,
  filter_symbol: Wi,
  filter_fill: Ji,
  filter_line: Vi,
  filter_circle: Hi,
  "filter_fill-extrusion": {
    type: "boolean",
    doc: 'Expression which determines whether or not to display a Polygon. Fill-extrusion layer does NOT support dynamic filtering, meaning this expression can NOT use the `["pitch"]` and `["distance-from-center"]` expressions to reference the current state of the view.',
    default: false,
    transition: false,
    "property-type": "data-driven",
    expression: {
      interpolated: false,
      parameters: [
        "zoom",
        "feature"
      ]
    }
  },
  filter_heatmap: Gi,
  filter_operator: Zi,
  geometry_type: Xi,
  function: {
    expression: {
      type: "expression",
      doc: "An expression."
    },
    stops: {
      type: "array",
      doc: "An array of stops.",
      value: "function_stop"
    },
    base: {
      type: "number",
      default: 1,
      minimum: 0,
      doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
    },
    property: {
      type: "string",
      doc: "The name of a feature property to use as the function input.",
      default: "$zoom"
    },
    type: {
      type: "enum",
      values: {
        identity: {
          doc: "Return the input value as the output value."
        },
        exponential: {
          doc: "Generate an output by interpolating between stops just less than and just greater than the function input."
        },
        interval: {
          doc: "Return the output value of the stop just less than the function input."
        },
        categorical: {
          doc: "Return the output value of the stop equal to the function input."
        }
      },
      doc: "The interpolation strategy to use in function evaluation.",
      default: "exponential"
    },
    colorSpace: {
      type: "enum",
      values: {
        rgb: {
          doc: "Use the RGB color space to interpolate color values"
        },
        lab: {
          doc: "Use the LAB color space to interpolate color values."
        },
        hcl: {
          doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."
        }
      },
      doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",
      default: "rgb"
    },
    default: {
      type: "*",
      required: false,
      doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances."
    }
  },
  function_stop: Yi,
  expression: Ki,
  expression_name: Qi,
  fog: eo,
  light: to,
  projection: ro,
  terrain: no,
  paint: io,
  paint_fill: oo,
  "paint_fill-extrusion": {
    "fill-extrusion-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",
      transition: true,
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-color": {
      type: "color",
      default: "#000000",
      doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
      transition: true,
      requires: [
        {
          "!": "fill-extrusion-pattern"
        }
      ],
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        },
        "data-driven styling": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: true,
      units: "pixels",
      doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-translate-anchor": {
      type: "enum",
      values: {
        map: {
          doc: "The fill extrusion is translated relative to the map."
        },
        viewport: {
          doc: "The fill extrusion is translated relative to the viewport."
        }
      },
      doc: "Controls the frame of reference for `fill-extrusion-translate`.",
      default: "map",
      requires: [
        "fill-extrusion-translate"
      ],
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: false,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-pattern": {
      type: "resolvedImage",
      transition: false,
      doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        },
        "data-driven styling": {
          js: "0.49.0",
          android: "6.5.0",
          macos: "0.11.0",
          ios: "4.4.0"
        }
      },
      expression: {
        interpolated: false,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-height": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      doc: "The height with which to extrude this layer.",
      transition: true,
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        },
        "data-driven styling": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-base": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",
      transition: true,
      requires: [
        "fill-extrusion-height"
      ],
      "sdk-support": {
        "basic functionality": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        },
        "data-driven styling": {
          js: "0.27.0",
          android: "5.1.0",
          ios: "3.6.0",
          macos: "0.5.0"
        }
      },
      expression: {
        interpolated: true,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-vertical-gradient": {
      type: "boolean",
      default: true,
      doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",
      transition: false,
      "sdk-support": {
        "basic functionality": {
          js: "0.50.0",
          android: "7.0.0",
          ios: "4.7.0",
          macos: "0.13.0"
        }
      },
      expression: {
        interpolated: false,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-ambient-occlusion-intensity": {
      "property-type": "data-constant",
      type: "number",
      private: true,
      default: 0,
      minimum: 0,
      maximum: 1,
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      transition: true,
      doc: "Controls the intensity of shading near ground and concave angles between walls. Default value 0.0 disables ambient occlusion and values around 0.3 provide the most plausible results for buildings.",
      "sdk-support": {
        "basic functionality": {
          js: "2.10.0",
          android: "10.7.0",
          ios: "10.7.0"
        }
      }
    },
    "fill-extrusion-ambient-occlusion-radius": {
      "property-type": "data-constant",
      type: "number",
      private: true,
      default: 3,
      minimum: 0,
      expression: {
        interpolated: true,
        parameters: [
          "zoom"
        ]
      },
      transition: true,
      doc: "Shades area near ground and concave angles between walls where the radius defines only vertical impact. Default value 3.0 corresponds to height of one floor and brings the most plausible results for buildings.",
      requires: [
        "fill-extrusion-edge-radius"
      ],
      "sdk-support": {
        "basic functionality": {
          js: "2.10.0",
          android: "10.7.0",
          ios: "10.7.0"
        }
      }
    }
  },
  paint_line: ao,
  paint_circle: so,
  paint_heatmap: lo,
  paint_symbol: uo,
  paint_raster: co,
  paint_hillshade: po,
  paint_background: ho,
  paint_sky: fo,
  transition: mo,
  "property-type": {
    "data-driven": {
      type: "property-type",
      doc: "Property is interpolable and can be represented using a property expression."
    },
    "color-ramp": {
      type: "property-type",
      doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."
    },
    "data-constant": {
      type: "property-type",
      doc: "Property is interpolable but cannot be represented using a property expression."
    },
    constant: {
      type: "property-type",
      doc: "Property is constant across all zoom levels and property values."
    }
  },
  promoteId: yo
};
var Tt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var Zt = { exports: {} };
(function(r, e) {
  (function(t) {
    var n = e && !e.nodeType && e, i = r && !r.nodeType && r, o = typeof Tt == "object" && Tt;
    (o.global === o || o.window === o || o.self === o) && (t = o);
    var a, s = 2147483647, l2 = 36, u = 1, c = 26, p = 38, d = 700, m = 72, v = 128, _ = "-", j = /^xn--/, g = /[^\x20-\x7E]/, f = /[\x2E\u3002\uFF0E\uFF61]/g, b = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, T = l2 - u, h = Math.floor, k = String.fromCharCode, Y;
    function E(w) {
      throw RangeError(b[w]);
    }
    function P(w, x) {
      for (var S = w.length, R = []; S--; )
        R[S] = x(w[S]);
      return R;
    }
    function K(w, x) {
      var S = w.split("@"), R = "";
      S.length > 1 && (R = S[0] + "@", w = S[1]), w = w.replace(f, ".");
      var O = w.split("."), q = P(O, x).join(".");
      return R + q;
    }
    function te(w) {
      for (var x = [], S = 0, R = w.length, O, q; S < R; )
        O = w.charCodeAt(S++), O >= 55296 && O <= 56319 && S < R ? (q = w.charCodeAt(S++), (q & 64512) == 56320 ? x.push(((O & 1023) << 10) + (q & 1023) + 65536) : (x.push(O), S--)) : x.push(O);
      return x;
    }
    function $(w) {
      return P(w, function(x) {
        var S = "";
        return x > 65535 && (x -= 65536, S += k(x >>> 10 & 1023 | 55296), x = 56320 | x & 1023), S += k(x), S;
      }).join("");
    }
    function I(w) {
      return w - 48 < 10 ? w - 22 : w - 65 < 26 ? w - 65 : w - 97 < 26 ? w - 97 : l2;
    }
    function N(w, x) {
      return w + 22 + 75 * (w < 26) - ((x != 0) << 5);
    }
    function ie(w, x, S) {
      var R = 0;
      for (w = S ? h(w / d) : w >> 1, w += h(w / x); w > T * c >> 1; R += l2)
        w = h(w / T);
      return h(R + (T + 1) * w / (w + p));
    }
    function Z(w) {
      var x = [], S = w.length, R, O = 0, q = v, D = m, F, X, B, pe, G, oe, le, ve, ke;
      for (F = w.lastIndexOf(_), F < 0 && (F = 0), X = 0; X < F; ++X)
        w.charCodeAt(X) >= 128 && E("not-basic"), x.push(w.charCodeAt(X));
      for (B = F > 0 ? F + 1 : 0; B < S; ) {
        for (pe = O, G = 1, oe = l2; B >= S && E("invalid-input"), le = I(w.charCodeAt(B++)), (le >= l2 || le > h((s - O) / G)) && E("overflow"), O += le * G, ve = oe <= D ? u : oe >= D + c ? c : oe - D, !(le < ve); oe += l2)
          ke = l2 - ve, G > h(s / ke) && E("overflow"), G *= ke;
        R = x.length + 1, D = ie(O - pe, R, pe == 0), h(O / R) > s - q && E("overflow"), q += h(O / R), O %= R, x.splice(O++, 0, q);
      }
      return $(x);
    }
    function ze(w) {
      var x, S, R, O, q, D, F, X, B, pe, G, oe = [], le, ve, ke, jt;
      for (w = te(w), le = w.length, x = v, S = 0, q = m, D = 0; D < le; ++D)
        G = w[D], G < 128 && oe.push(k(G));
      for (R = O = oe.length, O && oe.push(_); R < le; ) {
        for (F = s, D = 0; D < le; ++D)
          G = w[D], G >= x && G < F && (F = G);
        for (ve = R + 1, F - x > h((s - S) / ve) && E("overflow"), S += (F - x) * ve, x = F, D = 0; D < le; ++D)
          if (G = w[D], G < x && ++S > s && E("overflow"), G == x) {
            for (X = S, B = l2; pe = B <= q ? u : B >= q + c ? c : B - q, !(X < pe); B += l2)
              jt = X - pe, ke = l2 - pe, oe.push(k(N(pe + jt % ke, 0))), X = h(jt / ke);
            oe.push(k(N(X, 0))), q = ie(S, ve, R == O), S = 0, ++R;
          }
        ++S, ++x;
      }
      return oe.join("");
    }
    function kt(w) {
      return K(w, function(x) {
        return j.test(x) ? Z(x.slice(4).toLowerCase()) : x;
      });
    }
    function H(w) {
      return K(w, function(x) {
        return g.test(x) ? "xn--" + ze(x) : x;
      });
    }
    if (a = {
      /**
      * A string representing the current Punycode.js version number.
      * @memberOf punycode
      * @type String
      */
      version: "1.3.2",
      /**
      * An object of methods to convert from JavaScript's internal character
      * representation (UCS-2) to Unicode code points, and back.
      * @see <https://mathiasbynens.be/notes/javascript-encoding>
      * @memberOf punycode
      * @type Object
      */
      ucs2: {
        decode: te,
        encode: $
      },
      decode: Z,
      encode: ze,
      toASCII: H,
      toUnicode: kt
    }, n && i)
      if (r.exports == n)
        i.exports = a;
      else
        for (Y in a)
          a.hasOwnProperty(Y) && (n[Y] = a[Y]);
    else
      t.punycode = a;
  })(Tt);
})(Zt, Zt.exports);
var bo = {
  isString: function(r) {
    return typeof r == "string";
  },
  isObject: function(r) {
    return typeof r == "object" && r !== null;
  },
  isNull: function(r) {
    return r === null;
  },
  isNullOrUndefined: function(r) {
    return r == null;
  }
};
var Ve = {};
function vo(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
var wo = function(r, e, t, n) {
  e = e || "&", t = t || "=";
  var i = {};
  if (typeof r != "string" || r.length === 0)
    return i;
  var o = /\+/g;
  r = r.split(e);
  var a = 1e3;
  n && typeof n.maxKeys == "number" && (a = n.maxKeys);
  var s = r.length;
  a > 0 && s > a && (s = a);
  for (var l2 = 0; l2 < s; ++l2) {
    var u = r[l2].replace(o, "%20"), c = u.indexOf(t), p, d, m, v;
    c >= 0 ? (p = u.substr(0, c), d = u.substr(c + 1)) : (p = u, d = ""), m = decodeURIComponent(p), v = decodeURIComponent(d), vo(i, m) ? Array.isArray(i[m]) ? i[m].push(v) : i[m] = [
      i[m],
      v
    ] : i[m] = v;
  }
  return i;
};
var $e = function(r) {
  switch (typeof r) {
    case "string":
      return r;
    case "boolean":
      return r ? "true" : "false";
    case "number":
      return isFinite(r) ? r : "";
    default:
      return "";
  }
};
var xo = function(r, e, t, n) {
  return e = e || "&", t = t || "=", r === null && (r = void 0), typeof r == "object" ? Object.keys(r).map(function(i) {
    var o = encodeURIComponent($e(i)) + t;
    return Array.isArray(r[i]) ? r[i].map(function(a) {
      return o + encodeURIComponent($e(a));
    }).join(e) : o + encodeURIComponent($e(r[i]));
  }).join(e) : n ? encodeURIComponent($e(n)) + t + encodeURIComponent($e(r)) : "";
};
Ve.decode = Ve.parse = wo;
Ve.encode = Ve.stringify = xo;
var ko = Zt.exports;
var he = bo;
function me() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var jo = /^([a-z0-9.+-]+:)/i;
var To = /:[0-9]*$/;
var zo = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var Co = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  "\n",
  "	"
];
var Eo = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(Co);
var Xt = ["'"].concat(Eo);
var Br = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(Xt);
var Wr = [
  "/",
  "?",
  "#"
];
var Ao = 255;
var Jr = /^[+a-z0-9A-Z_-]{0,63}$/;
var _o = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var So = {
  javascript: true,
  "javascript:": true
};
var Yt = {
  javascript: true,
  "javascript:": true
};
var Ie = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
var Kt = Ve;
function Io(r, e, t) {
  if (r && he.isObject(r) && r instanceof me)
    return r;
  var n = new me();
  return n.parse(r, e, t), n;
}
me.prototype.parse = function(r, e, t) {
  if (!he.isString(r))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof r);
  var n = r.indexOf("?"), i = n !== -1 && n < r.indexOf("#") ? "?" : "#", o = r.split(i), a = /\\/g;
  o[0] = o[0].replace(a, "/"), r = o.join(i);
  var s = r;
  if (s = s.trim(), !t && r.split("#").length === 1) {
    var l2 = zo.exec(s);
    if (l2)
      return this.path = s, this.href = s, this.pathname = l2[1], l2[2] ? (this.search = l2[2], e ? this.query = Kt.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this;
  }
  var u = jo.exec(s);
  if (u) {
    u = u[0];
    var c = u.toLowerCase();
    this.protocol = c, s = s.substr(u.length);
  }
  if (t || u || s.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var p = s.substr(0, 2) === "//";
    p && !(u && Yt[u]) && (s = s.substr(2), this.slashes = true);
  }
  if (!Yt[u] && (p || u && !Ie[u])) {
    for (var d = -1, m = 0; m < Wr.length; m++) {
      var v = s.indexOf(Wr[m]);
      v !== -1 && (d === -1 || v < d) && (d = v);
    }
    var _, j;
    d === -1 ? j = s.lastIndexOf("@") : j = s.lastIndexOf("@", d), j !== -1 && (_ = s.slice(0, j), s = s.slice(j + 1), this.auth = decodeURIComponent(_)), d = -1;
    for (var m = 0; m < Br.length; m++) {
      var v = s.indexOf(Br[m]);
      v !== -1 && (d === -1 || v < d) && (d = v);
    }
    d === -1 && (d = s.length), this.host = s.slice(0, d), s = s.slice(d), this.parseHost(), this.hostname = this.hostname || "";
    var g = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!g)
      for (var f = this.hostname.split(/\./), m = 0, b = f.length; m < b; m++) {
        var T = f[m];
        if (T && !T.match(Jr)) {
          for (var h = "", k = 0, Y = T.length; k < Y; k++)
            T.charCodeAt(k) > 127 ? h += "x" : h += T[k];
          if (!h.match(Jr)) {
            var E = f.slice(0, m), P = f.slice(m + 1), K = T.match(_o);
            K && (E.push(K[1]), P.unshift(K[2])), P.length && (s = "/" + P.join(".") + s), this.hostname = E.join(".");
            break;
          }
        }
      }
    this.hostname.length > Ao ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), g || (this.hostname = ko.toASCII(this.hostname));
    var te = this.port ? ":" + this.port : "", $ = this.hostname || "";
    this.host = $ + te, this.href += this.host, g && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s[0] !== "/" && (s = "/" + s));
  }
  if (!So[c])
    for (var m = 0, b = Xt.length; m < b; m++) {
      var I = Xt[m];
      if (s.indexOf(I) !== -1) {
        var N = encodeURIComponent(I);
        N === I && (N = escape(I)), s = s.split(I).join(N);
      }
    }
  var ie = s.indexOf("#");
  ie !== -1 && (this.hash = s.substr(ie), s = s.slice(0, ie));
  var Z = s.indexOf("?");
  if (Z !== -1 ? (this.search = s.substr(Z), this.query = s.substr(Z + 1), e && (this.query = Kt.parse(this.query)), s = s.slice(0, Z)) : e && (this.search = "", this.query = {}), s && (this.pathname = s), Ie[c] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var te = this.pathname || "", ze = this.search || "";
    this.path = te + ze;
  }
  return this.href = this.format(), this;
};
me.prototype.format = function() {
  var r = this.auth || "";
  r && (r = encodeURIComponent(r), r = r.replace(/%3A/i, ":"), r += "@");
  var e = this.protocol || "", t = this.pathname || "", n = this.hash || "", i = false, o = "";
  this.host ? i = r + this.host : this.hostname && (i = r + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && he.isObject(this.query) && Object.keys(this.query).length && (o = Kt.stringify(this.query));
  var a = this.search || o && "?" + o || "";
  return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || Ie[e]) && i !== false ? (i = "//" + (i || ""), t && t.charAt(0) !== "/" && (t = "/" + t)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a && a.charAt(0) !== "?" && (a = "?" + a), t = t.replace(/[?#]/g, function(s) {
    return encodeURIComponent(s);
  }), a = a.replace("#", "%23"), e + i + t + a + n;
};
me.prototype.resolve = function(r) {
  return this.resolveObject(Io(r, false, true)).format();
};
me.prototype.resolveObject = function(r) {
  if (he.isString(r)) {
    var e = new me();
    e.parse(r, false, true), r = e;
  }
  for (var t = new me(), n = Object.keys(this), i = 0; i < n.length; i++) {
    var o = n[i];
    t[o] = this[o];
  }
  if (t.hash = r.hash, r.href === "")
    return t.href = t.format(), t;
  if (r.slashes && !r.protocol) {
    for (var a = Object.keys(r), s = 0; s < a.length; s++) {
      var l2 = a[s];
      l2 !== "protocol" && (t[l2] = r[l2]);
    }
    return Ie[t.protocol] && t.hostname && !t.pathname && (t.path = t.pathname = "/"), t.href = t.format(), t;
  }
  if (r.protocol && r.protocol !== t.protocol) {
    if (!Ie[r.protocol]) {
      for (var u = Object.keys(r), c = 0; c < u.length; c++) {
        var p = u[c];
        t[p] = r[p];
      }
      return t.href = t.format(), t;
    }
    if (t.protocol = r.protocol, !r.host && !Yt[r.protocol]) {
      for (var b = (r.pathname || "").split("/"); b.length && !(r.host = b.shift()); )
        ;
      r.host || (r.host = ""), r.hostname || (r.hostname = ""), b[0] !== "" && b.unshift(""), b.length < 2 && b.unshift(""), t.pathname = b.join("/");
    } else
      t.pathname = r.pathname;
    if (t.search = r.search, t.query = r.query, t.host = r.host || "", t.auth = r.auth, t.hostname = r.hostname || r.host, t.port = r.port, t.pathname || t.search) {
      var d = t.pathname || "", m = t.search || "";
      t.path = d + m;
    }
    return t.slashes = t.slashes || r.slashes, t.href = t.format(), t;
  }
  var v = t.pathname && t.pathname.charAt(0) === "/", _ = r.host || r.pathname && r.pathname.charAt(0) === "/", j = _ || v || t.host && r.pathname, g = j, f = t.pathname && t.pathname.split("/") || [], b = r.pathname && r.pathname.split("/") || [], T = t.protocol && !Ie[t.protocol];
  if (T && (t.hostname = "", t.port = null, t.host && (f[0] === "" ? f[0] = t.host : f.unshift(t.host)), t.host = "", r.protocol && (r.hostname = null, r.port = null, r.host && (b[0] === "" ? b[0] = r.host : b.unshift(r.host)), r.host = null), j = j && (b[0] === "" || f[0] === "")), _)
    t.host = r.host || r.host === "" ? r.host : t.host, t.hostname = r.hostname || r.hostname === "" ? r.hostname : t.hostname, t.search = r.search, t.query = r.query, f = b;
  else if (b.length)
    f || (f = []), f.pop(), f = f.concat(b), t.search = r.search, t.query = r.query;
  else if (!he.isNullOrUndefined(r.search)) {
    if (T) {
      t.hostname = t.host = f.shift();
      var h = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : false;
      h && (t.auth = h.shift(), t.host = t.hostname = h.shift());
    }
    return t.search = r.search, t.query = r.query, (!he.isNull(t.pathname) || !he.isNull(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t;
  }
  if (!f.length)
    return t.pathname = null, t.search ? t.path = "/" + t.search : t.path = null, t.href = t.format(), t;
  for (var k = f.slice(-1)[0], Y = (t.host || r.host || f.length > 1) && (k === "." || k === "..") || k === "", E = 0, P = f.length; P >= 0; P--)
    k = f[P], k === "." ? f.splice(P, 1) : k === ".." ? (f.splice(P, 1), E++) : E && (f.splice(P, 1), E--);
  if (!j && !g)
    for (; E--; E)
      f.unshift("..");
  j && f[0] !== "" && (!f[0] || f[0].charAt(0) !== "/") && f.unshift(""), Y && f.join("/").substr(-1) !== "/" && f.push("");
  var K = f[0] === "" || f[0] && f[0].charAt(0) === "/";
  if (T) {
    t.hostname = t.host = K ? "" : f.length ? f.shift() : "";
    var h = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : false;
    h && (t.auth = h.shift(), t.host = t.hostname = h.shift());
  }
  return j = j || t.host && f.length, j && !K && f.unshift(""), f.length ? t.pathname = f.join("/") : (t.pathname = null, t.path = null), (!he.isNull(t.pathname) || !he.isNull(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = r.auth || t.auth, t.slashes = t.slashes || r.slashes, t.href = t.format(), t;
};
me.prototype.parseHost = function() {
  var r = this.host, e = To.exec(r);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), r = r.substr(0, r.length - e.length)), r && (this.hostname = r);
};
function Cn(r, ...e) {
  for (const t of e)
    for (const n in t)
      r[n] = t[n];
  return r;
}
var Ro = class extends Error {
  constructor(e, t) {
    super(t), this.message = t, this.key = e;
  }
};
var de = Ro;
var ar = class _ar {
  constructor(e, t = []) {
    this.parent = e, this.bindings = {};
    for (const [n, i] of t)
      this.bindings[n] = i;
  }
  concat(e) {
    return new _ar(this, e);
  }
  get(e) {
    if (this.bindings[e])
      return this.bindings[e];
    if (this.parent)
      return this.parent.get(e);
    throw new Error("".concat(e, " not found in scope."));
  }
  has(e) {
    return this.bindings[e] ? true : this.parent ? this.parent.has(e) : false;
  }
};
var Oo = ar;
var ct = { kind: "null" };
var y = { kind: "number" };
var A = { kind: "string" };
var z = { kind: "boolean" };
var ye = { kind: "color" };
var Re = { kind: "object" };
var C = { kind: "value" };
var qo = { kind: "error" };
var dt = { kind: "collator" };
var pt = { kind: "formatted" };
var Xe = { kind: "resolvedImage" };
function se(r, e) {
  return {
    kind: "array",
    itemType: r,
    N: e
  };
}
function L(r) {
  if (r.kind === "array") {
    const e = L(r.itemType);
    return typeof r.N == "number" ? "array<".concat(e, ", ").concat(r.N, ">") : r.itemType.kind === "value" ? "array" : "array<".concat(e, ">");
  } else
    return r.kind;
}
var Lo = [
  ct,
  y,
  A,
  z,
  ye,
  pt,
  Re,
  se(C),
  Xe
];
function He(r, e) {
  if (e.kind === "error")
    return null;
  if (r.kind === "array") {
    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !He(r.itemType, e.itemType)) && (typeof r.N != "number" || r.N === e.N))
      return null;
  } else {
    if (r.kind === e.kind)
      return null;
    if (r.kind === "value") {
      for (const t of Lo)
        if (!He(t, e))
          return null;
    }
  }
  return "Expected ".concat(L(r), " but found ").concat(L(e), " instead.");
}
function sr(r, e) {
  return e.some((t) => t.kind === r.kind);
}
function Ge(r, e) {
  return e.some((t) => t === "null" ? r === null : t === "array" ? Array.isArray(r) : t === "object" ? r && !Array.isArray(r) && typeof r == "object" : t === typeof r);
}
var No = {};
var En;
var Vr = {
  transparent: [
    0,
    0,
    0,
    0
  ],
  aliceblue: [
    240,
    248,
    255,
    1
  ],
  antiquewhite: [
    250,
    235,
    215,
    1
  ],
  aqua: [
    0,
    255,
    255,
    1
  ],
  aquamarine: [
    127,
    255,
    212,
    1
  ],
  azure: [
    240,
    255,
    255,
    1
  ],
  beige: [
    245,
    245,
    220,
    1
  ],
  bisque: [
    255,
    228,
    196,
    1
  ],
  black: [
    0,
    0,
    0,
    1
  ],
  blanchedalmond: [
    255,
    235,
    205,
    1
  ],
  blue: [
    0,
    0,
    255,
    1
  ],
  blueviolet: [
    138,
    43,
    226,
    1
  ],
  brown: [
    165,
    42,
    42,
    1
  ],
  burlywood: [
    222,
    184,
    135,
    1
  ],
  cadetblue: [
    95,
    158,
    160,
    1
  ],
  chartreuse: [
    127,
    255,
    0,
    1
  ],
  chocolate: [
    210,
    105,
    30,
    1
  ],
  coral: [
    255,
    127,
    80,
    1
  ],
  cornflowerblue: [
    100,
    149,
    237,
    1
  ],
  cornsilk: [
    255,
    248,
    220,
    1
  ],
  crimson: [
    220,
    20,
    60,
    1
  ],
  cyan: [
    0,
    255,
    255,
    1
  ],
  darkblue: [
    0,
    0,
    139,
    1
  ],
  darkcyan: [
    0,
    139,
    139,
    1
  ],
  darkgoldenrod: [
    184,
    134,
    11,
    1
  ],
  darkgray: [
    169,
    169,
    169,
    1
  ],
  darkgreen: [
    0,
    100,
    0,
    1
  ],
  darkgrey: [
    169,
    169,
    169,
    1
  ],
  darkkhaki: [
    189,
    183,
    107,
    1
  ],
  darkmagenta: [
    139,
    0,
    139,
    1
  ],
  darkolivegreen: [
    85,
    107,
    47,
    1
  ],
  darkorange: [
    255,
    140,
    0,
    1
  ],
  darkorchid: [
    153,
    50,
    204,
    1
  ],
  darkred: [
    139,
    0,
    0,
    1
  ],
  darksalmon: [
    233,
    150,
    122,
    1
  ],
  darkseagreen: [
    143,
    188,
    143,
    1
  ],
  darkslateblue: [
    72,
    61,
    139,
    1
  ],
  darkslategray: [
    47,
    79,
    79,
    1
  ],
  darkslategrey: [
    47,
    79,
    79,
    1
  ],
  darkturquoise: [
    0,
    206,
    209,
    1
  ],
  darkviolet: [
    148,
    0,
    211,
    1
  ],
  deeppink: [
    255,
    20,
    147,
    1
  ],
  deepskyblue: [
    0,
    191,
    255,
    1
  ],
  dimgray: [
    105,
    105,
    105,
    1
  ],
  dimgrey: [
    105,
    105,
    105,
    1
  ],
  dodgerblue: [
    30,
    144,
    255,
    1
  ],
  firebrick: [
    178,
    34,
    34,
    1
  ],
  floralwhite: [
    255,
    250,
    240,
    1
  ],
  forestgreen: [
    34,
    139,
    34,
    1
  ],
  fuchsia: [
    255,
    0,
    255,
    1
  ],
  gainsboro: [
    220,
    220,
    220,
    1
  ],
  ghostwhite: [
    248,
    248,
    255,
    1
  ],
  gold: [
    255,
    215,
    0,
    1
  ],
  goldenrod: [
    218,
    165,
    32,
    1
  ],
  gray: [
    128,
    128,
    128,
    1
  ],
  green: [
    0,
    128,
    0,
    1
  ],
  greenyellow: [
    173,
    255,
    47,
    1
  ],
  grey: [
    128,
    128,
    128,
    1
  ],
  honeydew: [
    240,
    255,
    240,
    1
  ],
  hotpink: [
    255,
    105,
    180,
    1
  ],
  indianred: [
    205,
    92,
    92,
    1
  ],
  indigo: [
    75,
    0,
    130,
    1
  ],
  ivory: [
    255,
    255,
    240,
    1
  ],
  khaki: [
    240,
    230,
    140,
    1
  ],
  lavender: [
    230,
    230,
    250,
    1
  ],
  lavenderblush: [
    255,
    240,
    245,
    1
  ],
  lawngreen: [
    124,
    252,
    0,
    1
  ],
  lemonchiffon: [
    255,
    250,
    205,
    1
  ],
  lightblue: [
    173,
    216,
    230,
    1
  ],
  lightcoral: [
    240,
    128,
    128,
    1
  ],
  lightcyan: [
    224,
    255,
    255,
    1
  ],
  lightgoldenrodyellow: [
    250,
    250,
    210,
    1
  ],
  lightgray: [
    211,
    211,
    211,
    1
  ],
  lightgreen: [
    144,
    238,
    144,
    1
  ],
  lightgrey: [
    211,
    211,
    211,
    1
  ],
  lightpink: [
    255,
    182,
    193,
    1
  ],
  lightsalmon: [
    255,
    160,
    122,
    1
  ],
  lightseagreen: [
    32,
    178,
    170,
    1
  ],
  lightskyblue: [
    135,
    206,
    250,
    1
  ],
  lightslategray: [
    119,
    136,
    153,
    1
  ],
  lightslategrey: [
    119,
    136,
    153,
    1
  ],
  lightsteelblue: [
    176,
    196,
    222,
    1
  ],
  lightyellow: [
    255,
    255,
    224,
    1
  ],
  lime: [
    0,
    255,
    0,
    1
  ],
  limegreen: [
    50,
    205,
    50,
    1
  ],
  linen: [
    250,
    240,
    230,
    1
  ],
  magenta: [
    255,
    0,
    255,
    1
  ],
  maroon: [
    128,
    0,
    0,
    1
  ],
  mediumaquamarine: [
    102,
    205,
    170,
    1
  ],
  mediumblue: [
    0,
    0,
    205,
    1
  ],
  mediumorchid: [
    186,
    85,
    211,
    1
  ],
  mediumpurple: [
    147,
    112,
    219,
    1
  ],
  mediumseagreen: [
    60,
    179,
    113,
    1
  ],
  mediumslateblue: [
    123,
    104,
    238,
    1
  ],
  mediumspringgreen: [
    0,
    250,
    154,
    1
  ],
  mediumturquoise: [
    72,
    209,
    204,
    1
  ],
  mediumvioletred: [
    199,
    21,
    133,
    1
  ],
  midnightblue: [
    25,
    25,
    112,
    1
  ],
  mintcream: [
    245,
    255,
    250,
    1
  ],
  mistyrose: [
    255,
    228,
    225,
    1
  ],
  moccasin: [
    255,
    228,
    181,
    1
  ],
  navajowhite: [
    255,
    222,
    173,
    1
  ],
  navy: [
    0,
    0,
    128,
    1
  ],
  oldlace: [
    253,
    245,
    230,
    1
  ],
  olive: [
    128,
    128,
    0,
    1
  ],
  olivedrab: [
    107,
    142,
    35,
    1
  ],
  orange: [
    255,
    165,
    0,
    1
  ],
  orangered: [
    255,
    69,
    0,
    1
  ],
  orchid: [
    218,
    112,
    214,
    1
  ],
  palegoldenrod: [
    238,
    232,
    170,
    1
  ],
  palegreen: [
    152,
    251,
    152,
    1
  ],
  paleturquoise: [
    175,
    238,
    238,
    1
  ],
  palevioletred: [
    219,
    112,
    147,
    1
  ],
  papayawhip: [
    255,
    239,
    213,
    1
  ],
  peachpuff: [
    255,
    218,
    185,
    1
  ],
  peru: [
    205,
    133,
    63,
    1
  ],
  pink: [
    255,
    192,
    203,
    1
  ],
  plum: [
    221,
    160,
    221,
    1
  ],
  powderblue: [
    176,
    224,
    230,
    1
  ],
  purple: [
    128,
    0,
    128,
    1
  ],
  rebeccapurple: [
    102,
    51,
    153,
    1
  ],
  red: [
    255,
    0,
    0,
    1
  ],
  rosybrown: [
    188,
    143,
    143,
    1
  ],
  royalblue: [
    65,
    105,
    225,
    1
  ],
  saddlebrown: [
    139,
    69,
    19,
    1
  ],
  salmon: [
    250,
    128,
    114,
    1
  ],
  sandybrown: [
    244,
    164,
    96,
    1
  ],
  seagreen: [
    46,
    139,
    87,
    1
  ],
  seashell: [
    255,
    245,
    238,
    1
  ],
  sienna: [
    160,
    82,
    45,
    1
  ],
  silver: [
    192,
    192,
    192,
    1
  ],
  skyblue: [
    135,
    206,
    235,
    1
  ],
  slateblue: [
    106,
    90,
    205,
    1
  ],
  slategray: [
    112,
    128,
    144,
    1
  ],
  slategrey: [
    112,
    128,
    144,
    1
  ],
  snow: [
    255,
    250,
    250,
    1
  ],
  springgreen: [
    0,
    255,
    127,
    1
  ],
  steelblue: [
    70,
    130,
    180,
    1
  ],
  tan: [
    210,
    180,
    140,
    1
  ],
  teal: [
    0,
    128,
    128,
    1
  ],
  thistle: [
    216,
    191,
    216,
    1
  ],
  tomato: [
    255,
    99,
    71,
    1
  ],
  turquoise: [
    64,
    224,
    208,
    1
  ],
  violet: [
    238,
    130,
    238,
    1
  ],
  wheat: [
    245,
    222,
    179,
    1
  ],
  white: [
    255,
    255,
    255,
    1
  ],
  whitesmoke: [
    245,
    245,
    245,
    1
  ],
  yellow: [
    255,
    255,
    0,
    1
  ],
  yellowgreen: [
    154,
    205,
    50,
    1
  ]
};
function Be(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 255 ? 255 : r;
}
function Hr(r) {
  return r < 0 ? 0 : r > 1 ? 1 : r;
}
function zt(r) {
  return r[r.length - 1] === "%" ? Be(parseFloat(r) / 100 * 255) : Be(parseInt(r));
}
function Ke(r) {
  return r[r.length - 1] === "%" ? Hr(parseFloat(r) / 100) : Hr(parseFloat(r));
}
function Ct(r, e, t) {
  return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? r + (e - r) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? r + (e - r) * (2 / 3 - t) * 6 : r;
}
function Do(r) {
  var e = r.replace(/ /g, "").toLowerCase();
  if (e in Vr)
    return Vr[e].slice();
  if (e[0] === "#") {
    if (e.length === 4) {
      var t = parseInt(e.substr(1), 16);
      return t >= 0 && t <= 4095 ? [
        (t & 3840) >> 4 | (t & 3840) >> 8,
        t & 240 | (t & 240) >> 4,
        t & 15 | (t & 15) << 4,
        1
      ] : null;
    } else if (e.length === 7) {
      var t = parseInt(e.substr(1), 16);
      return t >= 0 && t <= 16777215 ? [
        (t & 16711680) >> 16,
        (t & 65280) >> 8,
        t & 255,
        1
      ] : null;
    }
    return null;
  }
  var n = e.indexOf("("), i = e.indexOf(")");
  if (n !== -1 && i + 1 === e.length) {
    var o = e.substr(0, n), a = e.substr(n + 1, i - (n + 1)).split(","), s = 1;
    switch (o) {
      case "rgba":
        if (a.length !== 4)
          return null;
        s = Ke(a.pop());
      case "rgb":
        return a.length !== 3 ? null : [
          zt(a[0]),
          zt(a[1]),
          zt(a[2]),
          s
        ];
      case "hsla":
        if (a.length !== 4)
          return null;
        s = Ke(a.pop());
      case "hsl":
        if (a.length !== 3)
          return null;
        var l2 = (parseFloat(a[0]) % 360 + 360) % 360 / 360, u = Ke(a[1]), c = Ke(a[2]), p = c <= 0.5 ? c * (u + 1) : c + u - c * u, d = c * 2 - p;
        return [
          Be(Ct(d, p, l2 + 1 / 3) * 255),
          Be(Ct(d, p, l2) * 255),
          Be(Ct(d, p, l2 - 1 / 3) * 255),
          s
        ];
      default:
        return null;
    }
  }
  return null;
}
try {
  En = No.parseCSSColor = Do;
} catch (e) {
}
var Q = class _Q {
  constructor(e, t, n, i = 1) {
    this.r = e, this.g = t, this.b = n, this.a = i;
  }
  /**
   * Parses valid CSS color strings and returns a `Color` instance.
   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
   */
  static parse(e) {
    if (!e)
      return;
    if (e instanceof _Q)
      return e;
    if (typeof e != "string")
      return;
    const t = En(e);
    if (t)
      return new _Q(t[0] / 255 * t[3], t[1] / 255 * t[3], t[2] / 255 * t[3], t[3]);
  }
  /**
   * Returns an RGBA string representing the color value.
   *
   * @returns An RGBA string.
   * @example
   * var purple = new Color.parse('purple');
   * purple.toString; // = "rgba(128,0,128,1)"
   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
   * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
   */
  toString() {
    const [e, t, n, i] = this.toArray();
    return "rgba(".concat(Math.round(e), ",").concat(Math.round(t), ",").concat(Math.round(n), ",").concat(i, ")");
  }
  /**
   * Returns an RGBA array of values representing the color, unpremultiplied by A.
   *
   * @returns An array of RGBA color values in the range [0, 255].
   */
  toArray() {
    const { r: e, g: t, b: n, a: i } = this;
    return i === 0 ? [
      0,
      0,
      0,
      0
    ] : [
      e * 255 / i,
      t * 255 / i,
      n * 255 / i,
      i
    ];
  }
  /**
   * Returns a RGBA array of float values representing the color, unpremultiplied by A.
   *
   * @returns An array of RGBA color values in the range [0, 1].
   */
  toArray01() {
    const { r: e, g: t, b: n, a: i } = this;
    return i === 0 ? [
      0,
      0,
      0,
      0
    ] : [
      e / i,
      t / i,
      n / i,
      i
    ];
  }
  /**
   * Returns an RGBA array of values representing the color, premultiplied by A.
   *
   * @returns An array of RGBA color values in the range [0, 1].
   */
  toArray01PremultipliedAlpha() {
    const { r: e, g: t, b: n, a: i } = this;
    return [
      e,
      t,
      n,
      i
    ];
  }
};
Q.black = new Q(0, 0, 0, 1);
Q.white = new Q(1, 1, 1, 1);
Q.transparent = new Q(0, 0, 0, 0);
Q.red = new Q(1, 0, 0, 1);
Q.blue = new Q(0, 0, 1, 1);
var W = Q;
var lr = class {
  constructor(e, t, n) {
    e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
      sensitivity: this.sensitivity,
      usage: "search"
    });
  }
  compare(e, t) {
    return this.collator.compare(e, t);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
};
var Qt = class {
  constructor(e, t, n, i, o) {
    this.text = e.normalize ? e.normalize() : e, this.image = t, this.scale = n, this.fontStack = i, this.textColor = o;
  }
};
var ce = class _ce {
  constructor(e) {
    this.sections = e;
  }
  static fromString(e) {
    return new _ce([new Qt(e, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? true : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
  }
  static factory(e) {
    return e instanceof _ce ? e : _ce.fromString(e);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
  }
  serialize() {
    const e = ["format"];
    for (const t of this.sections) {
      if (t.image) {
        e.push([
          "image",
          t.image.name
        ]);
        continue;
      }
      e.push(t.text);
      const n = {};
      t.fontStack && (n["text-font"] = [
        "literal",
        t.fontStack.split(",")
      ]), t.scale && (n["font-scale"] = t.scale), t.textColor && (n["text-color"] = ["rgba"].concat(t.textColor.toArray())), e.push(n);
    }
    return e;
  }
};
var be = class _be {
  constructor(e) {
    this.name = e.name, this.available = e.available;
  }
  toString() {
    return this.name;
  }
  static fromString(e) {
    return e ? new _be({
      name: e,
      available: false
    }) : null;
  }
  serialize() {
    return [
      "image",
      this.name
    ];
  }
};
function An(r, e, t, n) {
  return typeof r == "number" && r >= 0 && r <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 ? typeof n > "u" || typeof n == "number" && n >= 0 && n <= 1 ? null : "Invalid rgba value [".concat([
    r,
    e,
    t,
    n
  ].join(", "), "]: 'a' must be between 0 and 1.") : "Invalid rgba value [".concat((typeof n == "number" ? [
    r,
    e,
    t,
    n
  ] : [
    r,
    e,
    t
  ]).join(", "), "]: 'r', 'g', and 'b' must be between 0 and 255.");
}
function rt(r) {
  if (r === null)
    return true;
  if (typeof r == "string")
    return true;
  if (typeof r == "boolean")
    return true;
  if (typeof r == "number")
    return true;
  if (r instanceof W)
    return true;
  if (r instanceof lr)
    return true;
  if (r instanceof ce)
    return true;
  if (r instanceof be)
    return true;
  if (Array.isArray(r)) {
    for (const e of r)
      if (!rt(e))
        return false;
    return true;
  } else if (typeof r == "object") {
    for (const e in r)
      if (!rt(r[e]))
        return false;
    return true;
  } else
    return false;
}
function M(r) {
  if (r === null)
    return ct;
  if (typeof r == "string")
    return A;
  if (typeof r == "boolean")
    return z;
  if (typeof r == "number")
    return y;
  if (r instanceof W)
    return ye;
  if (r instanceof lr)
    return dt;
  if (r instanceof ce)
    return pt;
  if (r instanceof be)
    return Xe;
  if (Array.isArray(r)) {
    const e = r.length;
    let t;
    for (const n of r) {
      const i = M(n);
      if (!t)
        t = i;
      else {
        if (t === i)
          continue;
        t = C;
        break;
      }
    }
    return se(t || C, e);
  } else
    return Re;
}
function We(r) {
  const e = typeof r;
  return r === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r) : r instanceof W || r instanceof ce || r instanceof be ? r.toString() : JSON.stringify(r);
}
var ur = class _ur {
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("'literal' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
    if (!rt(e[1]))
      return t.error("invalid value");
    const n = e[1];
    let i = M(n);
    const o = t.expectedType;
    return i.kind === "array" && i.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (i = o), new _ur(i, n);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
  serialize() {
    return this.type.kind === "array" || this.type.kind === "object" ? [
      "literal",
      this.value
    ] : this.value instanceof W ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ce ? this.value.serialize() : this.value;
  }
};
var nt = ur;
var Po = class {
  constructor(e) {
    this.name = "ExpressionEvaluationError", this.message = e;
  }
  toJSON() {
    return this.message;
  }
};
var J = Po;
var Et = {
  string: A,
  number: y,
  boolean: z,
  object: Re
};
var cr = class _cr {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    let n = 1, i;
    const o = e[0];
    if (o === "array") {
      let s;
      if (e.length > 2) {
        const u = e[1];
        if (typeof u != "string" || !(u in Et) || u === "object")
          return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
        s = Et[u], n++;
      } else
        s = C;
      let l2;
      if (e.length > 3) {
        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
          return t.error('The length argument to "array" must be a positive integer literal', 2);
        l2 = e[2], n++;
      }
      i = se(s, l2);
    } else
      i = Et[o];
    const a = [];
    for (; n < e.length; n++) {
      const s = t.parse(e[n], n, C);
      if (!s)
        return null;
      a.push(s);
    }
    return new _cr(i, a);
  }
  evaluate(e) {
    for (let t = 0; t < this.args.length; t++) {
      const n = this.args[t].evaluate(e);
      if (He(this.type, M(n))) {
        if (t === this.args.length - 1)
          throw new J("Expected value to be of type ".concat(L(this.type), ", but found ").concat(L(M(n)), " instead."));
      } else
        return n;
    }
    return null;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
  serialize() {
    const e = this.type, t = [e.kind];
    if (e.kind === "array") {
      const n = e.itemType;
      if (n.kind === "string" || n.kind === "number" || n.kind === "boolean") {
        t.push(n.kind);
        const i = e.N;
        (typeof i == "number" || this.args.length > 1) && t.push(i);
      }
    }
    return t.concat(this.args.map((n) => n.serialize()));
  }
};
var fe = cr;
var ht = class _ht {
  constructor(e) {
    this.type = pt, this.sections = e;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    const n = e[1];
    if (!Array.isArray(n) && typeof n == "object")
      return t.error("First argument must be an image or text section.");
    const i = [];
    let o = false;
    for (let a = 1; a <= e.length - 1; ++a) {
      const s = e[a];
      if (o && typeof s == "object" && !Array.isArray(s)) {
        o = false;
        let l2 = null;
        if (s["font-scale"] && (l2 = t.parse(s["font-scale"], 1, y), !l2))
          return null;
        let u = null;
        if (s["text-font"] && (u = t.parse(s["text-font"], 1, se(A)), !u))
          return null;
        let c = null;
        if (s["text-color"] && (c = t.parse(s["text-color"], 1, ye), !c))
          return null;
        const p = i[i.length - 1];
        p.scale = l2, p.font = u, p.textColor = c;
      } else {
        const l2 = t.parse(e[a], 1, C);
        if (!l2)
          return null;
        const u = l2.type.kind;
        if (u !== "string" && u !== "value" && u !== "null" && u !== "resolvedImage")
          return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        o = true, i.push({
          content: l2,
          scale: null,
          font: null,
          textColor: null
        });
      }
    }
    return new _ht(i);
  }
  evaluate(e) {
    const t = (n) => {
      const i = n.content.evaluate(e);
      return M(i) === Xe ? new Qt("", i, null, null, null) : new Qt(We(i), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null);
    };
    return new ce(this.sections.map(t));
  }
  eachChild(e) {
    for (const t of this.sections)
      e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    const e = ["format"];
    for (const t of this.sections) {
      e.push(t.content.serialize());
      const n = {};
      t.scale && (n["font-scale"] = t.scale.serialize()), t.font && (n["text-font"] = t.font.serialize()), t.textColor && (n["text-color"] = t.textColor.serialize()), e.push(n);
    }
    return e;
  }
};
var ft = class _ft {
  constructor(e) {
    this.type = Xe, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected two arguments.");
    const n = t.parse(e[1], 1, A);
    return n ? new _ft(n) : t.error("No image name provided.");
  }
  evaluate(e) {
    const t = this.input.evaluate(e), n = be.fromString(t);
    return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return [
      "image",
      this.input.serialize()
    ];
  }
};
var Mo = {
  "to-boolean": z,
  "to-color": ye,
  "to-number": y,
  "to-string": A
};
var dr = class _dr {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    const n = e[0];
    if ((n === "to-boolean" || n === "to-string") && e.length !== 2)
      return t.error("Expected one argument.");
    const i = Mo[n], o = [];
    for (let a = 1; a < e.length; a++) {
      const s = t.parse(e[a], a, C);
      if (!s)
        return null;
      o.push(s);
    }
    return new _dr(i, o);
  }
  evaluate(e) {
    if (this.type.kind === "boolean")
      return !!this.args[0].evaluate(e);
    if (this.type.kind === "color") {
      let t, n;
      for (const i of this.args) {
        if (t = i.evaluate(e), n = null, t instanceof W)
          return t;
        if (typeof t == "string") {
          const o = e.parseColor(t);
          if (o)
            return o;
        } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = "Invalid rbga value ".concat(JSON.stringify(t), ": expected an array containing either three or four numeric values.") : n = An(t[0], t[1], t[2], t[3]), !n))
          return new W(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
      }
      throw new J(n || "Could not parse color from value '".concat(typeof t == "string" ? t : String(JSON.stringify(t)), "'"));
    } else if (this.type.kind === "number") {
      let t = null;
      for (const n of this.args) {
        if (t = n.evaluate(e), t === null)
          return 0;
        const i = Number(t);
        if (!isNaN(i))
          return i;
      }
      throw new J("Could not convert ".concat(JSON.stringify(t), " to number."));
    } else
      return this.type.kind === "formatted" ? ce.fromString(We(this.args[0].evaluate(e))) : this.type.kind === "resolvedImage" ? be.fromString(We(this.args[0].evaluate(e))) : We(this.args[0].evaluate(e));
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
  serialize() {
    if (this.type.kind === "formatted")
      return new ht([{
        content: this.args[0],
        scale: null,
        font: null,
        textColor: null
      }]).serialize();
    if (this.type.kind === "resolvedImage")
      return new ft(this.args[0]).serialize();
    const e = ["to-".concat(this.type.kind)];
    return this.eachChild((t) => {
      e.push(t.serialize());
    }), e;
  }
};
var _e = dr;
var $o = [
  "Unknown",
  "Point",
  "LineString",
  "Polygon"
];
var Fo = class {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
  }
  id() {
    return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? $o[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  distanceFromCenter() {
    if (this.featureTileCoord && this.featureDistanceData) {
      const e = this.featureDistanceData.center, t = this.featureDistanceData.scale, { x: n, y: i } = this.featureTileCoord, o = n * t - e[0], a = i * t - e[1], s = this.featureDistanceData.bearing[0], l2 = this.featureDistanceData.bearing[1];
      return s * o + l2 * a;
    }
    return 0;
  }
  parseColor(e) {
    let t = this._parseColorCache[e];
    return t || (t = this._parseColorCache[e] = W.parse(e)), t;
  }
};
var _n = Fo;
var Se = class _Se {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this._evaluate = n, this.args = i;
  }
  evaluate(e) {
    return this._evaluate(e, this.args);
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return [this.name].concat(this.args.map((e) => e.serialize()));
  }
  static parse(e, t) {
    const n = e[0], i = _Se.definitions[n];
    if (!i)
      return t.error('Unknown expression "'.concat(n, '". If you wanted a literal array, use ["literal", [...]].'), 0);
    const o = Array.isArray(i) ? i[0] : i.type, a = Array.isArray(i) ? [[
      i[1],
      i[2]
    ]] : i.overloads, s = a.filter(
      ([u]) => !Array.isArray(u) || // varags
      u.length === e.length - 1
      // correct param count
    );
    let l2 = null;
    for (const [u, c] of s) {
      l2 = new qn(t.registry, t.path, null, t.scope);
      const p = [];
      let d = false;
      for (let m = 1; m < e.length; m++) {
        const v = e[m], _ = Array.isArray(u) ? u[m - 1] : u.type, j = l2.parse(v, 1 + p.length, _);
        if (!j) {
          d = true;
          break;
        }
        p.push(j);
      }
      if (!d) {
        if (Array.isArray(u) && u.length !== p.length) {
          l2.error("Expected ".concat(u.length, " arguments, but found ").concat(p.length, " instead."));
          continue;
        }
        for (let m = 0; m < p.length; m++) {
          const v = Array.isArray(u) ? u[m] : u.type, _ = p[m];
          l2.concat(m + 1).checkSubtype(v, _.type);
        }
        if (l2.errors.length === 0)
          return new _Se(n, o, c, p);
      }
    }
    if (s.length === 1)
      t.errors.push(...l2.errors);
    else {
      const c = (s.length ? s : a).map(([d]) => Uo(d)).join(" | "), p = [];
      for (let d = 1; d < e.length; d++) {
        const m = t.parse(e[d], 1 + p.length);
        if (!m)
          return null;
        p.push(L(m.type));
      }
      t.error("Expected arguments of type ".concat(c, ", but found (").concat(p.join(", "), ") instead."));
    }
    return null;
  }
  static register(e, t) {
    _Se.definitions = t;
    for (const n in t)
      e[n] = _Se;
  }
};
function Uo(r) {
  return Array.isArray(r) ? "(".concat(r.map(L).join(", "), ")") : "(".concat(L(r.type), "...)");
}
var De = Se;
var mt = class _mt {
  constructor(e, t, n) {
    this.type = dt, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected one argument.");
    const n = e[1];
    if (typeof n != "object" || Array.isArray(n))
      return t.error("Collator options argument must be an object.");
    const i = t.parse(n["case-sensitive"] === void 0 ? false : n["case-sensitive"], 1, z);
    if (!i)
      return null;
    const o = t.parse(n["diacritic-sensitive"] === void 0 ? false : n["diacritic-sensitive"], 1, z);
    if (!o)
      return null;
    let a = null;
    return n.locale && (a = t.parse(n.locale, 1, A), !a) ? null : new _mt(i, o, a);
  }
  evaluate(e) {
    return new lr(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
  }
  eachChild(e) {
    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    const e = {};
    return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), [
      "collator",
      e
    ];
  }
};
var xe = 8192;
function pr(r, e) {
  r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);
}
function Bo(r) {
  return (180 + r) / 360;
}
function Wo(r) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function it(r, e) {
  return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);
}
function Jo(r, e) {
  const t = Bo(r[0]), n = Wo(r[1]), i = Math.pow(2, e.z);
  return [
    Math.round(t * i * xe),
    Math.round(n * i * xe)
  ];
}
function Vo(r, e, t) {
  const n = r[0] - e[0], i = r[1] - e[1], o = r[0] - t[0], a = r[1] - t[1];
  return n * a - o * i === 0 && n * o <= 0 && i * a <= 0;
}
function Ho(r, e, t) {
  return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];
}
function hr(r, e) {
  let t = false;
  for (let n = 0, i = e.length; n < i; n++) {
    const o = e[n];
    for (let a = 0, s = o.length; a < s - 1; a++) {
      if (Vo(r, o[a], o[a + 1]))
        return false;
      Ho(r, o[a], o[a + 1]) && (t = !t);
    }
  }
  return t;
}
function Go(r, e) {
  for (let t = 0; t < e.length; t++)
    if (hr(r, e[t]))
      return true;
  return false;
}
function Zo(r, e) {
  return r[0] * e[1] - r[1] * e[0];
}
function Gr(r, e, t, n) {
  const i = r[0] - t[0], o = r[1] - t[1], a = e[0] - t[0], s = e[1] - t[1], l2 = n[0] - t[0], u = n[1] - t[1], c = i * u - l2 * o, p = a * u - l2 * s;
  return c > 0 && p < 0 || c < 0 && p > 0;
}
function Xo(r, e, t, n) {
  const i = [
    e[0] - r[0],
    e[1] - r[1]
  ], o = [
    n[0] - t[0],
    n[1] - t[1]
  ];
  return Zo(o, i) === 0 ? false : !!(Gr(r, e, t, n) && Gr(t, n, r, e));
}
function Yo(r, e, t) {
  for (const n of t)
    for (let i = 0; i < n.length - 1; ++i)
      if (Xo(r, e, n[i], n[i + 1]))
        return true;
  return false;
}
function Sn(r, e) {
  for (let t = 0; t < r.length; ++t)
    if (!hr(r[t], e))
      return false;
  for (let t = 0; t < r.length - 1; ++t)
    if (Yo(r[t], r[t + 1], e))
      return false;
  return true;
}
function Ko(r, e) {
  for (let t = 0; t < e.length; t++)
    if (Sn(r, e[t]))
      return true;
  return false;
}
function fr(r, e, t) {
  const n = [];
  for (let i = 0; i < r.length; i++) {
    const o = [];
    for (let a = 0; a < r[i].length; a++) {
      const s = Jo(r[i][a], t);
      pr(e, s), o.push(s);
    }
    n.push(o);
  }
  return n;
}
function In(r, e, t) {
  const n = [];
  for (let i = 0; i < r.length; i++) {
    const o = fr(r[i], e, t);
    n.push(o);
  }
  return n;
}
function Rn(r, e, t, n) {
  if (r[0] < t[0] || r[0] > t[2]) {
    const i = n * 0.5;
    let o = r[0] - t[0] > i ? -n : t[0] - r[0] > i ? n : 0;
    o === 0 && (o = r[0] - t[2] > i ? -n : t[2] - r[0] > i ? n : 0), r[0] += o;
  }
  pr(e, r);
}
function Qo(r) {
  r[0] = r[1] = 1 / 0, r[2] = r[3] = -1 / 0;
}
function Zr(r, e, t, n) {
  const i = Math.pow(2, n.z) * xe, o = [
    n.x * xe,
    n.y * xe
  ], a = [];
  if (!r)
    return a;
  for (const s of r)
    for (const l2 of s) {
      const u = [
        l2.x + o[0],
        l2.y + o[1]
      ];
      Rn(u, e, t, i), a.push(u);
    }
  return a;
}
function Xr(r, e, t, n) {
  const i = Math.pow(2, n.z) * xe, o = [
    n.x * xe,
    n.y * xe
  ], a = [];
  if (!r)
    return a;
  for (const s of r) {
    const l2 = [];
    for (const u of s) {
      const c = [
        u.x + o[0],
        u.y + o[1]
      ];
      pr(e, c), l2.push(c);
    }
    a.push(l2);
  }
  if (e[2] - e[0] <= i / 2) {
    Qo(e);
    for (const s of a)
      for (const l2 of s)
        Rn(l2, e, t, i);
  }
  return a;
}
function ea(r, e) {
  const t = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], n = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], i = r.canonicalID();
  if (!i)
    return false;
  if (e.type === "Polygon") {
    const o = fr(e.coordinates, n, i), a = Zr(r.geometry(), t, n, i);
    if (!it(t, n))
      return false;
    for (const s of a)
      if (!hr(s, o))
        return false;
  }
  if (e.type === "MultiPolygon") {
    const o = In(e.coordinates, n, i), a = Zr(r.geometry(), t, n, i);
    if (!it(t, n))
      return false;
    for (const s of a)
      if (!Go(s, o))
        return false;
  }
  return true;
}
function ta(r, e) {
  const t = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], n = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], i = r.canonicalID();
  if (!i)
    return false;
  if (e.type === "Polygon") {
    const o = fr(e.coordinates, n, i), a = Xr(r.geometry(), t, n, i);
    if (!it(t, n))
      return false;
    for (const s of a)
      if (!Sn(s, o))
        return false;
  }
  if (e.type === "MultiPolygon") {
    const o = In(e.coordinates, n, i), a = Xr(r.geometry(), t, n, i);
    if (!it(t, n))
      return false;
    for (const s of a)
      if (!Ko(s, o))
        return false;
  }
  return true;
}
var Je = class _Je {
  constructor(e, t) {
    this.type = z, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("'within' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
    if (rt(e[1])) {
      const n = e[1];
      if (n.type === "FeatureCollection")
        for (let i = 0; i < n.features.length; ++i) {
          const o = n.features[i].geometry.type;
          if (o === "Polygon" || o === "MultiPolygon")
            return new _Je(n, n.features[i].geometry);
        }
      else if (n.type === "Feature") {
        const i = n.geometry.type;
        if (i === "Polygon" || i === "MultiPolygon")
          return new _Je(n, n.geometry);
      } else if (n.type === "Polygon" || n.type === "MultiPolygon")
        return new _Je(n, n);
    }
    return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point")
        return ea(e, this.geometries);
      if (e.geometryType() === "LineString")
        return ta(e, this.geometries);
    }
    return false;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
  serialize() {
    return [
      "within",
      this.geojson
    ];
  }
};
var mr = Je;
function yr(r) {
  if (r instanceof De) {
    if (r.name === "get" && r.args.length === 1)
      return false;
    if (r.name === "feature-state")
      return false;
    if (r.name === "has" && r.args.length === 1)
      return false;
    if (r.name === "properties" || r.name === "geometry-type" || r.name === "id")
      return false;
    if (/^filter-/.test(r.name))
      return false;
  }
  if (r instanceof mr)
    return false;
  let e = true;
  return r.eachChild((t) => {
    e && !yr(t) && (e = false);
  }), e;
}
function gr(r) {
  if (r instanceof De && r.name === "feature-state")
    return false;
  let e = true;
  return r.eachChild((t) => {
    e && !gr(t) && (e = false);
  }), e;
}
function br(r, e) {
  if (r instanceof De && e.indexOf(r.name) >= 0)
    return false;
  let t = true;
  return r.eachChild((n) => {
    t && !br(n, e) && (t = false);
  }), t;
}
var vr = class _vr {
  constructor(e, t) {
    this.type = t.type, this.name = e, this.boundExpression = t;
  }
  static parse(e, t) {
    if (e.length !== 2 || typeof e[1] != "string")
      return t.error("'var' expression requires exactly one string literal argument.");
    const n = e[1];
    return t.scope.has(n) ? new _vr(n, t.scope.get(n)) : t.error('Unknown variable "'.concat(n, '". Make sure "').concat(n, '" has been bound in an enclosing "let" expression before using it.'), 1);
  }
  evaluate(e) {
    return this.boundExpression.evaluate(e);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return [
      "var",
      this.name
    ];
  }
};
var On = vr;
var wr = class _wr {
  // The expected type of this expression. Provided only to allow Expression
  // implementations to infer argument types: Expression#parse() need not
  // check that the output type of the parsed expression matches
  // `expectedType`.
  constructor(e, t = [], n, i = new Oo(), o = []) {
    this.registry = e, this.path = t, this.key = t.map((a) => "[".concat(a, "]")).join(""), this.scope = i, this.errors = o, this.expectedType = n;
  }
  /**
   * @param expr the JSON expression to parse
   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
   * @param options
   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
   * @private
   */
  parse(e, t, n, i, o = {}) {
    return t ? this.concat(t, n, i)._parse(e, o) : this._parse(e, o);
  }
  _parse(e, t) {
    (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = [
      "literal",
      e
    ]);
    function n(i, o, a) {
      return a === "assert" ? new fe(o, [i]) : a === "coerce" ? new _e(o, [i]) : i;
    }
    if (Array.isArray(e)) {
      if (e.length === 0)
        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      const i = e[0];
      if (typeof i != "string")
        return this.error("Expression name must be a string, but found ".concat(typeof i, ' instead. If you wanted a literal array, use ["literal", [...]].'), 0), null;
      const o = this.registry[i];
      if (o) {
        let a = o.parse(e, this);
        if (!a)
          return null;
        if (this.expectedType) {
          const s = this.expectedType, l2 = a.type;
          if ((s.kind === "string" || s.kind === "number" || s.kind === "boolean" || s.kind === "object" || s.kind === "array") && l2.kind === "value")
            a = n(a, s, t.typeAnnotation || "assert");
          else if ((s.kind === "color" || s.kind === "formatted" || s.kind === "resolvedImage") && (l2.kind === "value" || l2.kind === "string"))
            a = n(a, s, t.typeAnnotation || "coerce");
          else if (this.checkSubtype(s, l2))
            return null;
        }
        if (!(a instanceof nt) && a.type.kind !== "resolvedImage" && er(a)) {
          const s = new _n();
          try {
            a = new nt(a.type, a.evaluate(s));
          } catch (l2) {
            return this.error(l2.message), null;
          }
        }
        return a;
      }
      return this.error('Unknown expression "'.concat(i, '". If you wanted a literal array, use ["literal", [...]].'), 0);
    } else
      return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error("Expected an array, but found ".concat(typeof e, " instead."));
  }
  /**
   * Returns a copy of this context suitable for parsing the subexpression at
   * index `index`, optionally appending to 'let' binding map.
   *
   * Note that `errors` property, intended for collecting errors while
   * parsing, is copied by reference rather than cloned.
   * @private
   */
  concat(e, t, n) {
    const i = typeof e == "number" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;
    return new _wr(this.registry, i, t || null, o, this.errors);
  }
  /**
   * Push a parsing (or type checking) error into the `this.errors`
   * @param error The message
   * @param keys Optionally specify the source of the error at a child
   * of the current expression at `this.key`.
   * @private
   */
  error(e, ...t) {
    const n = "".concat(this.key).concat(t.map((i) => "[".concat(i, "]")).join(""));
    this.errors.push(new de(n, e));
  }
  /**
   * Returns null if `t` is a subtype of `expected`; otherwise returns an
   * error message and also pushes it to `this.errors`.
   */
  checkSubtype(e, t) {
    const n = He(e, t);
    return n && this.error(n), n;
  }
};
var qn = wr;
function er(r) {
  if (r instanceof On)
    return er(r.boundExpression);
  if (r instanceof De && r.name === "error")
    return false;
  if (r instanceof mt)
    return false;
  if (r instanceof mr)
    return false;
  const e = r instanceof _e || r instanceof fe;
  let t = true;
  return r.eachChild((n) => {
    e ? t = t && er(n) : t = t && n instanceof nt;
  }), t ? yr(r) && br(r, [
    "zoom",
    "heatmap-density",
    "line-progress",
    "sky-radial-progress",
    "accumulated",
    "is-supported-script",
    "pitch",
    "distance-from-center"
  ]) : false;
}
function yt(r, e) {
  const t = r.length - 1;
  let n = 0, i = t, o = 0, a, s;
  for (; n <= i; )
    if (o = Math.floor((n + i) / 2), a = r[o], s = r[o + 1], a <= e) {
      if (o === t || e < s)
        return o;
      n = o + 1;
    } else if (a > e)
      i = o - 1;
    else
      throw new J("Input is not a number.");
  return 0;
}
var xr = class _xr {
  constructor(e, t, n) {
    this.type = e, this.input = t, this.labels = [], this.outputs = [];
    for (const [i, o] of n)
      this.labels.push(i), this.outputs.push(o);
  }
  static parse(e, t) {
    if (e.length - 1 < 4)
      return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if ((e.length - 1) % 2 !== 0)
      return t.error("Expected an even number of arguments.");
    const n = t.parse(e[1], 1, y);
    if (!n)
      return null;
    const i = [];
    let o = null;
    t.expectedType && t.expectedType.kind !== "value" && (o = t.expectedType);
    for (let a = 1; a < e.length; a += 2) {
      const s = a === 1 ? -1 / 0 : e[a], l2 = e[a + 1], u = a, c = a + 1;
      if (typeof s != "number")
        return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u);
      if (i.length && i[i.length - 1][0] >= s)
        return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u);
      const p = t.parse(l2, c, o);
      if (!p)
        return null;
      o = o || p.type, i.push([
        s,
        p
      ]);
    }
    return new _xr(o, n, i);
  }
  evaluate(e) {
    const t = this.labels, n = this.outputs;
    if (t.length === 1)
      return n[0].evaluate(e);
    const i = this.input.evaluate(e);
    if (i <= t[0])
      return n[0].evaluate(e);
    const o = t.length;
    if (i >= t[o - 1])
      return n[o - 1].evaluate(e);
    const a = yt(t, i);
    return n[a].evaluate(e);
  }
  eachChild(e) {
    e(this.input);
    for (const t of this.outputs)
      e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
  serialize() {
    const e = [
      "step",
      this.input.serialize()
    ];
    for (let t = 0; t < this.labels.length; t++)
      t > 0 && e.push(this.labels[t]), e.push(this.outputs[t].serialize());
    return e;
  }
};
var Ln = xr;
var ra = Nn;
function Nn(r, e, t, n) {
  this.cx = 3 * r, this.bx = 3 * (t - r) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r, this.p1y = e, this.p2x = t, this.p2y = n;
}
Nn.prototype = {
  sampleCurveX: function(r) {
    return ((this.ax * r + this.bx) * r + this.cx) * r;
  },
  sampleCurveY: function(r) {
    return ((this.ay * r + this.by) * r + this.cy) * r;
  },
  sampleCurveDerivativeX: function(r) {
    return (3 * this.ax * r + 2 * this.bx) * r + this.cx;
  },
  solveCurveX: function(r, e) {
    if (e === void 0 && (e = 1e-6), r < 0)
      return 0;
    if (r > 1)
      return 1;
    for (var t = r, n = 0; n < 8; n++) {
      var i = this.sampleCurveX(t) - r;
      if (Math.abs(i) < e)
        return t;
      var o = this.sampleCurveDerivativeX(t);
      if (Math.abs(o) < 1e-6)
        break;
      t = t - i / o;
    }
    var a = 0, s = 1;
    for (t = r, n = 0; n < 20 && (i = this.sampleCurveX(t), !(Math.abs(i - r) < e)); n++)
      r > i ? a = t : s = t, t = (s - a) * 0.5 + a;
    return t;
  },
  solve: function(r, e) {
    return this.sampleCurveY(this.solveCurveX(r, e));
  }
};
function ne(r, e, t) {
  return r * (1 - t) + e * t;
}
function na(r, e, t) {
  return new W(ne(r.r, e.r, t), ne(r.g, e.g, t), ne(r.b, e.b, t), ne(r.a, e.a, t));
}
function ia(r, e, t) {
  return r.map((n, i) => ne(n, e[i], t));
}
var Dn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  number: ne,
  color: na,
  array: ia
});
var Pn = 0.95047;
var Mn = 1;
var $n = 1.08883;
var Fn = 4 / 29;
var Oe = 6 / 29;
var Un = 3 * Oe * Oe;
var oa = Oe * Oe * Oe;
var aa = Math.PI / 180;
var sa = 180 / Math.PI;
function At(r) {
  return r > oa ? Math.pow(r, 1 / 3) : r / Un + Fn;
}
function _t(r) {
  return r > Oe ? r * r * r : Un * (r - Fn);
}
function St(r) {
  return 255 * (r <= 31308e-7 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055);
}
function It(r) {
  return r /= 255, r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
}
function Bn(r) {
  const e = It(r.r), t = It(r.g), n = It(r.b), i = At((0.4124564 * e + 0.3575761 * t + 0.1804375 * n) / Pn), o = At((0.2126729 * e + 0.7151522 * t + 0.072175 * n) / Mn), a = At((0.0193339 * e + 0.119192 * t + 0.9503041 * n) / $n);
  return {
    l: 116 * o - 16,
    a: 500 * (i - o),
    b: 200 * (o - a),
    alpha: r.a
  };
}
function Wn(r) {
  let e = (r.l + 16) / 116, t = isNaN(r.a) ? e : e + r.a / 500, n = isNaN(r.b) ? e : e - r.b / 200;
  return e = Mn * _t(e), t = Pn * _t(t), n = $n * _t(n), new W(
    St(3.2404542 * t - 1.5371385 * e - 0.4985314 * n),
    // D65 -> sRGB
    St(-0.969266 * t + 1.8760108 * e + 0.041556 * n),
    St(0.0556434 * t - 0.2040259 * e + 1.0572252 * n),
    r.alpha
  );
}
function la(r, e, t) {
  return {
    l: ne(r.l, e.l, t),
    a: ne(r.a, e.a, t),
    b: ne(r.b, e.b, t),
    alpha: ne(r.alpha, e.alpha, t)
  };
}
function ua(r) {
  const { l: e, a: t, b: n } = Bn(r), i = Math.atan2(n, t) * sa;
  return {
    h: i < 0 ? i + 360 : i,
    c: Math.sqrt(t * t + n * n),
    l: e,
    alpha: r.a
  };
}
function ca(r) {
  const e = r.h * aa, t = r.c, n = r.l;
  return Wn({
    l: n,
    a: Math.cos(e) * t,
    b: Math.sin(e) * t,
    alpha: r.alpha
  });
}
function da(r, e, t) {
  const n = e - r;
  return r + t * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
}
function pa(r, e, t) {
  return {
    h: da(r.h, e.h, t),
    c: ne(r.c, e.c, t),
    l: ne(r.l, e.l, t),
    alpha: ne(r.alpha, e.alpha, t)
  };
}
var Fe = {
  forward: Bn,
  reverse: Wn,
  interpolate: la
};
var Ue = {
  forward: ua,
  reverse: ca,
  interpolate: pa
};
var Jn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  lab: Fe,
  hcl: Ue
});
var ot = class _ot {
  constructor(e, t, n, i, o) {
    this.type = e, this.operator = t, this.interpolation = n, this.input = i, this.labels = [], this.outputs = [];
    for (const [a, s] of o)
      this.labels.push(a), this.outputs.push(s);
  }
  static interpolationFactor(e, t, n, i) {
    let o = 0;
    if (e.name === "exponential")
      o = Rt(t, e.base, n, i);
    else if (e.name === "linear")
      o = Rt(t, 1, n, i);
    else if (e.name === "cubic-bezier") {
      const a = e.controlPoints;
      o = new ra(a[0], a[1], a[2], a[3]).solve(Rt(t, 1, n, i));
    }
    return o;
  }
  static parse(e, t) {
    let [n, i, o, ...a] = e;
    if (!Array.isArray(i) || i.length === 0)
      return t.error("Expected an interpolation type expression.", 1);
    if (i[0] === "linear")
      i = { name: "linear" };
    else if (i[0] === "exponential") {
      const u = i[1];
      if (typeof u != "number")
        return t.error("Exponential interpolation requires a numeric base.", 1, 1);
      i = {
        name: "exponential",
        base: u
      };
    } else if (i[0] === "cubic-bezier") {
      const u = i.slice(1);
      if (u.length !== 4 || u.some((c) => typeof c != "number" || c < 0 || c > 1))
        return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      i = {
        name: "cubic-bezier",
        controlPoints: u
      };
    } else
      return t.error("Unknown interpolation type ".concat(String(i[0])), 1, 0);
    if (e.length - 1 < 4)
      return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if ((e.length - 1) % 2 !== 0)
      return t.error("Expected an even number of arguments.");
    if (o = t.parse(o, 2, y), !o)
      return null;
    const s = [];
    let l2 = null;
    n === "interpolate-hcl" || n === "interpolate-lab" ? l2 = ye : t.expectedType && t.expectedType.kind !== "value" && (l2 = t.expectedType);
    for (let u = 0; u < a.length; u += 2) {
      const c = a[u], p = a[u + 1], d = u + 3, m = u + 4;
      if (typeof c != "number")
        return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', d);
      if (s.length && s[s.length - 1][0] >= c)
        return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', d);
      const v = t.parse(p, m, l2);
      if (!v)
        return null;
      l2 = l2 || v.type, s.push([
        c,
        v
      ]);
    }
    return l2.kind !== "number" && l2.kind !== "color" && !(l2.kind === "array" && l2.itemType.kind === "number" && typeof l2.N == "number") ? t.error("Type ".concat(L(l2), " is not interpolatable.")) : new _ot(l2, n, i, o, s);
  }
  evaluate(e) {
    const t = this.labels, n = this.outputs;
    if (t.length === 1)
      return n[0].evaluate(e);
    const i = this.input.evaluate(e);
    if (i <= t[0])
      return n[0].evaluate(e);
    const o = t.length;
    if (i >= t[o - 1])
      return n[o - 1].evaluate(e);
    const a = yt(t, i), s = t[a], l2 = t[a + 1], u = _ot.interpolationFactor(this.interpolation, i, s, l2), c = n[a].evaluate(e), p = n[a + 1].evaluate(e);
    return this.operator === "interpolate" ? Dn[this.type.kind.toLowerCase()](c, p, u) : this.operator === "interpolate-hcl" ? Ue.reverse(Ue.interpolate(Ue.forward(c), Ue.forward(p), u)) : Fe.reverse(Fe.interpolate(Fe.forward(c), Fe.forward(p), u));
  }
  eachChild(e) {
    e(this.input);
    for (const t of this.outputs)
      e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
  serialize() {
    let e;
    this.interpolation.name === "linear" ? e = ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? e = ["linear"] : e = [
      "exponential",
      this.interpolation.base
    ] : e = ["cubic-bezier"].concat(this.interpolation.controlPoints);
    const t = [
      this.operator,
      e,
      this.input.serialize()
    ];
    for (let n = 0; n < this.labels.length; n++)
      t.push(this.labels[n], this.outputs[n].serialize());
    return t;
  }
};
function Rt(r, e, t, n) {
  const i = n - t, o = r - t;
  return i === 0 ? 0 : e === 1 ? o / i : (Math.pow(e, o) - 1) / (Math.pow(e, i) - 1);
}
var ge = ot;
var at = class _at {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expectected at least one argument.");
    let n = null;
    const i = t.expectedType;
    i && i.kind !== "value" && (n = i);
    const o = [];
    for (const s of e.slice(1)) {
      const l2 = t.parse(s, 1 + o.length, n, void 0, { typeAnnotation: "omit" });
      if (!l2)
        return null;
      n = n || l2.type, o.push(l2);
    }
    return i && o.some((s) => He(i, s.type)) ? new _at(C, o) : new _at(n, o);
  }
  evaluate(e) {
    let t = null, n = 0, i;
    for (const o of this.args) {
      if (n++, t = o.evaluate(e), t && t instanceof be && !t.available && (i || (i = t), t = null, n === this.args.length))
        return i;
      if (t !== null)
        break;
    }
    return t;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
  serialize() {
    const e = ["coalesce"];
    return this.eachChild((t) => {
      e.push(t.serialize());
    }), e;
  }
};
var Vn = at;
var kr = class _kr {
  constructor(e, t) {
    this.type = t.type, this.bindings = [].concat(e), this.result = t;
  }
  evaluate(e) {
    return this.result.evaluate(e);
  }
  eachChild(e) {
    for (const t of this.bindings)
      e(t[1]);
    e(this.result);
  }
  static parse(e, t) {
    if (e.length < 4)
      return t.error("Expected at least 3 arguments, but found ".concat(e.length - 1, " instead."));
    const n = [];
    for (let o = 1; o < e.length - 1; o += 2) {
      const a = e[o];
      if (typeof a != "string")
        return t.error("Expected string, but found ".concat(typeof a, " instead."), o);
      if (/[^a-zA-Z0-9_]/.test(a))
        return t.error("Variable names must contain only alphanumeric characters or '_'.", o);
      const s = t.parse(e[o + 1], o + 1);
      if (!s)
        return null;
      n.push([
        a,
        s
      ]);
    }
    const i = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
    return i ? new _kr(n, i) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
  serialize() {
    const e = ["let"];
    for (const [t, n] of this.bindings)
      e.push(t, n.serialize());
    return e.push(this.result.serialize()), e;
  }
};
var Hn = kr;
var jr = class _jr {
  constructor(e, t, n) {
    this.type = e, this.index = t, this.input = n;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error("Expected 2 arguments, but found ".concat(e.length - 1, " instead."));
    const n = t.parse(e[1], 1, y), i = t.parse(e[2], 2, se(t.expectedType || C));
    if (!n || !i)
      return null;
    const o = i.type;
    return new _jr(o.itemType, n, i);
  }
  evaluate(e) {
    const t = this.index.evaluate(e), n = this.input.evaluate(e);
    if (t < 0)
      throw new J("Array index out of bounds: ".concat(t, " < 0."));
    if (t >= n.length)
      throw new J("Array index out of bounds: ".concat(t, " > ").concat(n.length - 1, "."));
    if (t !== Math.floor(t))
      throw new J("Array index must be an integer, but found ".concat(t, " instead."));
    return n[t];
  }
  eachChild(e) {
    e(this.index), e(this.input);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return [
      "at",
      this.index.serialize(),
      this.input.serialize()
    ];
  }
};
var ha = jr;
var Tr = class _Tr {
  constructor(e, t) {
    this.type = z, this.needle = e, this.haystack = t;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error("Expected 2 arguments, but found ".concat(e.length - 1, " instead."));
    const n = t.parse(e[1], 1, C), i = t.parse(e[2], 2, C);
    return !n || !i ? null : sr(n.type, [
      z,
      A,
      y,
      ct,
      C
    ]) ? new _Tr(n, i) : t.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(L(n.type), " instead"));
  }
  evaluate(e) {
    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (n == null)
      return false;
    if (!Ge(t, [
      "boolean",
      "string",
      "number",
      "null"
    ]))
      throw new J("Expected first argument to be of type boolean, string, number or null, but found ".concat(L(M(t)), " instead."));
    if (!Ge(n, [
      "string",
      "array"
    ]))
      throw new J("Expected second argument to be of type array or string, but found ".concat(L(M(n)), " instead."));
    return n.indexOf(t) >= 0;
  }
  eachChild(e) {
    e(this.needle), e(this.haystack);
  }
  outputDefined() {
    return true;
  }
  serialize() {
    return [
      "in",
      this.needle.serialize(),
      this.haystack.serialize()
    ];
  }
};
var fa = Tr;
var st = class _st {
  constructor(e, t, n) {
    this.type = y, this.needle = e, this.haystack = t, this.fromIndex = n;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5)
      return t.error("Expected 3 or 4 arguments, but found ".concat(e.length - 1, " instead."));
    const n = t.parse(e[1], 1, C), i = t.parse(e[2], 2, C);
    if (!n || !i)
      return null;
    if (!sr(n.type, [
      z,
      A,
      y,
      ct,
      C
    ]))
      return t.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(L(n.type), " instead"));
    if (e.length === 4) {
      const o = t.parse(e[3], 3, y);
      return o ? new _st(n, i, o) : null;
    } else
      return new _st(n, i);
  }
  evaluate(e) {
    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!Ge(t, [
      "boolean",
      "string",
      "number",
      "null"
    ]))
      throw new J("Expected first argument to be of type boolean, string, number or null, but found ".concat(L(M(t)), " instead."));
    if (!Ge(n, [
      "string",
      "array"
    ]))
      throw new J("Expected second argument to be of type array or string, but found ".concat(L(M(n)), " instead."));
    if (this.fromIndex) {
      const i = this.fromIndex.evaluate(e);
      return n.indexOf(t, i);
    }
    return n.indexOf(t);
  }
  eachChild(e) {
    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    if (this.fromIndex != null && this.fromIndex !== void 0) {
      const e = this.fromIndex.serialize();
      return [
        "index-of",
        this.needle.serialize(),
        this.haystack.serialize(),
        e
      ];
    }
    return [
      "index-of",
      this.needle.serialize(),
      this.haystack.serialize()
    ];
  }
};
var ma = st;
var zr = class _zr {
  constructor(e, t, n, i, o, a) {
    this.inputType = e, this.type = t, this.input = n, this.cases = i, this.outputs = o, this.otherwise = a;
  }
  static parse(e, t) {
    if (e.length < 5)
      return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if (e.length % 2 !== 1)
      return t.error("Expected an even number of arguments.");
    let n, i;
    t.expectedType && t.expectedType.kind !== "value" && (i = t.expectedType);
    const o = {}, a = [];
    for (let u = 2; u < e.length - 1; u += 2) {
      let c = e[u];
      const p = e[u + 1];
      Array.isArray(c) || (c = [c]);
      const d = t.concat(u);
      if (c.length === 0)
        return d.error("Expected at least one branch label.");
      for (const v of c) {
        if (typeof v != "number" && typeof v != "string")
          return d.error("Branch labels must be numbers or strings.");
        if (typeof v == "number" && Math.abs(v) > Number.MAX_SAFE_INTEGER)
          return d.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));
        if (typeof v == "number" && Math.floor(v) !== v)
          return d.error("Numeric branch labels must be integer values.");
        if (!n)
          n = M(v);
        else if (d.checkSubtype(n, M(v)))
          return null;
        if (typeof o[String(v)] < "u")
          return d.error("Branch labels must be unique.");
        o[String(v)] = a.length;
      }
      const m = t.parse(p, u, i);
      if (!m)
        return null;
      i = i || m.type, a.push(m);
    }
    const s = t.parse(e[1], 1, C);
    if (!s)
      return null;
    const l2 = t.parse(e[e.length - 1], e.length - 1, i);
    return !l2 || s.type.kind !== "value" && t.concat(1).checkSubtype(n, s.type) ? null : new _zr(n, i, s, o, a, l2);
  }
  evaluate(e) {
    const t = this.input.evaluate(e);
    return (M(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
  }
  eachChild(e) {
    e(this.input), this.outputs.forEach(e), e(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
  }
  serialize() {
    const e = [
      "match",
      this.input.serialize()
    ], t = Object.keys(this.cases).sort(), n = [], i = {};
    for (const a of t) {
      const s = i[this.cases[a]];
      s === void 0 ? (i[this.cases[a]] = n.length, n.push([
        this.cases[a],
        [a]
      ])) : n[s][1].push(a);
    }
    const o = (a) => this.inputType.kind === "number" ? Number(a) : a;
    for (const [a, s] of n)
      s.length === 1 ? e.push(o(s[0])) : e.push(s.map(o)), e.push(this.outputs[a].serialize());
    return e.push(this.otherwise.serialize()), e;
  }
};
var ya = zr;
var Cr = class _Cr {
  constructor(e, t, n) {
    this.type = e, this.branches = t, this.otherwise = n;
  }
  static parse(e, t) {
    if (e.length < 4)
      return t.error("Expected at least 3 arguments, but found only ".concat(e.length - 1, "."));
    if (e.length % 2 !== 0)
      return t.error("Expected an odd number of arguments.");
    let n;
    t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
    const i = [];
    for (let a = 1; a < e.length - 1; a += 2) {
      const s = t.parse(e[a], a, z);
      if (!s)
        return null;
      const l2 = t.parse(e[a + 1], a + 1, n);
      if (!l2)
        return null;
      i.push([
        s,
        l2
      ]), n = n || l2.type;
    }
    const o = t.parse(e[e.length - 1], e.length - 1, n);
    return o ? new _Cr(n, i, o) : null;
  }
  evaluate(e) {
    for (const [t, n] of this.branches)
      if (t.evaluate(e))
        return n.evaluate(e);
    return this.otherwise.evaluate(e);
  }
  eachChild(e) {
    for (const [t, n] of this.branches)
      e(t), e(n);
    e(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
  }
  serialize() {
    const e = ["case"];
    return this.eachChild((t) => {
      e.push(t.serialize());
    }), e;
  }
};
var ga = Cr;
var lt = class _lt {
  constructor(e, t, n, i) {
    this.type = e, this.input = t, this.beginIndex = n, this.endIndex = i;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5)
      return t.error("Expected 3 or 4 arguments, but found ".concat(e.length - 1, " instead."));
    const n = t.parse(e[1], 1, C), i = t.parse(e[2], 2, y);
    if (!n || !i)
      return null;
    if (!sr(n.type, [
      se(C),
      A,
      C
    ]))
      return t.error("Expected first argument to be of type array or string, but found ".concat(L(n.type), " instead"));
    if (e.length === 4) {
      const o = t.parse(e[3], 3, y);
      return o ? new _lt(n.type, n, i, o) : null;
    } else
      return new _lt(n.type, n, i);
  }
  evaluate(e) {
    const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
    if (!Ge(t, [
      "string",
      "array"
    ]))
      throw new J("Expected first argument to be of type array or string, but found ".concat(L(M(t)), " instead."));
    if (this.endIndex) {
      const i = this.endIndex.evaluate(e);
      return t.slice(n, i);
    }
    return t.slice(n);
  }
  eachChild(e) {
    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    if (this.endIndex != null && this.endIndex !== void 0) {
      const e = this.endIndex.serialize();
      return [
        "slice",
        this.input.serialize(),
        this.beginIndex.serialize(),
        e
      ];
    }
    return [
      "slice",
      this.input.serialize(),
      this.beginIndex.serialize()
    ];
  }
};
var ba = lt;
function Yr(r, e) {
  return r === "==" || r === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
function va(r, e, t) {
  return e === t;
}
function wa(r, e, t) {
  return e !== t;
}
function xa(r, e, t) {
  return e < t;
}
function ka(r, e, t) {
  return e > t;
}
function ja(r, e, t) {
  return e <= t;
}
function Ta(r, e, t) {
  return e >= t;
}
function Gn(r, e, t, n) {
  return n.compare(e, t) === 0;
}
function za(r, e, t, n) {
  return !Gn(r, e, t, n);
}
function Ca(r, e, t, n) {
  return n.compare(e, t) < 0;
}
function Ea(r, e, t, n) {
  return n.compare(e, t) > 0;
}
function Aa(r, e, t, n) {
  return n.compare(e, t) <= 0;
}
function _a(r, e, t, n) {
  return n.compare(e, t) >= 0;
}
function Pe(r, e, t) {
  const n = r !== "==" && r !== "!=";
  return class Zn {
    constructor(o, a, s) {
      this.type = z, this.lhs = o, this.rhs = a, this.collator = s, this.hasUntypedArgument = o.type.kind === "value" || a.type.kind === "value";
    }
    static parse(o, a) {
      if (o.length !== 3 && o.length !== 4)
        return a.error("Expected two or three arguments.");
      const s = o[0];
      let l2 = a.parse(o[1], 1, C);
      if (!l2)
        return null;
      if (!Yr(s, l2.type))
        return a.concat(1).error('"'.concat(s, "\" comparisons are not supported for type '").concat(L(l2.type), "'."));
      let u = a.parse(o[2], 2, C);
      if (!u)
        return null;
      if (!Yr(s, u.type))
        return a.concat(2).error('"'.concat(s, "\" comparisons are not supported for type '").concat(L(u.type), "'."));
      if (l2.type.kind !== u.type.kind && l2.type.kind !== "value" && u.type.kind !== "value")
        return a.error("Cannot compare types '".concat(L(l2.type), "' and '").concat(L(u.type), "'."));
      n && (l2.type.kind === "value" && u.type.kind !== "value" ? l2 = new fe(u.type, [l2]) : l2.type.kind !== "value" && u.type.kind === "value" && (u = new fe(l2.type, [u])));
      let c = null;
      if (o.length === 4) {
        if (l2.type.kind !== "string" && u.type.kind !== "string" && l2.type.kind !== "value" && u.type.kind !== "value")
          return a.error("Cannot use collator to compare non-string types.");
        if (c = a.parse(o[3], 3, dt), !c)
          return null;
      }
      return new Zn(l2, u, c);
    }
    evaluate(o) {
      const a = this.lhs.evaluate(o), s = this.rhs.evaluate(o);
      if (n && this.hasUntypedArgument) {
        const l2 = M(a), u = M(s);
        if (l2.kind !== u.kind || !(l2.kind === "string" || l2.kind === "number"))
          throw new J('Expected arguments for "'.concat(r, '" to be (string, string) or (number, number), but found (').concat(l2.kind, ", ").concat(u.kind, ") instead."));
      }
      if (this.collator && !n && this.hasUntypedArgument) {
        const l2 = M(a), u = M(s);
        if (l2.kind !== "string" || u.kind !== "string")
          return e(o, a, s);
      }
      return this.collator ? t(o, a, s, this.collator.evaluate(o)) : e(o, a, s);
    }
    eachChild(o) {
      o(this.lhs), o(this.rhs), this.collator && o(this.collator);
    }
    outputDefined() {
      return true;
    }
    serialize() {
      const o = [r];
      return this.eachChild((a) => {
        o.push(a.serialize());
      }), o;
    }
  };
}
var Sa = Pe("==", va, Gn);
var Ia = Pe("!=", wa, za);
var Ra = Pe("<", xa, Ca);
var Oa = Pe(">", ka, Ea);
var qa = Pe("<=", ja, Aa);
var La = Pe(">=", Ta, _a);
var Er = class _Er {
  // BCP 47 language tag
  // ISO 4217 currency code, required if style=currency
  // Simple units sanctioned for use in ECMAScript, required if style=unit. https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_proposed_out.html#sec-issanctionedsimpleunitidentifier
  // Default 0
  // Default 3
  constructor(e, t, n, i, o, a) {
    this.type = A, this.number = e, this.locale = t, this.currency = n, this.unit = i, this.minFractionDigits = o, this.maxFractionDigits = a;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error("Expected two arguments.");
    const n = t.parse(e[1], 1, y);
    if (!n)
      return null;
    const i = e[2];
    if (typeof i != "object" || Array.isArray(i))
      return t.error("NumberFormat options argument must be an object.");
    let o = null;
    if (i.locale && (o = t.parse(i.locale, 1, A), !o))
      return null;
    let a = null;
    if (i.currency && (a = t.parse(i.currency, 1, A), !a))
      return null;
    let s = null;
    if (i.unit && (s = t.parse(i.unit, 1, A), !s))
      return null;
    let l2 = null;
    if (i["min-fraction-digits"] && (l2 = t.parse(i["min-fraction-digits"], 1, y), !l2))
      return null;
    let u = null;
    return i["max-fraction-digits"] && (u = t.parse(i["max-fraction-digits"], 1, y), !u) ? null : new _Er(n, o, a, s, l2, u);
  }
  evaluate(e) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
      style: this.currency && "currency" || this.unit && "unit" || "decimal",
      currency: this.currency ? this.currency.evaluate(e) : void 0,
      unit: this.unit ? this.unit.evaluate(e) : void 0,
      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
    }).format(this.number.evaluate(e));
  }
  eachChild(e) {
    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    const e = {};
    return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
      "number-format",
      this.number.serialize(),
      e
    ];
  }
};
var Ar = class _Ar {
  constructor(e) {
    this.type = y, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected 1 argument, but found ".concat(e.length - 1, " instead."));
    const n = t.parse(e[1], 1);
    return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? t.error("Expected argument of type string or array, but found ".concat(L(n.type), " instead.")) : new _Ar(n) : null;
  }
  evaluate(e) {
    const t = this.input.evaluate(e);
    if (typeof t == "string")
      return t.length;
    if (Array.isArray(t))
      return t.length;
    throw new J("Expected value to be of type string or array, but found ".concat(L(M(t)), " instead."));
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
  serialize() {
    const e = ["length"];
    return this.eachChild((t) => {
      e.push(t.serialize());
    }), e;
  }
};
var Na = Ar;
var Xn = {
  // special forms
  "==": Sa,
  "!=": Ia,
  ">": Oa,
  "<": Ra,
  ">=": La,
  "<=": qa,
  array: fe,
  at: ha,
  boolean: fe,
  case: ga,
  coalesce: Vn,
  collator: mt,
  format: ht,
  image: ft,
  in: fa,
  "index-of": ma,
  interpolate: ge,
  "interpolate-hcl": ge,
  "interpolate-lab": ge,
  length: Na,
  let: Hn,
  literal: nt,
  match: ya,
  number: fe,
  "number-format": Er,
  object: fe,
  slice: ba,
  step: Ln,
  string: fe,
  "to-boolean": _e,
  "to-color": _e,
  "to-number": _e,
  "to-string": _e,
  var: On,
  within: mr
};
function Kr(r, [e, t, n, i]) {
  e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);
  const o = i ? i.evaluate(r) : 1, a = An(e, t, n, o);
  if (a)
    throw new J(a);
  return new W(e / 255 * o, t / 255 * o, n / 255 * o, o);
}
function Qr(r, e) {
  return r in e;
}
function Ot(r, e) {
  const t = e[r];
  return typeof t > "u" ? null : t;
}
function Da(r, e, t, n) {
  for (; t <= n; ) {
    const i = t + n >> 1;
    if (e[i] === r)
      return true;
    e[i] > r ? n = i - 1 : t = i + 1;
  }
  return false;
}
function je(r) {
  return { type: r };
}
De.register(Xn, {
  error: [
    qo,
    [A],
    (r, [e]) => {
      throw new J(e.evaluate(r));
    }
  ],
  typeof: [
    A,
    [C],
    (r, [e]) => L(M(e.evaluate(r)))
  ],
  "to-rgba": [
    se(y, 4),
    [ye],
    (r, [e]) => e.evaluate(r).toArray()
  ],
  rgb: [
    ye,
    [
      y,
      y,
      y
    ],
    Kr
  ],
  rgba: [
    ye,
    [
      y,
      y,
      y,
      y
    ],
    Kr
  ],
  has: {
    type: z,
    overloads: [
      [
        [A],
        (r, [e]) => Qr(e.evaluate(r), r.properties())
      ],
      [
        [
          A,
          Re
        ],
        (r, [e, t]) => Qr(e.evaluate(r), t.evaluate(r))
      ]
    ]
  },
  get: {
    type: C,
    overloads: [
      [
        [A],
        (r, [e]) => Ot(e.evaluate(r), r.properties())
      ],
      [
        [
          A,
          Re
        ],
        (r, [e, t]) => Ot(e.evaluate(r), t.evaluate(r))
      ]
    ]
  },
  "feature-state": [
    C,
    [A],
    (r, [e]) => Ot(e.evaluate(r), r.featureState || {})
  ],
  properties: [
    Re,
    [],
    (r) => r.properties()
  ],
  "geometry-type": [
    A,
    [],
    (r) => r.geometryType()
  ],
  id: [
    C,
    [],
    (r) => r.id()
  ],
  zoom: [
    y,
    [],
    (r) => r.globals.zoom
  ],
  pitch: [
    y,
    [],
    (r) => r.globals.pitch || 0
  ],
  "distance-from-center": [
    y,
    [],
    (r) => r.distanceFromCenter()
  ],
  "heatmap-density": [
    y,
    [],
    (r) => r.globals.heatmapDensity || 0
  ],
  "line-progress": [
    y,
    [],
    (r) => r.globals.lineProgress || 0
  ],
  "sky-radial-progress": [
    y,
    [],
    (r) => r.globals.skyRadialProgress || 0
  ],
  accumulated: [
    C,
    [],
    (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated
  ],
  "+": [
    y,
    je(y),
    (r, e) => {
      let t = 0;
      for (const n of e)
        t += n.evaluate(r);
      return t;
    }
  ],
  "*": [
    y,
    je(y),
    (r, e) => {
      let t = 1;
      for (const n of e)
        t *= n.evaluate(r);
      return t;
    }
  ],
  "-": {
    type: y,
    overloads: [
      [
        [
          y,
          y
        ],
        (r, [e, t]) => e.evaluate(r) - t.evaluate(r)
      ],
      [
        [y],
        (r, [e]) => -e.evaluate(r)
      ]
    ]
  },
  "/": [
    y,
    [
      y,
      y
    ],
    (r, [e, t]) => e.evaluate(r) / t.evaluate(r)
  ],
  "%": [
    y,
    [
      y,
      y
    ],
    (r, [e, t]) => e.evaluate(r) % t.evaluate(r)
  ],
  ln2: [
    y,
    [],
    () => Math.LN2
  ],
  pi: [
    y,
    [],
    () => Math.PI
  ],
  e: [
    y,
    [],
    () => Math.E
  ],
  "^": [
    y,
    [
      y,
      y
    ],
    (r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))
  ],
  sqrt: [
    y,
    [y],
    (r, [e]) => Math.sqrt(e.evaluate(r))
  ],
  log10: [
    y,
    [y],
    (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10
  ],
  ln: [
    y,
    [y],
    (r, [e]) => Math.log(e.evaluate(r))
  ],
  log2: [
    y,
    [y],
    (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2
  ],
  sin: [
    y,
    [y],
    (r, [e]) => Math.sin(e.evaluate(r))
  ],
  cos: [
    y,
    [y],
    (r, [e]) => Math.cos(e.evaluate(r))
  ],
  tan: [
    y,
    [y],
    (r, [e]) => Math.tan(e.evaluate(r))
  ],
  asin: [
    y,
    [y],
    (r, [e]) => Math.asin(e.evaluate(r))
  ],
  acos: [
    y,
    [y],
    (r, [e]) => Math.acos(e.evaluate(r))
  ],
  atan: [
    y,
    [y],
    (r, [e]) => Math.atan(e.evaluate(r))
  ],
  min: [
    y,
    je(y),
    (r, e) => Math.min(...e.map((t) => t.evaluate(r)))
  ],
  max: [
    y,
    je(y),
    (r, e) => Math.max(...e.map((t) => t.evaluate(r)))
  ],
  abs: [
    y,
    [y],
    (r, [e]) => Math.abs(e.evaluate(r))
  ],
  round: [
    y,
    [y],
    (r, [e]) => {
      const t = e.evaluate(r);
      return t < 0 ? -Math.round(-t) : Math.round(t);
    }
  ],
  floor: [
    y,
    [y],
    (r, [e]) => Math.floor(e.evaluate(r))
  ],
  ceil: [
    y,
    [y],
    (r, [e]) => Math.ceil(e.evaluate(r))
  ],
  "filter-==": [
    z,
    [
      A,
      C
    ],
    (r, [e, t]) => r.properties()[e.value] === t.value
  ],
  "filter-id-==": [
    z,
    [C],
    (r, [e]) => r.id() === e.value
  ],
  "filter-type-==": [
    z,
    [A],
    (r, [e]) => r.geometryType() === e.value
  ],
  "filter-<": [
    z,
    [
      A,
      C
    ],
    (r, [e, t]) => {
      const n = r.properties()[e.value], i = t.value;
      return typeof n == typeof i && n < i;
    }
  ],
  "filter-id-<": [
    z,
    [C],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t < n;
    }
  ],
  "filter->": [
    z,
    [
      A,
      C
    ],
    (r, [e, t]) => {
      const n = r.properties()[e.value], i = t.value;
      return typeof n == typeof i && n > i;
    }
  ],
  "filter-id->": [
    z,
    [C],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t > n;
    }
  ],
  "filter-<=": [
    z,
    [
      A,
      C
    ],
    (r, [e, t]) => {
      const n = r.properties()[e.value], i = t.value;
      return typeof n == typeof i && n <= i;
    }
  ],
  "filter-id-<=": [
    z,
    [C],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t <= n;
    }
  ],
  "filter->=": [
    z,
    [
      A,
      C
    ],
    (r, [e, t]) => {
      const n = r.properties()[e.value], i = t.value;
      return typeof n == typeof i && n >= i;
    }
  ],
  "filter-id->=": [
    z,
    [C],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t >= n;
    }
  ],
  "filter-has": [
    z,
    [C],
    (r, [e]) => e.value in r.properties()
  ],
  "filter-has-id": [
    z,
    [],
    (r) => r.id() !== null && r.id() !== void 0
  ],
  "filter-type-in": [
    z,
    [se(A)],
    (r, [e]) => e.value.indexOf(r.geometryType()) >= 0
  ],
  "filter-id-in": [
    z,
    [se(C)],
    (r, [e]) => e.value.indexOf(r.id()) >= 0
  ],
  "filter-in-small": [
    z,
    [
      A,
      se(C)
    ],
    // assumes v is an array literal
    (r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0
  ],
  "filter-in-large": [
    z,
    [
      A,
      se(C)
    ],
    // assumes v is a array literal with values sorted in ascending order and of a single type
    (r, [e, t]) => Da(r.properties()[e.value], t.value, 0, t.value.length - 1)
  ],
  all: {
    type: z,
    overloads: [
      [
        [
          z,
          z
        ],
        (r, [e, t]) => e.evaluate(r) && t.evaluate(r)
      ],
      [
        je(z),
        (r, e) => {
          for (const t of e)
            if (!t.evaluate(r))
              return false;
          return true;
        }
      ]
    ]
  },
  any: {
    type: z,
    overloads: [
      [
        [
          z,
          z
        ],
        (r, [e, t]) => e.evaluate(r) || t.evaluate(r)
      ],
      [
        je(z),
        (r, e) => {
          for (const t of e)
            if (t.evaluate(r))
              return true;
          return false;
        }
      ]
    ]
  },
  "!": [
    z,
    [z],
    (r, [e]) => !e.evaluate(r)
  ],
  "is-supported-script": [
    z,
    [A],
    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    (r, [e]) => {
      const t = r.globals && r.globals.isSupportedScript;
      return t ? t(e.evaluate(r)) : true;
    }
  ],
  upcase: [
    A,
    [A],
    (r, [e]) => e.evaluate(r).toUpperCase()
  ],
  downcase: [
    A,
    [A],
    (r, [e]) => e.evaluate(r).toLowerCase()
  ],
  concat: [
    A,
    je(C),
    (r, e) => e.map((t) => We(t.evaluate(r))).join("")
  ],
  "resolved-locale": [
    A,
    [dt],
    (r, [e]) => e.evaluate(r).resolvedLocale()
  ]
});
var Yn = Xn;
function tr(r) {
  return {
    result: "success",
    value: r
  };
}
function Ae(r) {
  return {
    result: "error",
    value: r
  };
}
function Pa(r) {
  return r["property-type"] === "data-driven";
}
function Ma(r) {
  return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
}
function Kn(r) {
  return !!r.expression && r.expression.interpolated;
}
function _r(r) {
  return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
}
function Sr(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r);
}
function $a(r) {
  return r;
}
function Ir(r, e) {
  const t = e.type === "color", n = r.stops && typeof r.stops[0][0] == "object", i = n || r.property !== void 0, o = n || !i, a = r.type || (Kn(e) ? "exponential" : "interval");
  if (t && (r = Cn({}, r), r.stops && (r.stops = r.stops.map((c) => [
    c[0],
    W.parse(c[1])
  ])), r.default ? r.default = W.parse(r.default) : r.default = W.parse(e.default)), r.colorSpace && r.colorSpace !== "rgb" && !Jn[r.colorSpace])
    throw new Error("Unknown color space: ".concat(r.colorSpace));
  let s, l2, u;
  if (a === "exponential")
    s = en;
  else if (a === "interval")
    s = Ua;
  else if (a === "categorical") {
    s = Fa, l2 = /* @__PURE__ */ Object.create(null);
    for (const c of r.stops)
      l2[c[0]] = c[1];
    u = typeof r.stops[0][0];
  } else if (a === "identity")
    s = Ba;
  else
    throw new Error('Unknown function type "'.concat(a, '"'));
  if (n) {
    const c = {}, p = [];
    for (let v = 0; v < r.stops.length; v++) {
      const _ = r.stops[v], j = _[0].zoom;
      c[j] === void 0 && (c[j] = {
        zoom: j,
        type: r.type,
        property: r.property,
        default: r.default,
        stops: []
      }, p.push(j)), c[j].stops.push([
        _[0].value,
        _[1]
      ]);
    }
    const d = [];
    for (const v of p)
      d.push([
        c[v].zoom,
        Ir(c[v], e)
      ]);
    const m = { name: "linear" };
    return {
      kind: "composite",
      interpolationType: m,
      interpolationFactor: ge.interpolationFactor.bind(void 0, m),
      zoomStops: d.map((v) => v[0]),
      evaluate({ zoom: v }, _) {
        return en({
          stops: d,
          base: r.base
        }, e, v).evaluate(v, _);
      }
    };
  } else if (o) {
    const c = a === "exponential" ? {
      name: "exponential",
      base: r.base !== void 0 ? r.base : 1
    } : null;
    return {
      kind: "camera",
      interpolationType: c,
      interpolationFactor: ge.interpolationFactor.bind(void 0, c),
      zoomStops: r.stops.map((p) => p[0]),
      evaluate: ({ zoom: p }) => s(r, e, p, l2, u)
    };
  } else
    return {
      kind: "source",
      evaluate(c, p) {
        const d = p && p.properties ? p.properties[r.property] : void 0;
        return d === void 0 ? Ye(r.default, e.default) : s(r, e, d, l2, u);
      }
    };
}
function Ye(r, e, t) {
  if (r !== void 0)
    return r;
  if (e !== void 0)
    return e;
  if (t !== void 0)
    return t;
}
function Fa(r, e, t, n, i) {
  const o = typeof t === i ? n[t] : void 0;
  return Ye(o, r.default, e.default);
}
function Ua(r, e, t) {
  if (_r(t) !== "number")
    return Ye(r.default, e.default);
  const n = r.stops.length;
  if (n === 1 || t <= r.stops[0][0])
    return r.stops[0][1];
  if (t >= r.stops[n - 1][0])
    return r.stops[n - 1][1];
  const i = yt(r.stops.map((o) => o[0]), t);
  return r.stops[i][1];
}
function en(r, e, t) {
  const n = r.base !== void 0 ? r.base : 1;
  if (_r(t) !== "number")
    return Ye(r.default, e.default);
  const i = r.stops.length;
  if (i === 1 || t <= r.stops[0][0])
    return r.stops[0][1];
  if (t >= r.stops[i - 1][0])
    return r.stops[i - 1][1];
  const o = yt(r.stops.map((c) => c[0]), t), a = Wa(t, n, r.stops[o][0], r.stops[o + 1][0]), s = r.stops[o][1], l2 = r.stops[o + 1][1];
  let u = Dn[e.type] || $a;
  if (r.colorSpace && r.colorSpace !== "rgb") {
    const c = Jn[r.colorSpace];
    u = (p, d) => c.reverse(c.interpolate(c.forward(p), c.forward(d), a));
  }
  return typeof s.evaluate == "function" ? {
    evaluate(...c) {
      const p = s.evaluate.apply(void 0, c), d = l2.evaluate.apply(void 0, c);
      if (!(p === void 0 || d === void 0))
        return u(p, d, a);
    }
  } : u(s, l2, a);
}
function Ba(r, e, t) {
  return e.type === "color" ? t = W.parse(t) : e.type === "formatted" ? t = ce.fromString(t.toString()) : e.type === "resolvedImage" ? t = be.fromString(t.toString()) : _r(t) !== e.type && (e.type !== "enum" || !e.values[t]) && (t = void 0), Ye(t, r.default, e.default);
}
function Wa(r, e, t, n) {
  const i = n - t, o = r - t;
  return i === 0 ? 0 : e === 1 ? o / i : (Math.pow(e, o) - 1) / (Math.pow(e, i) - 1);
}
var Qn = class {
  constructor(e, t) {
    this.expression = e, this._warningHistory = {}, this._evaluator = new _n(), this._defaultValue = t ? Ha(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null;
  }
  evaluateWithoutErrorHandling(e, t, n, i, o, a, s, l2) {
    return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = i || null, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = a, this._evaluator.featureTileCoord = s || null, this._evaluator.featureDistanceData = l2 || null, this.expression.evaluate(this._evaluator);
  }
  evaluate(e, t, n, i, o, a, s, l2) {
    this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = i || null, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = a || null, this._evaluator.featureTileCoord = s || null, this._evaluator.featureDistanceData = l2 || null;
    try {
      const u = this.expression.evaluate(this._evaluator);
      if (u == null || typeof u == "number" && u !== u)
        return this._defaultValue;
      if (this._enumValues && !(u in this._enumValues))
        throw new J("Expected value to be one of ".concat(Object.keys(this._enumValues).map((c) => JSON.stringify(c)).join(", "), ", but found ").concat(JSON.stringify(u), " instead."));
      return u;
    } catch (u) {
      return this._warningHistory[u.message] || (this._warningHistory[u.message] = true, typeof console < "u" && console.warn(u.message)), this._defaultValue;
    }
  }
};
function ei(r) {
  return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in Yn;
}
function ti(r, e) {
  const t = new qn(Yn, [], e ? Va(e) : void 0), n = t.parse(r, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return n ? tr(new Qn(n, e)) : Ae(t.errors);
}
var rr = class {
  constructor(e, t) {
    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !gr(t.expression);
  }
  evaluateWithoutErrorHandling(e, t, n, i, o, a) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, i, o, a);
  }
  evaluate(e, t, n, i, o, a) {
    return this._styleExpression.evaluate(e, t, n, i, o, a);
  }
};
var nr = class {
  constructor(e, t, n, i) {
    this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== "camera" && !gr(t.expression), this.interpolationType = i;
  }
  evaluateWithoutErrorHandling(e, t, n, i, o, a) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, i, o, a);
  }
  evaluate(e, t, n, i, o, a) {
    return this._styleExpression.evaluate(e, t, n, i, o, a);
  }
  interpolationFactor(e, t, n) {
    return this.interpolationType ? ge.interpolationFactor(this.interpolationType, e, t, n) : 0;
  }
};
function ri(r, e) {
  if (r = ti(r, e), r.result === "error")
    return r;
  const t = r.value.expression, n = yr(t);
  if (!n && !Pa(e))
    return Ae([new de("", "data expressions not supported")]);
  const i = br(t, [
    "zoom",
    "pitch",
    "distance-from-center"
  ]);
  if (!i && !Ma(e))
    return Ae([new de("", "zoom expressions not supported")]);
  const o = Qe(t);
  if (!o && !i)
    return Ae([new de("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (o instanceof de)
    return Ae([o]);
  if (o instanceof ge && !Kn(e))
    return Ae([new de("", '"interpolate" expressions cannot be used with this property')]);
  if (!o)
    return tr(n ? new rr("constant", r.value) : new rr("source", r.value));
  const a = o instanceof ge ? o.interpolation : void 0;
  return tr(n ? new nr("camera", r.value, o.labels, a) : new nr("composite", r.value, o.labels, a));
}
var gt = class _gt {
  constructor(e, t) {
    this._parameters = e, this._specification = t, Cn(this, Ir(this._parameters, this._specification));
  }
  static deserialize(e) {
    return new _gt(e._parameters, e._specification);
  }
  static serialize(e) {
    return {
      _parameters: e._parameters,
      _specification: e._specification
    };
  }
};
function Ja(r, e) {
  if (Sr(r))
    return new gt(r, e);
  if (ei(r)) {
    const t = ri(r, e);
    if (t.result === "error")
      throw new Error(t.value.map((n) => "".concat(n.key, ": ").concat(n.message)).join(", "));
    return t.value;
  } else {
    let t = r;
    return typeof r == "string" && e.type === "color" && (t = W.parse(r)), {
      kind: "constant",
      evaluate: () => t
    };
  }
}
function Qe(r) {
  let e = null;
  if (r instanceof Hn)
    e = Qe(r.result);
  else if (r instanceof Vn) {
    for (const t of r.args)
      if (e = Qe(t), e)
        break;
  } else
    (r instanceof Ln || r instanceof ge) && r.input instanceof De && r.input.name === "zoom" && (e = r);
  return e instanceof de || r.eachChild((t) => {
    const n = Qe(t);
    n instanceof de ? e = n : !e && n ? e = new de("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && n && e !== n && (e = new de("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), e;
}
function Va(r) {
  const e = {
    color: ye,
    string: A,
    number: y,
    enum: A,
    boolean: z,
    formatted: pt,
    resolvedImage: Xe
  };
  return r.type === "array" ? se(e[r.value] || C, r.length) : e[r.type];
}
function Ha(r) {
  return r.type === "color" && (Sr(r.default) || Array.isArray(r.default)) ? new W(0, 0, 0, 0) : r.type === "color" ? W.parse(r.default) || null : r.default === void 0 ? null : r.default;
}
function Ze(r) {
  return typeof r == "object" ? [
    "literal",
    r
  ] : r;
}
function Ga(r, e) {
  let t = r.stops;
  if (!t)
    return Za(r, e);
  const n = t && typeof t[0][0] == "object", i = n || r.property !== void 0, o = n || !i;
  return t = t.map((a) => !i && e.tokens && typeof a[1] == "string" ? [
    a[0],
    Qa(a[1])
  ] : [
    a[0],
    Ze(a[1])
  ]), n ? Xa(r, e, t) : o ? Ka(r, e, t) : ir(r, e, t);
}
function Za(r, e) {
  const t = [
    "get",
    r.property
  ];
  if (r.default === void 0)
    return e.type === "string" ? [
      "string",
      t
    ] : t;
  if (e.type === "enum")
    return [
      "match",
      t,
      Object.keys(e.values),
      t,
      r.default
    ];
  {
    const n = [
      e.type === "color" ? "to-color" : e.type,
      t,
      Ze(r.default)
    ];
    return e.type === "array" && n.splice(1, 0, e.value, e.length || null), n;
  }
}
function Rr(r) {
  switch (r.colorSpace) {
    case "hcl":
      return "interpolate-hcl";
    case "lab":
      return "interpolate-lab";
    default:
      return "interpolate";
  }
}
function Xa(r, e, t) {
  const n = {}, i = {}, o = [];
  for (let s = 0; s < t.length; s++) {
    const l2 = t[s], u = l2[0].zoom;
    n[u] === void 0 && (n[u] = {
      zoom: u,
      type: r.type,
      property: r.property,
      default: r.default
    }, i[u] = [], o.push(u)), i[u].push([
      l2[0].value,
      l2[1]
    ]);
  }
  if (qr({}, e) === "exponential") {
    const s = [
      Rr(r),
      ["linear"],
      ["zoom"]
    ];
    for (const l2 of o) {
      const u = ir(n[l2], e, i[l2]);
      qe(s, l2, u, false);
    }
    return s;
  } else {
    const s = [
      "step",
      ["zoom"]
    ];
    for (const l2 of o) {
      const u = ir(n[l2], e, i[l2]);
      qe(s, l2, u, true);
    }
    return Or(s), s;
  }
}
function Ya(r, e) {
  if (r !== void 0)
    return r;
  if (e !== void 0)
    return e;
}
function tn(r, e) {
  const t = Ze(Ya(r.default, e.default));
  return t === void 0 && e.type === "resolvedImage" ? "" : t;
}
function ir(r, e, t) {
  const n = qr(r, e), i = [
    "get",
    r.property
  ];
  if (n === "categorical" && typeof t[0][0] == "boolean") {
    const o = ["case"];
    for (const a of t)
      o.push([
        "==",
        i,
        a[0]
      ], a[1]);
    return o.push(tn(r, e)), o;
  } else if (n === "categorical") {
    const o = [
      "match",
      i
    ];
    for (const a of t)
      qe(o, a[0], a[1], false);
    return o.push(tn(r, e)), o;
  } else if (n === "interval") {
    const o = [
      "step",
      [
        "number",
        i
      ]
    ];
    for (const a of t)
      qe(o, a[0], a[1], true);
    return Or(o), r.default === void 0 ? o : [
      "case",
      [
        "==",
        [
          "typeof",
          i
        ],
        "number"
      ],
      o,
      Ze(r.default)
    ];
  } else if (n === "exponential") {
    const o = r.base !== void 0 ? r.base : 1, a = [
      Rr(r),
      o === 1 ? ["linear"] : [
        "exponential",
        o
      ],
      [
        "number",
        i
      ]
    ];
    for (const s of t)
      qe(a, s[0], s[1], false);
    return r.default === void 0 ? a : [
      "case",
      [
        "==",
        [
          "typeof",
          i
        ],
        "number"
      ],
      a,
      Ze(r.default)
    ];
  } else
    throw new Error("Unknown property function type ".concat(n));
}
function Ka(r, e, t, n = ["zoom"]) {
  const i = qr(r, e);
  let o, a = false;
  if (i === "interval")
    o = [
      "step",
      n
    ], a = true;
  else if (i === "exponential") {
    const s = r.base !== void 0 ? r.base : 1;
    o = [
      Rr(r),
      s === 1 ? ["linear"] : [
        "exponential",
        s
      ],
      n
    ];
  } else
    throw new Error('Unknown zoom function type "'.concat(i, '"'));
  for (const s of t)
    qe(o, s[0], s[1], a);
  return Or(o), o;
}
function Or(r) {
  r[0] === "step" && r.length === 3 && (r.push(0), r.push(r[3]));
}
function qe(r, e, t, n) {
  r.length > 3 && e === r[r.length - 2] || (n && r.length === 2 || r.push(e), r.push(t));
}
function qr(r, e) {
  return r.type ? r.type : e.expression.interpolated ? "exponential" : "interval";
}
function Qa(r) {
  const e = ["concat"], t = /{([^{}]+)}/g;
  let n = 0;
  for (let i = t.exec(r); i !== null; i = t.exec(r)) {
    const o = r.slice(n, t.lastIndex - i[0].length);
    n = t.lastIndex, o.length > 0 && e.push(o), e.push([
      "get",
      i[1]
    ]);
  }
  if (e.length === 1)
    return r;
  if (n < r.length)
    e.push(r.slice(n));
  else if (e.length === 2)
    return [
      "to-string",
      e[1]
    ];
  return e;
}
function ni(r) {
  if (r === true || r === false)
    return true;
  if (!Array.isArray(r) || r.length === 0)
    return false;
  switch (r[0]) {
    case "has":
      return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
    case "in":
      return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
    case "!in":
    case "!has":
    case "none":
      return false;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
    case "any":
    case "all":
      for (const e of r.slice(1))
        if (!ni(e) && typeof e != "boolean")
          return false;
      return true;
    default:
      return true;
  }
}
function es(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ts = {};
(function(r) {
  var e = function() {
    var t = function(j, g, f, b) {
      for (f = f || {}, b = j.length; b--; f[j[b]] = g)
        ;
      return f;
    }, n = [
      1,
      12
    ], i = [
      1,
      13
    ], o = [
      1,
      9
    ], a = [
      1,
      10
    ], s = [
      1,
      11
    ], l2 = [
      1,
      14
    ], u = [
      1,
      15
    ], c = [
      14,
      18,
      22,
      24
    ], p = [
      18,
      22
    ], d = [
      22,
      24
    ], m = {
      trace: function() {
      },
      yy: {},
      symbols_: {
        error: 2,
        JSONString: 3,
        STRING: 4,
        JSONNumber: 5,
        NUMBER: 6,
        JSONNullLiteral: 7,
        NULL: 8,
        JSONBooleanLiteral: 9,
        TRUE: 10,
        FALSE: 11,
        JSONText: 12,
        JSONValue: 13,
        EOF: 14,
        JSONObject: 15,
        JSONArray: 16,
        "{": 17,
        "}": 18,
        JSONMemberList: 19,
        JSONMember: 20,
        ":": 21,
        ",": 22,
        "[": 23,
        "]": 24,
        JSONElementList: 25,
        $accept: 0,
        $end: 1
      },
      terminals_: {
        2: "error",
        4: "STRING",
        6: "NUMBER",
        8: "NULL",
        10: "TRUE",
        11: "FALSE",
        14: "EOF",
        17: "{",
        18: "}",
        21: ":",
        22: ",",
        23: "[",
        24: "]"
      },
      productions_: [
        0,
        [
          3,
          1
        ],
        [
          5,
          1
        ],
        [
          7,
          1
        ],
        [
          9,
          1
        ],
        [
          9,
          1
        ],
        [
          12,
          2
        ],
        [
          13,
          1
        ],
        [
          13,
          1
        ],
        [
          13,
          1
        ],
        [
          13,
          1
        ],
        [
          13,
          1
        ],
        [
          13,
          1
        ],
        [
          15,
          2
        ],
        [
          15,
          3
        ],
        [
          20,
          3
        ],
        [
          19,
          1
        ],
        [
          19,
          3
        ],
        [
          16,
          2
        ],
        [
          16,
          3
        ],
        [
          25,
          1
        ],
        [
          25,
          3
        ]
      ],
      performAction: function(g, f, b, T, h, k, Y) {
        var E = k.length - 1;
        switch (h) {
          case 1:
            this.$ = new String(g.replace(/\\(\\|")/g, "$1").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "	").replace(/\\v/g, "\v").replace(/\\f/g, "\f").replace(/\\b/g, "\b")), this.$.__line__ = this._$.first_line;
            break;
          case 2:
            this.$ = new Number(g), this.$.__line__ = this._$.first_line;
            break;
          case 3:
            this.$ = null;
            break;
          case 4:
            this.$ = new Boolean(true), this.$.__line__ = this._$.first_line;
            break;
          case 5:
            this.$ = new Boolean(false), this.$.__line__ = this._$.first_line;
            break;
          case 6:
            return this.$ = k[E - 1];
          case 13:
            this.$ = {}, Object.defineProperty(this.$, "__line__", {
              value: this._$.first_line,
              enumerable: false
            });
            break;
          case 14:
          case 19:
            this.$ = k[E - 1], Object.defineProperty(this.$, "__line__", {
              value: this._$.first_line,
              enumerable: false
            });
            break;
          case 15:
            this.$ = [
              k[E - 2],
              k[E]
            ];
            break;
          case 16:
            this.$ = {}, this.$[k[E][0]] = k[E][1];
            break;
          case 17:
            this.$ = k[E - 2], k[E - 2][k[E][0]] = k[E][1];
            break;
          case 18:
            this.$ = [], Object.defineProperty(this.$, "__line__", {
              value: this._$.first_line,
              enumerable: false
            });
            break;
          case 20:
            this.$ = [k[E]];
            break;
          case 21:
            this.$ = k[E - 2], k[E - 2].push(k[E]);
            break;
        }
      },
      table: [
        {
          3: 5,
          4: n,
          5: 6,
          6: i,
          7: 3,
          8: o,
          9: 4,
          10: a,
          11: s,
          12: 1,
          13: 2,
          15: 7,
          16: 8,
          17: l2,
          23: u
        },
        { 1: [3] },
        {
          14: [
            1,
            16
          ]
        },
        t(c, [
          2,
          7
        ]),
        t(c, [
          2,
          8
        ]),
        t(c, [
          2,
          9
        ]),
        t(c, [
          2,
          10
        ]),
        t(c, [
          2,
          11
        ]),
        t(c, [
          2,
          12
        ]),
        t(c, [
          2,
          3
        ]),
        t(c, [
          2,
          4
        ]),
        t(c, [
          2,
          5
        ]),
        t([
          14,
          18,
          21,
          22,
          24
        ], [
          2,
          1
        ]),
        t(c, [
          2,
          2
        ]),
        {
          3: 20,
          4: n,
          18: [
            1,
            17
          ],
          19: 18,
          20: 19
        },
        {
          3: 5,
          4: n,
          5: 6,
          6: i,
          7: 3,
          8: o,
          9: 4,
          10: a,
          11: s,
          13: 23,
          15: 7,
          16: 8,
          17: l2,
          23: u,
          24: [
            1,
            21
          ],
          25: 22
        },
        {
          1: [
            2,
            6
          ]
        },
        t(c, [
          2,
          13
        ]),
        {
          18: [
            1,
            24
          ],
          22: [
            1,
            25
          ]
        },
        t(p, [
          2,
          16
        ]),
        {
          21: [
            1,
            26
          ]
        },
        t(c, [
          2,
          18
        ]),
        {
          22: [
            1,
            28
          ],
          24: [
            1,
            27
          ]
        },
        t(d, [
          2,
          20
        ]),
        t(c, [
          2,
          14
        ]),
        {
          3: 20,
          4: n,
          20: 29
        },
        {
          3: 5,
          4: n,
          5: 6,
          6: i,
          7: 3,
          8: o,
          9: 4,
          10: a,
          11: s,
          13: 30,
          15: 7,
          16: 8,
          17: l2,
          23: u
        },
        t(c, [
          2,
          19
        ]),
        {
          3: 5,
          4: n,
          5: 6,
          6: i,
          7: 3,
          8: o,
          9: 4,
          10: a,
          11: s,
          13: 31,
          15: 7,
          16: 8,
          17: l2,
          23: u
        },
        t(p, [
          2,
          17
        ]),
        t(p, [
          2,
          15
        ]),
        t(d, [
          2,
          21
        ])
      ],
      defaultActions: {
        16: [
          2,
          6
        ]
      },
      parseError: function(g, f) {
        if (f.recoverable)
          this.trace(g);
        else
          throw new Error(g);
      },
      parse: function(g) {
        var f = this, b = [0], T = [null], h = [], k = this.table, Y = "", E = 0, P = 0, K = 2, te = 1, $ = h.slice.call(arguments, 1), I = Object.create(this.lexer), N = { yy: {} };
        for (var ie in this.yy)
          Object.prototype.hasOwnProperty.call(this.yy, ie) && (N.yy[ie] = this.yy[ie]);
        I.setInput(g, N.yy), N.yy.lexer = I, N.yy.parser = this, typeof I.yylloc > "u" && (I.yylloc = {});
        var Z = I.yylloc;
        h.push(Z);
        var ze = I.options && I.options.ranges;
        typeof N.yy.parseError == "function" ? this.parseError = N.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
        function kt() {
          var B;
          return B = I.lex() || te, typeof B != "number" && (B = f.symbols_[B] || B), B;
        }
        for (var H, w, x, S, R = {}, O, q, D, F; ; ) {
          if (w = b[b.length - 1], this.defaultActions[w] ? x = this.defaultActions[w] : ((H === null || typeof H > "u") && (H = kt()), x = k[w] && k[w][H]), typeof x > "u" || !x.length || !x[0]) {
            var X = "";
            F = [];
            for (O in k[w])
              this.terminals_[O] && O > K && F.push("'" + this.terminals_[O] + "'");
            I.showPosition ? X = "Parse error on line " + (E + 1) + ":\n" + I.showPosition() + "\nExpecting " + F.join(", ") + ", got '" + (this.terminals_[H] || H) + "'" : X = "Parse error on line " + (E + 1) + ": Unexpected " + (H == te ? "end of input" : "'" + (this.terminals_[H] || H) + "'"), this.parseError(X, {
              text: I.match,
              token: this.terminals_[H] || H,
              line: I.yylineno,
              loc: Z,
              expected: F
            });
          }
          if (x[0] instanceof Array && x.length > 1)
            throw new Error("Parse Error: multiple actions possible at state: " + w + ", token: " + H);
          switch (x[0]) {
            case 1:
              b.push(H), T.push(I.yytext), h.push(I.yylloc), b.push(x[1]), H = null, P = I.yyleng, Y = I.yytext, E = I.yylineno, Z = I.yylloc;
              break;
            case 2:
              if (q = this.productions_[x[1]][1], R.$ = T[T.length - q], R._$ = {
                first_line: h[h.length - (q || 1)].first_line,
                last_line: h[h.length - 1].last_line,
                first_column: h[h.length - (q || 1)].first_column,
                last_column: h[h.length - 1].last_column
              }, ze && (R._$.range = [
                h[h.length - (q || 1)].range[0],
                h[h.length - 1].range[1]
              ]), S = this.performAction.apply(R, [
                Y,
                P,
                E,
                N.yy,
                x[1],
                T,
                h
              ].concat($)), typeof S < "u")
                return S;
              q && (b = b.slice(0, -1 * q * 2), T = T.slice(0, -1 * q), h = h.slice(0, -1 * q)), b.push(this.productions_[x[1]][0]), T.push(R.$), h.push(R._$), D = k[b[b.length - 2]][b[b.length - 1]], b.push(D);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    }, v = /* @__PURE__ */ function() {
      var j = {
        EOF: 1,
        parseError: function(f, b) {
          if (this.yy.parser)
            this.yy.parser.parseError(f, b);
          else
            throw new Error(f);
        },
        // resets the lexer, sets new input
        setInput: function(g, f) {
          return this.yy = f || this.yy || {}, this._input = g, this._more = this._backtrack = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          }, this.options.ranges && (this.yylloc.range = [
            0,
            0
          ]), this.offset = 0, this;
        },
        // consumes and returns one char from the input
        input: function() {
          var g = this._input[0];
          this.yytext += g, this.yyleng++, this.offset++, this.match += g, this.matched += g;
          var f = g.match(/(?:\r\n?|\n).*/g);
          return f ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), g;
        },
        // unshifts one char (or a string) into the input
        unput: function(g) {
          var f = g.length, b = g.split(/(?:\r\n?|\n)/g);
          this._input = g + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - f), this.offset -= f;
          var T = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), b.length - 1 && (this.yylineno -= b.length - 1);
          var h = this.yylloc.range;
          return this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: b ? (b.length === T.length ? this.yylloc.first_column : 0) + T[T.length - b.length].length - b[0].length : this.yylloc.first_column - f
          }, this.options.ranges && (this.yylloc.range = [
            h[0],
            h[0] + this.yyleng - f
          ]), this.yyleng = this.yytext.length, this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function() {
          return this._more = true, this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function() {
          if (this.options.backtrack_lexer)
            this._backtrack = true;
          else
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          return this;
        },
        // retain first n characters of the match
        less: function(g) {
          this.unput(this.match.slice(g));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function() {
          var g = this.matched.substr(0, this.matched.length - this.match.length);
          return (g.length > 20 ? "..." : "") + g.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function() {
          var g = this.match;
          return g.length < 20 && (g += this._input.substr(0, 20 - g.length)), (g.substr(0, 20) + (g.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function() {
          var g = this.pastInput(), f = new Array(g.length + 1).join("-");
          return g + this.upcomingInput() + "\n" + f + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function(g, f) {
          var b, T, h;
          if (this.options.backtrack_lexer && (h = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          }, this.options.ranges && (h.yylloc.range = this.yylloc.range.slice(0))), T = g[0].match(/(?:\r\n?|\n).*/g), T && (this.yylineno += T.length), this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: T ? T[T.length - 1].length - T[T.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + g[0].length
          }, this.yytext += g[0], this.match += g[0], this.matches = g, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [
            this.offset,
            this.offset += this.yyleng
          ]), this._more = false, this._backtrack = false, this._input = this._input.slice(g[0].length), this.matched += g[0], b = this.performAction.call(this, this.yy, this, f, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = false), b)
            return b;
          if (this._backtrack) {
            for (var k in h)
              this[k] = h[k];
            return false;
          }
          return false;
        },
        // return next match in input
        next: function() {
          if (this.done)
            return this.EOF;
          this._input || (this.done = true);
          var g, f, b, T;
          this._more || (this.yytext = "", this.match = "");
          for (var h = this._currentRules(), k = 0; k < h.length; k++)
            if (b = this._input.match(this.rules[h[k]]), b && (!f || b[0].length > f[0].length)) {
              if (f = b, T = k, this.options.backtrack_lexer) {
                if (g = this.test_match(b, h[k]), g !== false)
                  return g;
                if (this._backtrack) {
                  f = false;
                  continue;
                } else
                  return false;
              } else if (!this.options.flex)
                break;
            }
          return f ? (g = this.test_match(f, h[T]), g !== false ? g : false) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        },
        // return next match that has a token
        lex: function() {
          var f = this.next();
          return f || this.lex();
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function(f) {
          this.conditionStack.push(f);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function() {
          var f = this.conditionStack.length - 1;
          return f > 0 ? this.conditionStack.pop() : this.conditionStack[0];
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function() {
          return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function(f) {
          return f = this.conditionStack.length - 1 - Math.abs(f || 0), f >= 0 ? this.conditionStack[f] : "INITIAL";
        },
        // alias for begin(condition)
        pushState: function(f) {
          this.begin(f);
        },
        // return the number of states currently on the stack
        stateStackSize: function() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function(f, b, T, h) {
          switch (T) {
            case 0:
              break;
            case 1:
              return 6;
            case 2:
              return b.yytext = b.yytext.substr(1, b.yyleng - 2), 4;
            case 3:
              return 17;
            case 4:
              return 18;
            case 5:
              return 23;
            case 6:
              return 24;
            case 7:
              return 22;
            case 8:
              return 21;
            case 9:
              return 10;
            case 10:
              return 11;
            case 11:
              return 8;
            case 12:
              return 14;
            case 13:
              return "INVALID";
          }
        },
        rules: [
          /^(?:\s+)/,
          /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,
          /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,
          /^(?:\{)/,
          /^(?:\})/,
          /^(?:\[)/,
          /^(?:\])/,
          /^(?:,)/,
          /^(?::)/,
          /^(?:true\b)/,
          /^(?:false\b)/,
          /^(?:null\b)/,
          /^(?:$)/,
          /^(?:.)/
        ],
        conditions: {
          INITIAL: {
            rules: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13
            ],
            inclusive: true
          }
        }
      };
      return j;
    }();
    m.lexer = v;
    function _() {
      this.yy = {};
    }
    return _.prototype = m, m.Parser = _, new _();
  }();
  typeof es < "u" && (r.parser = e, r.Parser = e.Parser, r.parse = function() {
    return e.parse.apply(e, arguments);
  });
})(ts);
var rs = {
  StyleExpression: Qn,
  isExpression: ei,
  isExpressionFilter: ni,
  createExpression: ti,
  createPropertyExpression: ri,
  normalizePropertyExpression: Ja,
  ZoomConstantExpression: rr,
  ZoomDependentExpression: nr,
  StylePropertyFunction: gt
};
var ns = {
  convertFunction: Ga,
  createFunction: Ir,
  isFunction: Sr
};
function is(r) {
  var e = r.expr, t = r.layer, n = Math.min(e(t, "paint", "circle-radius"), 8), i = Math.min(e(t, "paint", "circle-stroke-width"), 4), o = e(t, "paint", "circle-color"), a = e(t, "paint", "circle-opacity"), s = e(t, "paint", "circle-stroke-color"), l2 = e(t, "paint", "circle-stroke-opacity"), u = n - i / 2;
  return { element: "svg", attributes: { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg", style: { filter: "blur(" + e(t, "paint", "circle-blur") * u + "px)" } }, children: [{ element: "circle", attributes: { key: "l1", cx: 10, cy: 10, fill: o, opacity: a, r: u } }, { element: "circle", attributes: { key: "l2", cx: 10, cy: 10, fill: "transparent", opacity: l2, r: n, "stroke-width": i, stroke: s } }] };
}
function os(r) {
  var e = r.expr, t = r.layer;
  return { element: "div", attributes: { style: { width: "100%", height: "100%", backgroundImage: "url(" + (0, r.image)(e(t, "paint", "fill-pattern")) + ")", backgroundColor: e(t, "paint", "fill-color"), opacity: e(t, "paint", "fill-opacity"), backgroundSize: "66% 66%", backgroundPosition: "center" } } };
}
function as(r) {
  var e = r.layer, t = r.expr, n = (0, r.image)(t(e, "paint", "line-pattern")), i = { stroke: n ? "url(#img1)" : t(e, "paint", "line-color"), strokeWidth: Math.max(2, Math.min(t(e, "paint", "line-width"), 8)), strokeOpacity: t(e, "paint", "line-opacity"), strokeDasharray: t(e, "paint", "line-dasharray") }, o = i.strokeWidth, a = "stroke: " + i.stroke + ";";
  return i.strokeOpacity && (a += "stroke-opacity: " + i.strokeOpacity + ";"), i.strokeDasharray && (a += "stroke-dasharray: " + i.strokeDasharray + ";"), { element: "svg", attributes: { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" }, children: [{ element: "defs", attributes: { key: "defs" }, children: [{ element: "pattern", attributes: { key: "pattern", id: "img1", x: 0, y: 0, width: i.strokeWidth, height: i.strokeWidth, patternUnits: "userSpaceOnUse", patternTransform: "translate(" + -o / 2 + " " + -o / 2 + ") rotate(45)" }, children: [{ element: "image", attributes: { key: "img", xlinkHref: n, x: 0, y: 0, width: i.strokeWidth, height: i.strokeWidth } }] }] }, { element: "path", attributes: { key: "path", style: a, d: "M0 20 L 20 0" } }] };
}
function ss(r) {
  return function(s) {
    var l2 = s.image, u = (0, s.expr)(s.layer, "layout", "icon-image");
    if (!u)
      return null;
    var c = l2(u);
    return c ? { element: "div", attributes: { style: { backgroundImage: "url(" + c + ")", backgroundSize: "contain", backgroundPosition: "center", backgroundRepeat: "no-repeat", width: "100%", height: "100%" } } } : null;
  }(r) || (i = (t = (e = r).expr)(n = e.layer, "paint", "text-color"), o = t(n, "paint", "text-opacity"), { element: "svg", attributes: { viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg" }, children: [{ element: "path", attributes: { key: "l1", d: a = "M 4,4 L 16,4 L 16,7 L 11.5 7 L 11.5 16 L 8.5 16 L 8.5 7 L 4 7 Z", stroke: t(n, "paint", "text-halo-color"), "stroke-width": 2 * t(n, "paint", "text-halo-width"), fill: "transparent", "stroke-linejoin": "round" } }, { element: "path", attributes: { key: "l2", d: a, fill: "white" } }, { element: "path", attributes: { key: "l3", d: a, fill: i, opacity: o } }] });
  var e, t, n, i, o, a;
}
var ls = [["background"], ["circle"], ["fill-extrusion"], ["fill"], ["heatmap"], ["hillshade"], ["line"], ["raster"], ["icon", "symbol"], ["text", "symbol"]];
function us(r) {
  var e, t = r.sprite, n = r.layer, i = { circle: is, symbol: ss, line: as, fill: os }[n.type], o = (e = r.zoom, function(a, s, l2) {
    var u = function(v) {
      var _ = ls.find(function(j) {
        return v.startsWith(j[0]);
      });
      return _ ? _[1] || _[0] : null;
    }(l2), c = go[s + "_" + u][l2];
    if (!a[s])
      return c.default;
    var p = a[s][l2];
    if (p === void 0)
      return c.default;
    if (typeof p == "object") {
      var d;
      if (Array.isArray(p)) {
        if (c.type === "array")
          return p;
        d = rs.createExpression(p).value;
      } else
        d = ns.createFunction(p, c);
      if (!d.evaluate)
        return null;
      var m = d.evaluate({ zoom: e }, {});
      return m ? m.name || m : null;
    }
    return p;
  });
  return i ? i({ layer: n, expr: o, image: function(a) {
    if (t && t.json) {
      var s = t.json[a];
      if (s)
        return l2 = t.image, c = (u = s).x, p = u.y, d = u.width, m = u.height, (v = document.createElement("canvas")).width = 2 * d, v.height = 2 * m, v.getContext("2d").drawImage(l2, 2 * c, 2 * p, 2 * d, 2 * m, 0, 0, 2 * d, 2 * m), v.toDataURL();
    }
    var l2, u, c, p, d, m, v;
    return null;
  } }) : null;
}
function cs(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Lr = { exports: {} };
var ii = function(e, t) {
  return function() {
    for (var i = new Array(arguments.length), o = 0; o < i.length; o++)
      i[o] = arguments[o];
    return e.apply(t, i);
  };
};
var ds = ii;
var Nr = Object.prototype.toString;
var Dr = /* @__PURE__ */ function(r) {
  return function(e) {
    var t = Nr.call(e);
    return r[t] || (r[t] = t.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function Te(r) {
  return r = r.toLowerCase(), function(t) {
    return Dr(t) === r;
  };
}
function Pr(r) {
  return Array.isArray(r);
}
function ut(r) {
  return typeof r > "u";
}
function ps(r) {
  return r !== null && !ut(r) && r.constructor !== null && !ut(r.constructor) && typeof r.constructor.isBuffer == "function" && r.constructor.isBuffer(r);
}
var oi = Te("ArrayBuffer");
function hs(r) {
  var e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && oi(r.buffer), e;
}
function fs(r) {
  return typeof r == "string";
}
function ms(r) {
  return typeof r == "number";
}
function ai(r) {
  return r !== null && typeof r == "object";
}
function et(r) {
  if (Dr(r) !== "object")
    return false;
  var e = Object.getPrototypeOf(r);
  return e === null || e === Object.prototype;
}
var ys = Te("Date");
var gs = Te("File");
var bs = Te("Blob");
var vs = Te("FileList");
function Mr(r) {
  return Nr.call(r) === "[object Function]";
}
function ws(r) {
  return ai(r) && Mr(r.pipe);
}
function xs(r) {
  var e = "[object FormData]";
  return r && (typeof FormData == "function" && r instanceof FormData || Nr.call(r) === e || Mr(r.toString) && r.toString() === e);
}
var ks = Te("URLSearchParams");
function js(r) {
  return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
}
function Ts() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? false : typeof window < "u" && typeof document < "u";
}
function $r(r, e) {
  if (!(r === null || typeof r > "u"))
    if (typeof r != "object" && (r = [r]), Pr(r))
      for (var t = 0, n = r.length; t < n; t++)
        e.call(null, r[t], t, r);
    else
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && e.call(null, r[i], i, r);
}
function or() {
  var r = {};
  function e(i, o) {
    et(r[o]) && et(i) ? r[o] = or(r[o], i) : et(i) ? r[o] = or({}, i) : Pr(i) ? r[o] = i.slice() : r[o] = i;
  }
  for (var t = 0, n = arguments.length; t < n; t++)
    $r(arguments[t], e);
  return r;
}
function zs(r, e, t) {
  return $r(e, function(i, o) {
    t && typeof i == "function" ? r[o] = ds(i, t) : r[o] = i;
  }), r;
}
function Cs(r) {
  return r.charCodeAt(0) === 65279 && (r = r.slice(1)), r;
}
function Es(r, e, t, n) {
  r.prototype = Object.create(e.prototype, n), r.prototype.constructor = r, t && Object.assign(r.prototype, t);
}
function As(r, e, t) {
  var n, i, o, a = {};
  e = e || {};
  do {
    for (n = Object.getOwnPropertyNames(r), i = n.length; i-- > 0; )
      o = n[i], a[o] || (e[o] = r[o], a[o] = true);
    r = Object.getPrototypeOf(r);
  } while (r && (!t || t(r, e)) && r !== Object.prototype);
  return e;
}
function _s(r, e, t) {
  r = String(r), (t === void 0 || t > r.length) && (t = r.length), t -= e.length;
  var n = r.indexOf(e, t);
  return n !== -1 && n === t;
}
function Ss(r) {
  if (!r)
    return null;
  var e = r.length;
  if (ut(e))
    return null;
  for (var t = new Array(e); e-- > 0; )
    t[e] = r[e];
  return t;
}
var Is = /* @__PURE__ */ function(r) {
  return function(e) {
    return r && e instanceof r;
  };
}(typeof Uint8Array < "u" && Object.getPrototypeOf(Uint8Array));
var V = {
  isArray: Pr,
  isArrayBuffer: oi,
  isBuffer: ps,
  isFormData: xs,
  isArrayBufferView: hs,
  isString: fs,
  isNumber: ms,
  isObject: ai,
  isPlainObject: et,
  isUndefined: ut,
  isDate: ys,
  isFile: gs,
  isBlob: bs,
  isFunction: Mr,
  isStream: ws,
  isURLSearchParams: ks,
  isStandardBrowserEnv: Ts,
  forEach: $r,
  merge: or,
  extend: zs,
  trim: js,
  stripBOM: Cs,
  inherits: Es,
  toFlatObject: As,
  kindOf: Dr,
  kindOfTest: Te,
  endsWith: _s,
  toArray: Ss,
  isTypedArray: Is,
  isFileList: vs
};
var Ce = V;
function rn(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var si = function(e, t, n) {
  if (!t)
    return e;
  var i;
  if (n)
    i = n(t);
  else if (Ce.isURLSearchParams(t))
    i = t.toString();
  else {
    var o = [];
    Ce.forEach(t, function(l2, u) {
      l2 === null || typeof l2 > "u" || (Ce.isArray(l2) ? u = u + "[]" : l2 = [l2], Ce.forEach(l2, function(p) {
        Ce.isDate(p) ? p = p.toISOString() : Ce.isObject(p) && (p = JSON.stringify(p)), o.push(rn(u) + "=" + rn(p));
      }));
    }), i = o.join("&");
  }
  if (i) {
    var a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return e;
};
var Rs = V;
function bt() {
  this.handlers = [];
}
bt.prototype.use = function(e, t, n) {
  return this.handlers.push({
    fulfilled: e,
    rejected: t,
    synchronous: n ? n.synchronous : false,
    runWhen: n ? n.runWhen : null
  }), this.handlers.length - 1;
};
bt.prototype.eject = function(e) {
  this.handlers[e] && (this.handlers[e] = null);
};
bt.prototype.forEach = function(e) {
  Rs.forEach(this.handlers, function(n) {
    n !== null && e(n);
  });
};
var Os = bt;
var qs = V;
var Ls = function(e, t) {
  qs.forEach(e, function(i, o) {
    o !== t && o.toUpperCase() === t.toUpperCase() && (e[t] = i, delete e[o]);
  });
};
var li = V;
function Le(r, e, t, n, i) {
  Error.call(this), this.message = r, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), n && (this.request = n), i && (this.response = i);
}
li.inherits(Le, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var ui = Le.prototype;
var ci = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED"
  // eslint-disable-next-line func-names
].forEach(function(r) {
  ci[r] = { value: r };
});
Object.defineProperties(Le, ci);
Object.defineProperty(ui, "isAxiosError", { value: true });
Le.from = function(r, e, t, n, i, o) {
  var a = Object.create(ui);
  return li.toFlatObject(r, a, function(l2) {
    return l2 !== Error.prototype;
  }), Le.call(a, r.message, e, t, n, i), a.name = r.name, o && Object.assign(a, o), a;
};
var Me = Le;
var di = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var ue = V;
function Ns(r, e) {
  e = e || new FormData();
  var t = [];
  function n(o) {
    return o === null ? "" : ue.isDate(o) ? o.toISOString() : ue.isArrayBuffer(o) || ue.isTypedArray(o) ? typeof Blob == "function" ? new Blob([o]) : Buffer.from(o) : o;
  }
  function i(o, a) {
    if (ue.isPlainObject(o) || ue.isArray(o)) {
      if (t.indexOf(o) !== -1)
        throw Error("Circular reference detected in " + a);
      t.push(o), ue.forEach(o, function(l2, u) {
        if (!ue.isUndefined(l2)) {
          var c = a ? a + "." + u : u, p;
          if (l2 && !a && typeof l2 == "object") {
            if (ue.endsWith(u, "{}"))
              l2 = JSON.stringify(l2);
            else if (ue.endsWith(u, "[]") && (p = ue.toArray(l2))) {
              p.forEach(function(d) {
                !ue.isUndefined(d) && e.append(c, n(d));
              });
              return;
            }
          }
          i(l2, c);
        }
      }), t.pop();
    } else
      e.append(a, n(o));
  }
  return i(r), e;
}
var pi = Ns;
var qt;
var nn;
function Ds() {
  if (nn)
    return qt;
  nn = 1;
  var r = Me;
  return qt = function(t, n, i) {
    var o = i.config.validateStatus;
    !i.status || !o || o(i.status) ? t(i) : n(new r(
      "Request failed with status code " + i.status,
      [r.ERR_BAD_REQUEST, r.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
      i.config,
      i.request,
      i
    ));
  }, qt;
}
var Lt;
var on;
function Ps() {
  if (on)
    return Lt;
  on = 1;
  var r = V;
  return Lt = r.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function() {
      return {
        write: function(n, i, o, a, s, l2) {
          var u = [];
          u.push(n + "=" + encodeURIComponent(i)), r.isNumber(o) && u.push("expires=" + new Date(o).toGMTString()), r.isString(a) && u.push("path=" + a), r.isString(s) && u.push("domain=" + s), l2 === true && u.push("secure"), document.cookie = u.join("; ");
        },
        read: function(n) {
          var i = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
          return i ? decodeURIComponent(i[3]) : null;
        },
        remove: function(n) {
          this.write(n, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), Lt;
}
var Ms = function(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
};
var $s = function(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
};
var Fs = Ms;
var Us = $s;
var hi = function(e, t) {
  return e && !Fs(t) ? Us(e, t) : t;
};
var Nt;
var an;
function Bs() {
  if (an)
    return Nt;
  an = 1;
  var r = V, e = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return Nt = function(n) {
    var i = {}, o, a, s;
    return n && r.forEach(n.split("\n"), function(u) {
      if (s = u.indexOf(":"), o = r.trim(u.substr(0, s)).toLowerCase(), a = r.trim(u.substr(s + 1)), o) {
        if (i[o] && e.indexOf(o) >= 0)
          return;
        o === "set-cookie" ? i[o] = (i[o] ? i[o] : []).concat([a]) : i[o] = i[o] ? i[o] + ", " + a : a;
      }
    }), i;
  }, Nt;
}
var Dt;
var sn;
function Ws() {
  if (sn)
    return Dt;
  sn = 1;
  var r = V;
  return Dt = r.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a"), i;
      function o(a) {
        var s = a;
        return t && (n.setAttribute("href", s), s = n.href), n.setAttribute("href", s), {
          href: n.href,
          protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
          host: n.host,
          search: n.search ? n.search.replace(/^\?/, "") : "",
          hash: n.hash ? n.hash.replace(/^#/, "") : "",
          hostname: n.hostname,
          port: n.port,
          pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
        };
      }
      return i = o(window.location.href), function(s) {
        var l2 = r.isString(s) ? o(s) : s;
        return l2.protocol === i.protocol && l2.host === i.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return function() {
        return true;
      };
    }()
  ), Dt;
}
var Pt;
var ln;
function vt() {
  if (ln)
    return Pt;
  ln = 1;
  var r = Me, e = V;
  function t(n) {
    r.call(this, n != null ? n : "canceled", r.ERR_CANCELED), this.name = "CanceledError";
  }
  return e.inherits(t, r, {
    __CANCEL__: true
  }), Pt = t, Pt;
}
var Mt;
var un;
function Js() {
  return un || (un = 1, Mt = function(e) {
    var t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || "";
  }), Mt;
}
var $t;
var cn;
function dn() {
  if (cn)
    return $t;
  cn = 1;
  var r = V, e = Ds(), t = Ps(), n = si, i = hi, o = Bs(), a = Ws(), s = di, l2 = Me, u = vt(), c = Js();
  return $t = function(d) {
    return new Promise(function(v, _) {
      var j = d.data, g = d.headers, f = d.responseType, b;
      function T() {
        d.cancelToken && d.cancelToken.unsubscribe(b), d.signal && d.signal.removeEventListener("abort", b);
      }
      r.isFormData(j) && r.isStandardBrowserEnv() && delete g["Content-Type"];
      var h = new XMLHttpRequest();
      if (d.auth) {
        var k = d.auth.username || "", Y = d.auth.password ? unescape(encodeURIComponent(d.auth.password)) : "";
        g.Authorization = "Basic " + btoa(k + ":" + Y);
      }
      var E = i(d.baseURL, d.url);
      h.open(d.method.toUpperCase(), n(E, d.params, d.paramsSerializer), true), h.timeout = d.timeout;
      function P() {
        if (h) {
          var $ = "getAllResponseHeaders" in h ? o(h.getAllResponseHeaders()) : null, I = !f || f === "text" || f === "json" ? h.responseText : h.response, N = {
            data: I,
            status: h.status,
            statusText: h.statusText,
            headers: $,
            config: d,
            request: h
          };
          e(function(Z) {
            v(Z), T();
          }, function(Z) {
            _(Z), T();
          }, N), h = null;
        }
      }
      if ("onloadend" in h ? h.onloadend = P : h.onreadystatechange = function() {
        !h || h.readyState !== 4 || h.status === 0 && !(h.responseURL && h.responseURL.indexOf("file:") === 0) || setTimeout(P);
      }, h.onabort = function() {
        h && (_(new l2("Request aborted", l2.ECONNABORTED, d, h)), h = null);
      }, h.onerror = function() {
        _(new l2("Network Error", l2.ERR_NETWORK, d, h, h)), h = null;
      }, h.ontimeout = function() {
        var I = d.timeout ? "timeout of " + d.timeout + "ms exceeded" : "timeout exceeded", N = d.transitional || s;
        d.timeoutErrorMessage && (I = d.timeoutErrorMessage), _(new l2(
          I,
          N.clarifyTimeoutError ? l2.ETIMEDOUT : l2.ECONNABORTED,
          d,
          h
        )), h = null;
      }, r.isStandardBrowserEnv()) {
        var K = (d.withCredentials || a(E)) && d.xsrfCookieName ? t.read(d.xsrfCookieName) : void 0;
        K && (g[d.xsrfHeaderName] = K);
      }
      "setRequestHeader" in h && r.forEach(g, function(I, N) {
        typeof j > "u" && N.toLowerCase() === "content-type" ? delete g[N] : h.setRequestHeader(N, I);
      }), r.isUndefined(d.withCredentials) || (h.withCredentials = !!d.withCredentials), f && f !== "json" && (h.responseType = d.responseType), typeof d.onDownloadProgress == "function" && h.addEventListener("progress", d.onDownloadProgress), typeof d.onUploadProgress == "function" && h.upload && h.upload.addEventListener("progress", d.onUploadProgress), (d.cancelToken || d.signal) && (b = function($) {
        h && (_(!$ || $ && $.type ? new u() : $), h.abort(), h = null);
      }, d.cancelToken && d.cancelToken.subscribe(b), d.signal && (d.signal.aborted ? b() : d.signal.addEventListener("abort", b))), j || (j = null);
      var te = c(E);
      if (te && ["http", "https", "file"].indexOf(te) === -1) {
        _(new l2("Unsupported protocol " + te + ":", l2.ERR_BAD_REQUEST, d));
        return;
      }
      h.send(j);
    });
  }, $t;
}
var Ft;
var pn;
function Vs() {
  return pn || (pn = 1, Ft = null), Ft;
}
var U = V;
var hn = Ls;
var fn = Me;
var Hs = di;
var Gs = pi;
var Zs = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function mn(r, e) {
  !U.isUndefined(r) && U.isUndefined(r["Content-Type"]) && (r["Content-Type"] = e);
}
function Xs() {
  var r;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (r = dn()), r;
}
function Ys(r, e, t) {
  if (U.isString(r))
    try {
      return (e || JSON.parse)(r), U.trim(r);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (t || JSON.stringify)(r);
}
var wt = {
  transitional: Hs,
  adapter: Xs(),
  transformRequest: [function(e, t) {
    if (hn(t, "Accept"), hn(t, "Content-Type"), U.isFormData(e) || U.isArrayBuffer(e) || U.isBuffer(e) || U.isStream(e) || U.isFile(e) || U.isBlob(e))
      return e;
    if (U.isArrayBufferView(e))
      return e.buffer;
    if (U.isURLSearchParams(e))
      return mn(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString();
    var n = U.isObject(e), i = t && t["Content-Type"], o;
    if ((o = U.isFileList(e)) || n && i === "multipart/form-data") {
      var a = this.env && this.env.FormData;
      return Gs(o ? { "files[]": e } : e, a && new a());
    } else if (n || i === "application/json")
      return mn(t, "application/json"), Ys(e);
    return e;
  }],
  transformResponse: [function(e) {
    var t = this.transitional || wt.transitional, n = t && t.silentJSONParsing, i = t && t.forcedJSONParsing, o = !n && this.responseType === "json";
    if (o || i && U.isString(e) && e.length)
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? fn.from(a, fn.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Vs()
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
U.forEach(["delete", "get", "head"], function(e) {
  wt.headers[e] = {};
});
U.forEach(["post", "put", "patch"], function(e) {
  wt.headers[e] = U.merge(Zs);
});
var Fr = wt;
var Ks = V;
var Qs = Fr;
var el = function(e, t, n) {
  var i = this || Qs;
  return Ks.forEach(n, function(a) {
    e = a.call(i, e, t);
  }), e;
};
var Ut;
var yn;
function fi() {
  return yn || (yn = 1, Ut = function(e) {
    return !!(e && e.__CANCEL__);
  }), Ut;
}
var gn = V;
var Bt = el;
var tl = fi();
var rl = Fr;
var nl = vt();
function Wt(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new nl();
}
var il = function(e) {
  Wt(e), e.headers = e.headers || {}, e.data = Bt.call(
    e,
    e.data,
    e.headers,
    e.transformRequest
  ), e.headers = gn.merge(
    e.headers.common || {},
    e.headers[e.method] || {},
    e.headers
  ), gn.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(i) {
      delete e.headers[i];
    }
  );
  var t = e.adapter || rl.adapter;
  return t(e).then(function(i) {
    return Wt(e), i.data = Bt.call(
      e,
      i.data,
      i.headers,
      e.transformResponse
    ), i;
  }, function(i) {
    return tl(i) || (Wt(e), i && i.response && (i.response.data = Bt.call(
      e,
      i.response.data,
      i.response.headers,
      e.transformResponse
    ))), Promise.reject(i);
  });
};
var re = V;
var mi = function(e, t) {
  t = t || {};
  var n = {};
  function i(c, p) {
    return re.isPlainObject(c) && re.isPlainObject(p) ? re.merge(c, p) : re.isPlainObject(p) ? re.merge({}, p) : re.isArray(p) ? p.slice() : p;
  }
  function o(c) {
    if (re.isUndefined(t[c])) {
      if (!re.isUndefined(e[c]))
        return i(void 0, e[c]);
    } else
      return i(e[c], t[c]);
  }
  function a(c) {
    if (!re.isUndefined(t[c]))
      return i(void 0, t[c]);
  }
  function s(c) {
    if (re.isUndefined(t[c])) {
      if (!re.isUndefined(e[c]))
        return i(void 0, e[c]);
    } else
      return i(void 0, t[c]);
  }
  function l2(c) {
    if (c in t)
      return i(e[c], t[c]);
    if (c in e)
      return i(void 0, e[c]);
  }
  var u = {
    url: a,
    method: a,
    data: a,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: l2
  };
  return re.forEach(Object.keys(e).concat(Object.keys(t)), function(p) {
    var d = u[p] || o, m = d(p);
    re.isUndefined(m) && d !== l2 || (n[p] = m);
  }), n;
};
var Jt;
var bn;
function yi() {
  return bn || (bn = 1, Jt = {
    version: "0.27.2"
  }), Jt;
}
var ol = yi().version;
var we = Me;
var Ur = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(r, e) {
  Ur[r] = function(n) {
    return typeof n === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
var vn = {};
Ur.transitional = function(e, t, n) {
  function i(o, a) {
    return "[Axios v" + ol + "] Transitional option '" + o + "'" + a + (n ? ". " + n : "");
  }
  return function(o, a, s) {
    if (e === false)
      throw new we(
        i(a, " has been removed" + (t ? " in " + t : "")),
        we.ERR_DEPRECATED
      );
    return t && !vn[a] && (vn[a] = true, console.warn(
      i(
        a,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(o, a, s) : true;
  };
};
function al(r, e, t) {
  if (typeof r != "object")
    throw new we("options must be an object", we.ERR_BAD_OPTION_VALUE);
  for (var n = Object.keys(r), i = n.length; i-- > 0; ) {
    var o = n[i], a = e[o];
    if (a) {
      var s = r[o], l2 = s === void 0 || a(s, o, r);
      if (l2 !== true)
        throw new we("option " + o + " must be " + l2, we.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== true)
      throw new we("Unknown option " + o, we.ERR_BAD_OPTION);
  }
}
var sl = {
  assertOptions: al,
  validators: Ur
};
var gi = V;
var ll = si;
var wn = Os;
var xn = il;
var xt = mi;
var ul = hi;
var bi = sl;
var Ee = bi.validators;
function Ne(r) {
  this.defaults = r, this.interceptors = {
    request: new wn(),
    response: new wn()
  };
}
Ne.prototype.request = function(e, t) {
  typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = xt(this.defaults, t), t.method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = "get";
  var n = t.transitional;
  n !== void 0 && bi.assertOptions(n, {
    silentJSONParsing: Ee.transitional(Ee.boolean),
    forcedJSONParsing: Ee.transitional(Ee.boolean),
    clarifyTimeoutError: Ee.transitional(Ee.boolean)
  }, false);
  var i = [], o = true;
  this.interceptors.request.forEach(function(m) {
    typeof m.runWhen == "function" && m.runWhen(t) === false || (o = o && m.synchronous, i.unshift(m.fulfilled, m.rejected));
  });
  var a = [];
  this.interceptors.response.forEach(function(m) {
    a.push(m.fulfilled, m.rejected);
  });
  var s;
  if (!o) {
    var l2 = [xn, void 0];
    for (Array.prototype.unshift.apply(l2, i), l2 = l2.concat(a), s = Promise.resolve(t); l2.length; )
      s = s.then(l2.shift(), l2.shift());
    return s;
  }
  for (var u = t; i.length; ) {
    var c = i.shift(), p = i.shift();
    try {
      u = c(u);
    } catch (d) {
      p(d);
      break;
    }
  }
  try {
    s = xn(u);
  } catch (d) {
    return Promise.reject(d);
  }
  for (; a.length; )
    s = s.then(a.shift(), a.shift());
  return s;
};
Ne.prototype.getUri = function(e) {
  e = xt(this.defaults, e);
  var t = ul(e.baseURL, e.url);
  return ll(t, e.params, e.paramsSerializer);
};
gi.forEach(["delete", "get", "head", "options"], function(e) {
  Ne.prototype[e] = function(t, n) {
    return this.request(xt(n || {}, {
      method: e,
      url: t,
      data: (n || {}).data
    }));
  };
});
gi.forEach(["post", "put", "patch"], function(e) {
  function t(n) {
    return function(o, a, s) {
      return this.request(xt(s || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: a
      }));
    };
  }
  Ne.prototype[e] = t(), Ne.prototype[e + "Form"] = t(true);
});
var cl = Ne;
var Vt;
var kn;
function dl() {
  if (kn)
    return Vt;
  kn = 1;
  var r = vt();
  function e(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    var n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    var i = this;
    this.promise.then(function(o) {
      if (i._listeners) {
        var a, s = i._listeners.length;
        for (a = 0; a < s; a++)
          i._listeners[a](o);
        i._listeners = null;
      }
    }), this.promise.then = function(o) {
      var a, s = new Promise(function(l2) {
        i.subscribe(l2), a = l2;
      }).then(o);
      return s.cancel = function() {
        i.unsubscribe(a);
      }, s;
    }, t(function(a) {
      i.reason || (i.reason = new r(a), n(i.reason));
    });
  }
  return e.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, e.prototype.subscribe = function(n) {
    if (this.reason) {
      n(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(n) : this._listeners = [n];
  }, e.prototype.unsubscribe = function(n) {
    if (this._listeners) {
      var i = this._listeners.indexOf(n);
      i !== -1 && this._listeners.splice(i, 1);
    }
  }, e.source = function() {
    var n, i = new e(function(a) {
      n = a;
    });
    return {
      token: i,
      cancel: n
    };
  }, Vt = e, Vt;
}
var Ht;
var jn;
function pl() {
  return jn || (jn = 1, Ht = function(e) {
    return function(n) {
      return e.apply(null, n);
    };
  }), Ht;
}
var Gt;
var Tn;
function hl() {
  if (Tn)
    return Gt;
  Tn = 1;
  var r = V;
  return Gt = function(t) {
    return r.isObject(t) && t.isAxiosError === true;
  }, Gt;
}
var zn = V;
var fl = ii;
var tt = cl;
var ml = mi;
var yl = Fr;
function vi(r) {
  var e = new tt(r), t = fl(tt.prototype.request, e);
  return zn.extend(t, tt.prototype, e), zn.extend(t, e), t.create = function(i) {
    return vi(ml(r, i));
  }, t;
}
var ee = vi(yl);
ee.Axios = tt;
ee.CanceledError = vt();
ee.CancelToken = dl();
ee.isCancel = fi();
ee.VERSION = yi().version;
ee.toFormData = pi;
ee.AxiosError = Me;
ee.Cancel = ee.CanceledError;
ee.all = function(e) {
  return Promise.all(e);
};
ee.spread = pl();
ee.isAxiosError = hl();
Lr.exports = ee;
Lr.exports.default = ee;
var gl = Lr.exports;
var bl = gl;
var vl = /* @__PURE__ */ cs(bl);
var xl = class {
  constructor(e, t) {
    ae(this, "controlContainer");
    ae(this, "map");
    ae(this, "legendContainer");
    ae(this, "legendButton");
    ae(this, "closeButton");
    ae(this, "legendTable");
    ae(this, "targets");
    ae(this, "uncheckedLayers", {});
    ae(this, "onlyRendered");
    ae(this, "options", {
      showDefault: true,
      showCheckbox: true,
      reverseOrder: true,
      onlyRendered: true,
      title: void 0
    });
    ae(this, "sprite", {
      image: HTMLImageElement,
      json: JSON
    });
    this.targets = e, t && (this.options = Object.assign(this.options, t)), this.onlyRendered = this.options.onlyRendered, this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  /**
   * create checkbox for switching layer visibility
   * @param layer mapboxgl.Layer object
   * @returns HTMLElement | undefined return TD Element
   */
  createLayerCheckbox(e) {
    var a;
    if (!this.options.showCheckbox)
      return;
    const t = (s, l2) => {
      var c, p;
      l2 ? (this.uncheckedLayers[s] && delete this.uncheckedLayers[s], (c = this.map) == null || c.setLayoutProperty(s, "visibility", "visible")) : (this.uncheckedLayers[s] = s, (p = this.map) == null || p.setLayoutProperty(s, "visibility", "none"));
      const u = document.getElementsByName(s);
      for (const d in u)
        typeof u[d] != "number" && (u[d].checked = l2);
    }, n = document.createElement("TD");
    n.className = "legend-table-td";
    const i = document.createElement("input");
    i.setAttribute("type", "checkbox"), i.setAttribute("name", e.id), i.setAttribute("value", e.id);
    const o = (a = this.map) == null ? void 0 : a.getLayoutProperty(e.id, "visibility");
    if (!o)
      i.checked = true;
    else {
      let s = true;
      switch (o) {
        case "none":
          s = false;
          break;
        case "visible":
          s = true, i.checked = true;
          break;
      }
      t(e.id, s);
    }
    return i.addEventListener("click", function(s) {
      var c, p;
      const l2 = (c = s.target) == null ? void 0 : c.value, u = (p = s.target) == null ? void 0 : p.checked;
      t(l2, u);
    }), n.appendChild(i), n;
  }
  /**
   * Create and return a layer's legend row
   * @param layer mapboxgl.Layer object
   * @returns HTMLElement | undefined return TR Element
   */
  getLayerLegend(e) {
    const t = this.map, n = t == null ? void 0 : t.getZoom(), i = this.sprite, o = us({ sprite: i, zoom: n, layer: e }), a = document.createElement("TR"), s = this.createLayerCheckbox(e);
    s && a.appendChild(s);
    const l2 = document.createElement("TD");
    if (l2.className = "legend-table-td", o)
      if (o.element === "div") {
        if (o.attributes.style.backgroundImage && !["url(undefined)", "url(null)"].includes(o.attributes.style.backgroundImage)) {
          const p = document.createElement("img");
          p.src = o.attributes.style.backgroundImage.replace("url(", "").replace(")", ""), p.alt = e.id, p.style.cssText = "height: 17px;", l2.appendChild(p);
        }
        l2.style.backgroundColor = o.attributes.style.backgroundColor, l2.style.backgroundPosition = o.attributes.style.backgroundPosition, l2.style.backgroundSize = o.attributes.style.backgroundSize, l2.style.backgroundRepeat = o.attributes.style.backgroundRepeat, l2.style.opacity = o.attributes.style.opacity;
      } else if (o.element === "svg") {
        const p = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        p.style.cssText = "height: 17px;", p.setAttributeNS(null, "version", "1.1"), Object.keys(o.attributes).forEach((m) => {
          p.setAttribute(m, o.attributes[m]);
          const v = document.createElementNS("http://www.w3.org/2000/svg", "g");
          o.children.forEach((_) => {
            const j = document.createElementNS("http://www.w3.org/2000/svg", _.element);
            Object.keys(_.attributes).forEach((g) => {
              j.setAttributeNS(null, g, _.attributes[g]);
            }), v.appendChild(j);
          }), p.appendChild(v);
        });
        const d = document.createElement("label");
        d.textContent = this.targets && this.targets[e.id] ? this.targets[e.id] : e.id, l2.appendChild(p);
      } else
        return;
    else {
      const p = document.createElementNS("http://www.w3.org/2000/svg", "svg"), d = document.createElementNS("http://www.w3.org/2000/svg", "path"), m = document.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute("fill", "none"), p.setAttribute("viewBox", "0 0 24 24"), p.setAttribute("stroke", "black"), p.classList.add("post-icon"), d.setAttribute(
        "d",
        "M21,0H3A3,3,0,0,0,0,3V21a3,3,0,0,0,3,3H21a3,3,0,0,0,3-3V3A3,3,0,0,0,21,0ZM3,2H21a1,1,0,0,1,1,1V15.86L14.18,9.35a5.06,5.06,0,0,0-6.39-.06L2,13.92V3A1,1,0,0,1,3,2ZM21,22H3a1,1,0,0,1-1-1V16.48l7-5.63a3.06,3.06,0,0,1,3.86,0L22,18.47V21A1,1,0,0,1,21,22Z"
      ), d.setAttribute("stroke-linecap", "round"), d.setAttribute("stroke-linejoin", "round"), d.setAttribute("stroke-width", "2"), m.setAttribute(
        "d",
        "M18,9a3,3,0,1,0-3-3A3,3,0,0,0,18,9Zm0-4a1,1,0,1,1-1,1A1,1,0,0,1,18,5Z"
      ), m.setAttribute("stroke-linecap", "round"), m.setAttribute("stroke-linejoin", "round"), m.setAttribute("stroke-width", "2"), p.appendChild(d), p.appendChild(m);
      const v = document.createElement("label");
      v.textContent = this.targets && this.targets[e.id] ? this.targets[e.id] : e.id, l2.appendChild(p);
    }
    const u = document.createElement("TD");
    u.className = "legend-table-td";
    const c = document.createElement("label");
    return c.textContent = this.targets && this.targets[e.id] ? this.targets[e.id] : e.id, u.appendChild(c), a.appendChild(l2), a.appendChild(u), a;
  }
  /**
     update legend contents
     */
  updateLegendControl() {
    const e = this.map, t = {};
    if (e) {
      const i = e.queryRenderedFeatures();
      for (const o of i)
        t[o.layer.id] = o.layer;
    }
    let n = e == null ? void 0 : e.getStyle().layers;
    if (n) {
      for (this.legendTable || (this.legendTable = document.createElement("TABLE"), this.legendTable.className = "legend-table", this.legendContainer.appendChild(this.legendTable)); this.legendTable.firstChild; )
        this.legendTable.removeChild(this.legendTable.firstChild);
      this.options.reverseOrder && (n = n.reverse()), n.forEach((i) => {
        if (t[i.id] && this.uncheckedLayers[i.id] ? delete this.uncheckedLayers[i.id] : this.uncheckedLayers[i.id] && (t[i.id] = i), this.targets === void 0 || // if target option is undefined, show all layers.
        this.targets && Object.keys(this.targets).length === 0 || // if no layer is specified, show all layers.
        this.targets && Object.keys(this.targets).map((o) => o).includes(i.id)) {
          if (this.onlyRendered && !t[i.id])
            return;
          const o = this.getLayerLegend(i);
          if (!o)
            return;
          this.legendTable.appendChild(o);
        } else
          return;
      });
    }
  }
  onAdd(e) {
    this.map = e, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("maplibregl-ctrl"), this.controlContainer.classList.add("maplibregl-ctrl-group"), this.legendContainer = document.createElement("div"), this.legendContainer.classList.add("maplibregl-legend-list"), this.legendButton = document.createElement("button"), this.legendButton.classList.add("maplibregl-ctrl-icon"), this.legendButton.classList.add("maplibregl-legend-switcher"), this.legendButton.addEventListener("click", () => {
      this.legendButton.style.display = "none", this.legendContainer.style.display = "block";
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.legendButton), this.controlContainer.appendChild(this.legendContainer), this.closeButton = document.createElement("button"), this.closeButton.textContent = "x", this.closeButton.classList.add("maplibregl-legend-close-button"), this.closeButton.addEventListener("click", () => {
      this.legendButton.style.display = "block", this.legendContainer.style.display = "none";
    }), this.legendContainer.appendChild(this.closeButton);
    const t = document.createElement("label");
    t.classList.add("maplibregl-legend-title-label"), t.textContent = this.options.title || "Legend", this.legendContainer.appendChild(t), this.legendContainer.appendChild(document.createElement("br"));
    const n = document.createElement("input");
    n.setAttribute("type", "checkbox");
    const i = "maplibregl-legend-onlyrendered-checkbox-".concat(Math.random() * 100);
    n.setAttribute("id", i), n.classList.add("maplibregl-legend-onlyRendered-checkbox"), n.checked = this.onlyRendered, n.addEventListener("click", this.handleClickOnlyRendered.bind(this)), this.legendContainer.appendChild(n);
    const o = document.createElement("label");
    o.classList.add("maplibregl-legend-onlyRendered-label"), o.textContent = "Only rendered", o.htmlFor = i, this.legendContainer.appendChild(o), this.legendContainer.appendChild(document.createElement("br")), this.map.on("moveend", () => {
      this.updateLegendControl();
    }), this.map.on("styledata", () => {
      this.updateLegendControl();
    });
    const a = async () => {
      if (e.loaded()) {
        const l2 = e.getStyle().sprite;
        l2 && await Promise.all([
          this.loadImage("".concat(l2, "@2x.png")),
          this.loadJson("".concat(l2, ".json"))
        ]).then(([c, p]) => {
          this.setSprite(c, p);
        }).catch((c) => console.error(c)), this.updateLegendControl(), e.off("idle", a);
      }
    };
    return this.map.on("idle", a), this.options && this.options.showDefault == true && (this.legendContainer.style.display = "block", this.legendButton.style.display = "none"), this.controlContainer;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.legendButton || (this.legendButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.map = void 0);
  }
  redraw() {
    this.updateLegendControl();
  }
  onDocumentClick(e) {
    this.controlContainer && !this.controlContainer.contains(e.target) && this.legendContainer && this.legendButton && this.options && this.options.showDefault !== true && (this.legendContainer.style.display = "none", this.legendButton.style.display = "block");
  }
  handleClickOnlyRendered(e) {
    var n;
    const t = (n = e.target) == null ? void 0 : n.checked;
    this.onlyRendered = !!t, this.updateLegendControl();
  }
  setSprite(e, t) {
    this.sprite = {
      image: e,
      json: t
    };
  }
  loadImage(e) {
    let t = false;
    const n = new Promise((i, o) => {
      const a = new Image();
      a.crossOrigin = "Anonymous", a.onload = () => {
        t || i(a);
      }, a.onerror = (s) => {
        t || o(s);
      }, a.src = e;
    });
    return n.cancel = () => {
      t = true;
    }, n;
  }
  loadJson(e) {
    return vl.get(e, { responseType: "json" }).then((t) => t.data);
  }
};

// src/map.maplibre/basemaps.js
var Basemaps = [];
var idsTagIp = ["tag-ip-mu", "maritime"];
var idsGoogle = ["google-sattelite", "google-terrain", "google-roadmap"];
var tilesGOOGLESatellite = [
  "https://mt0.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}",
  "https://mt1.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}",
  "https://mt2.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}",
  "https://mt3.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}"
];
var tilesGOOGLEHybrid = tilesGOOGLESatellite.map((a) => a.replace("s&hl", "y&hl"));
var tilesGOOGLETerrain = tilesGOOGLESatellite.map((a) => a.replace("s&hl", "p&hl"));
var tilesGOOGLERoadmap = tilesGOOGLESatellite.map((a) => a.replace("s&hl", "m&hl"));
var tilesGOOGLERoadmapAltered = tilesGOOGLESatellite.map((a) => a.replace("s&hl", "r&hl"));
var tilesGOOGLE = [tilesGOOGLESatellite, tilesGOOGLETerrain, tilesGOOGLERoadmap];
var sourceExtraParamsGOOGLE = {
  attribution: "Map tiles from Google",
  tileSize: 256
};
var vectorUrl = map_defaults_default.vectorurl;
var rasterUrl = map_defaults_default.rasterurl;
for (const a of idsTagIp) {
  const infos = {};
  infos.id = a;
  infos.name = a.replaceAll("-", " ").toUpperCase();
  infos.sourceType = "vector";
  infos.icon = vectorUrl.concat("/styles/", a, "/0/0/0.png");
  Basemaps.push(infos);
}
for (const a of idsGoogle) {
  const infos = {};
  const index = idsGoogle.indexOf(a);
  infos.id = a;
  infos.name = a;
  infos.sourceType = "raster";
  infos.sourceExtraParams = sourceExtraParamsGOOGLE;
  infos.tiles = tilesGOOGLE[index];
  Basemaps.push(infos);
}
var basemaps_default = Basemaps;

// src/map.maplibre/map_object.js
var layerId = {
  maritime_1: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_2: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_3: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_4: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_5: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_6: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_7: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_8: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_9: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_10: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_11: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_12: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_13: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_14: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_15: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_16: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_17: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_18: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_19: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_20: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_21: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_22: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_23: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_24: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_25: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_26: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_27: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_place_z3: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_place_z4: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_boundarires: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  maritime_boundarires_symbol: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "visible"
  },
  ocean: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "none"
  },
  ocean_name_point: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  sea_name_point: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  lake: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  world_boundaries: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  world_countries_continent: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  world_countries_country: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mdg_pays: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_lighthouses: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_cap_port_cap: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_cap_port_port: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mdg_reg_lines: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mdg_dis_lines: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mdg_com_plg: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mdg_com_lines: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mdg_fkt_lines: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  park_outline: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  waterway_tunnel: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  waterway_river: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  waterway_river_intermittent: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  waterway_other: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  waterway_other_intermittent: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  landcover_sand_outline: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  aeroway_fill: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  aeroway_runway: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  aeroway_taxiway: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  ferry: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_service_track_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_secondary_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_tertiary_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_trunk_primary_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_trunk_primary_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_trunk_primary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_path_pedestrian: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_service_track: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_minor: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_secondary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_tertiary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_trunk_primary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_area_pier: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_pier: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_area_bridge: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_area_pattern: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_service_track_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_minor_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  "road_secondary_casing-copy": {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_tertiary_casing_copy: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_path_pedestrian: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_trunk_primary_link_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_trunk_primary_link: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_service_track: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_minor: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_secondary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_tertiary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_trunk_primary_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_trunk_primary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_major_rail: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_major_rail_hatching: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_minor_rail: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_minor_rail_hatching: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_natural_0: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_natural_1: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_natural_2: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_natural_3: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_natural_4: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_0: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_1: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_2: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_3: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  plg_osm_4: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  building: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  building_3d: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  building_stadium: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  building_tomb: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  waterway_bridge_case: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  waterway_bridge: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_service_track_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_path_pedestrian_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_secondary_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_tertiary_casing: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_highway_secondary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_highway_secondary_gap: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_path_pedestrian: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_service_track: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_minor: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_secondary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_tertiary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_major_rail: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  bridge_major_rail_hatching: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_major_rail: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  tunnel_major_rail_hatching: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  cablecar: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  "cablecar-dash": {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  boundary_2_z0_4_maritime: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "none"
  },
  boundary_2_z5: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  boundary_2_z5_disputed: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  boundary_2_z5_disputed_maritime: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "none"
  },
  boundary_2_z5_maritime: {
    "tag-ip-mu": "none",
    "tag-ip-tau": "none",
    "tag-ip": "none",
    maritime: "none"
  },
  water_name_line: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  water_name_point: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  polygon_name_point: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_transport: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_emergency: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_amenity: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_leisure: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_shop: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_tourism_religion_historic: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_transit: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  roads_minor_oneway: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  roads_oneway: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_oneway_opposite: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  road_label: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  label_road_primary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  label_road_secondary_tertiary: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  airport_gate: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  continent: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  housenumber: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_demo: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_reg: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_dis: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_dis_cua: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_com: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_fkt_13: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_fkt_15: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  poi_loc: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  line_osm_ferry: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  line_osm_ferry_symbol: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_clusterable_cluster: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_clusterable_cluster_count: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_clusterable_markers: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_clusterable_icons: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_markers: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_icons: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_traces_borders: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_traces_default: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_traces_dasharray: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_events_default: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_events_selected: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_clusterable_labels: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_labels: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_selected_markers: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_selected_icons: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_trackables_selected_labels: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_events_stops: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  },
  mu_events_stops_labels: {
    "tag-ip-mu": "visible",
    "tag-ip-tau": "visible",
    "tag-ip": "visible",
    maritime: "visible"
  }
};
var maritimeValue = [
  "maritime_1",
  "maritime_2",
  "maritime_3",
  "maritime_4",
  "maritime_5",
  "maritime_6",
  "maritime_7",
  "maritime_8",
  "maritime_9",
  "maritime_10",
  "maritime_11",
  "maritime_12",
  "maritime_13",
  "maritime_14",
  "maritime_15",
  "maritime_16",
  "maritime_17",
  "maritime_18",
  "maritime_19",
  "maritime_20",
  "maritime_21",
  "maritime_22",
  "maritime_23",
  "maritime_24",
  "maritime_25",
  "maritime_26",
  "maritime_27"
];
var seaDepth = {
  maritime_1: "-1 \xE0 -24.99",
  maritime_2: "-25 \xE0 -49.99",
  maritime_3: "-50 \xE0 -99.99",
  maritime_4: "-100 \xE0 -249.99",
  maritime_5: "-250 \xE0 -499.99",
  maritime_6: "-500 \xE0 -749.99",
  maritime_7: "-750 \xE0 -999.99",
  maritime_8: "-1000 \xE0 -1249.99",
  maritime_9: "-1250 \xE0 -1499.99",
  maritime_10: "-1500 \xE0 -1749.99",
  maritime_11: "-1750 \xE0 -1999.99",
  maritime_12: "-2000 \xE0 -2499.99",
  maritime_13: "-2500 \xE0 -2999.99",
  maritime_14: "-3000 \xE0 -3499.99",
  maritime_15: "-3500 \xE0 -3999.99",
  maritime_16: "-4000 \xE0 -4499.99",
  maritime_17: "-4500 \xE0 -4999.99",
  maritime_18: "-5000 \xE0 -5499.99",
  maritime_19: "-5500 \xE0 -5999.99",
  maritime_20: "-6000 \xE0 -6499.99",
  maritime_21: "-6500 \xE0 -6999.99",
  maritime_22: "-7000 \xE0 -7499.99",
  maritime_23: "-7500 \xE0 -7999.99",
  maritime_24: "-8000 \xE0 -8499.99",
  maritime_25: "-8500 \xE0 -8999.99",
  maritime_26: "-9000 \xE0 -9499.99",
  maritime_27: "-9500 \xE0 -12000"
};
var LegendOptions = {
  showDefault: true,
  showCheckbox: false,
  onlyRendered: true,
  reverseOrder: false,
  title: "Valeurs de profondeur de la mer",
  instructions: false
};
var FleetLayers = [
  "mu_trackables_clusterable_icons",
  "mu_trackables_clusterable_labels",
  "mu_trackables_clusterable_markers"
];
var moveLayers = [
  "mu_trackables_clusterable_markers",
  "mu_trackables_clusterable_icons",
  "mu_trackables_clusterable_labels"
];
var Layers = [
  "mu_trackables_clusterable_cluster",
  "mu_trackables_clusterable_cluster_count",
  "mu_trackables_clusterable_markers",
  "mu_trackables_clusterable_icons",
  "mu_trackables_clusterable_labels",
  "mu_trackables_selected_markers",
  "mu_trackables_selected_icons",
  "mu_trackables_selected_labels",
  "mu_events_default",
  "mu_events_selected",
  "mu_events_stops",
  "mu_events_stops_labels",
  "mu_traces_borders",
  "mu_traces_default",
  "mu_traces_dasharray"
];
var map_object_default = {
  layerId,
  maritimeValue,
  seaDepth,
  LegendOptions,
  FleetLayers,
  Layers,
  moveLayers
};

// src/map.maplibre/map_object_events.js
function hideLegend() {
  document.getElementsByClassName("maplibregl-legend-list")[0].style.display = "none";
  document.getElementsByClassName(
    "maplibregl-legend-switcher"
  )[0].style.display = "none";
}
function switcherLegend(property) {
  document.getElementsByClassName(
    "maplibregl-legend-switcher"
  )[0].style.display = property;
}
function switcherLegendList(property) {
  document.getElementsByClassName("maplibregl-legend-list")[0].style.display = property;
}
function showLayers(map2, style) {
  if (style === "tag-ip") {
    Object.entries(map_object_default.layerId).forEach(([key, value]) => {
      if (map2.getLayer(key)) {
        map2.setLayoutProperty(key, "visibility", value["tag-ip"]);
      }
    });
  }
  if (style === "maritime") {
    Object.entries(map_object_default.layerId).forEach(([key, value]) => {
      if (map2.getLayer(key)) {
        map2.setLayoutProperty(key, "visibility", value.maritime);
      }
    });
  }
  if (style === "none") {
    Object.entries(map_object_default.layerId).forEach(([key, _value]) => {
      if (map2.getLayer(key)) {
        map2.setLayoutProperty(key, "visibility", "none");
      }
    });
  }
}
var map_object_events_default = {
  hideLegend,
  showLayers,
  switcherLegend,
  switcherLegendList
};

// src/map.maplibre/basemap_control.js
var LegendControl = new xl(
  map_object_default.seaDepth,
  map_object_default.LegendOptions
);
var BasemapControl = class {
  constructor(options) {
    this._options = __spreadValues({}, options);
    this._container = document.createElement("div");
    this._container.classList.add("maplibregl-ctrl");
    this._container.classList.add("maplibregl-ctrl-basemaps");
    this._container.classList.add("closed");
    switch (this._options.expandDirection) {
      case "top":
        this._container.classList.add("reverse");
        break;
      case "down":
        this._container.classList.add("reverse");
        this._container.classList.add("column");
        break;
      case "left":
        this._container.classList.add("reverse");
        break;
      case "right":
        this._container.classList.add("reverse");
        this._container.classList.add("row");
        break;
      default:
        this._container.classList.add("reverse");
        this._container.classList.add("row");
    }
    this._container.addEventListener("mouseenter", () => {
      this._container.classList.remove("closed");
    });
    this._container.addEventListener("mouseleave", () => {
      this._container.classList.add("closed");
    });
    this.activeBasemap = localStorage.getItem("map:basemap");
    if (!this.activeBasemap) this.setActiveBasemap(basemaps_default[0].id);
  }
  get isVector() {
    return this.activeBasemap === basemaps_default[0].id;
  }
  setActiveBasemap(id) {
    localStorage.setItem("map:basemap", id);
    this.activeBasemap = id;
    if (id !== basemaps_default[0].id && id !== basemaps_default[1].id) {
    }
  }
  onAdd(map2) {
    this._map = map2;
    map2.on("load", () => {
      for (const {
        id,
        tiles,
        sourceExtraParams = {},
        layerExtraParams = {},
        icon,
        img,
        name,
        sourceType
      } of basemaps_default) {
        const basemapContainer = document.createElement("img");
        if (sourceType === "vector") {
          basemapContainer.classList.add("basemap");
          basemapContainer.dataset.id = id;
          basemapContainer.dataset.basemap_type = "vector";
          basemapContainer.setAttribute("title", name);
          basemapContainer.setAttribute("id", id);
          basemapContainer.src = icon;
          this._container.appendChild(basemapContainer);
        }
        if (sourceType === "raster") {
          map2.addSource(id, __spreadProps(__spreadValues({}, sourceExtraParams), {
            type: "raster",
            tiles
          }));
          map2.addLayer(__spreadValues({
            id,
            source: id,
            type: "raster"
          }, layerExtraParams));
          if (this.activeBasemap === id) {
            map2.setLayoutProperty(id, "visibility", "visible");
          } else map2.setLayoutProperty(id, "visibility", "none");
          basemapContainer.classList.add("basemap");
          basemapContainer.dataset.id = id;
          basemapContainer.dataset.basemap_type = "raster";
          basemapContainer.setAttribute("title", name);
          basemapContainer.setAttribute("id", id);
          basemapContainer.src = tiles[0].replace("{x}", "0").replace("{y}", "0").replace("{z}", (sourceExtraParams.minzoom || 0).toString());
          this._container.appendChild(basemapContainer);
        }
        if (this.activeBasemap === id) {
          basemapContainer.classList.toggle("active");
        }
        basemapContainer.addEventListener("click", () => {
          const activeElement = this._container.querySelector(".active");
          activeElement.classList.toggle("active");
          basemapContainer.classList.toggle("active");
          this.setActiveBasemap(id);
          if (sourceType === "vector") {
            if (activeElement.dataset.basemap_type === "raster") {
              map2.setLayoutProperty(
                activeElement.dataset.id,
                "visibility",
                "none"
              );
            }
            if (id === "tag-ip-mu") {
              map_object_events_default.showLayers(map2, "tag-ip");
              map_object_events_default.hideLegend();
            }
            if (id === "maritime") {
              map_object_events_default.showLayers(map2, "maritime");
              map_object_events_default.switcherLegend("block");
            }
          }
          if (sourceType === "raster") {
            map_object_events_default.showLayers(map2, "none");
            map2.setLayoutProperty(id, "visibility", "visible");
            if (activeElement.dataset.basemap_type === "raster") {
              map2.setLayoutProperty(
                activeElement.dataset.id,
                "visibility",
                "none"
              );
            }
            map_object_events_default.hideLegend();
            if (map2.getSource("directions")) {
              const Layers2 = map2.getStyle().layers;
              for (const f of Layers2) {
                if (f.source === "directions") {
                  const idLayer = f.id;
                  map2.moveLayer(idLayer);
                }
              }
            }
          }
        });
      }
      map2.addControl(LegendControl, "bottom-left");
      document.getElementsByClassName("maplibregl-legend-switcher")[0].setAttribute("title", "Afficher la l\xE9gende");
      document.getElementsByClassName("maplibregl-legend-onlyRendered-label")[0].innerText = "Seulement rendu";
      map_object_events_default.switcherLegendList("none");
    });
    return this._container;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container);
  }
};
var basemap_control_default = BasemapControl;

// app.js
var mapCenter = bounds_helper_default.Center;
var mapStyle = map_defaults_default.style;
var mapBounds = bounds_helper_default.initBounds;
var VisibleMapState = new MapState();
VisibleMapState.controls.basemap = new basemap_control_default();
var controlBasemap = VisibleMapState.controls.basemap;
var nominate = "https://nominatim.openstreetmap.org/reverse.php?format=jsonv2";
var initBounds2 = [
  [41.428523678184234, -25.855015532118756],
  [52.75820791383018, -11.711066264154994]
];
var styleMap = "https://vector-tiles.tag-ip.xyz/styles/tag-ip-mu/style.json";
var informationDiv = document.getElementById("informations");
var summaryContainer = document.getElementById("summary");
var distanceContainer = document.getElementById("distance");
var durationContainer = document.getElementById("duration");
var menuBtn = document.getElementById("menu-btn");
var sideMenu = document.getElementById("side-menu");
function displayDirections(locationName, dist, x, y2) {
  const li2 = document.createElement("li");
  const spanDistance = document.createElement("span");
  const span = document.createElement("span");
  li2.setAttribute("class", "list-direction");
  span.setAttribute("class", "decor");
  spanDistance.setAttribute("class", "decor");
  span.textContent = locationName;
  spanDistance.textContent = "".concat(dist, " m");
  li2.appendChild(span);
  li2.appendChild(spanDistance);
  li2.addEventListener("click", () => {
  });
  informationDiv.appendChild(li2);
}
async function getLocation(steps) {
  informationDiv.innerHTML = "";
  for (const step of steps) {
    const cord = step.maneuver.location;
    const dist = step.distance;
    const x = cord[0];
    const y2 = cord[1];
    const url = "".concat(nominate, "&lat=").concat(y2, "&lon=").concat(x, "&zoom=18");
    await fetch(url).then((response) => response.json()).then((data) => {
      const locationName = "".concat(data.display_name.split(",")[0], " ").concat(data.display_name.split(",")[1]);
      displayDirections(locationName, dist, x, y2);
    });
  }
  sideMenu.style.display = "block";
}
function myFunc() {
  const map2 = new import_maplibre_gl.default.Map({
    container: "map",
    style: styleMap,
    center: [47.5303, -18.9006],
    zoom: 10,
    attributionControl: false
  });
  map2.addControl(new import_maplibre_gl.default.AttributionControl(), "bottom-right");
  map2.addControl(new import_maplibre_gl.default.ScaleControl());
  map2.addControl(new import_maplibre_gl.default.FullscreenControl(), "top-right");
  map2.addControl(
    new import_maplibre_gl.default.NavigationControl({ visualizePitch: true }),
    "top-right"
  );
  map2.addControl(controlBasemap, "bottom-right");
  map2.fitBounds(initBounds2);
  const directions = new import_maplibre_gl_directions.default({
    map: map2,
    unit: "metric",
    interactive: true,
    controls: {
      inputs: true,
      instructions: false,
      profileSwitcher: false
    },
    profile: "driving"
  });
  directions.on("route", (e) => {
    console.log(e.route);
    const route = e.route[0];
    if (route) {
      if (!sideMenu.classList.contains("open")) {
        sideMenu.classList.add("open");
        menuBtn.innerHTML = "&lt;";
      }
      const steps = route.legs[0].steps;
      const validSteps = steps.filter((step) => step.name);
      let summary = "";
      if (validSteps.length > 0) {
        const startName = validSteps[0].name;
        const endName = validSteps[validSteps.length - 1].name;
        summary = "".concat(startName, ' <i class="fa-solid fa-arrow-right"></i> ').concat(endName);
      }
      const distance = (route.legs[0].distance / 1e3).toFixed(2);
      const duration = (route.legs[0].duration / 60).toFixed(2);
      summaryContainer.innerHTML = "<p>".concat(summary, "</p>");
      distanceContainer.innerHTML = "<p><strong>Distance:</strong> ".concat(distance, " km</p>");
      durationContainer.innerHTML = "<p><strong>Dur\xE9e:</strong> ".concat(duration, " min</p>");
      getLocation(steps);
    }
  });
  map2.addControl(directions, "top-left");
  menuBtn.addEventListener("click", () => {
    if (sideMenu.classList.contains("open")) {
      menuBtn.innerHTML = "&gt;";
      sideMenu.classList.remove("open");
    } else {
      menuBtn.innerHTML = "&lt;";
      sideMenu.classList.add("open");
    }
  });
  return map2;
}
export {
  myFunc as default
};
/*! Bundled license information:

maplibre-gl/dist/maplibre-gl.js:
  (**
   * MapLibre GL JS
   * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.7.1/LICENSE.txt
   *)

@watergis/maplibre-gl-legend/dist/maplibre-gl-legend.es.js:
  (*! https://mths.be/punycode v1.3.2 by @mathias *)
*/
